<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Dise√±o PK</title>
<!-- Fuente moderna -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
    :root{
        --bg-1: #f8fafc; /* claro */
        --bg-2: #f1f5f9;
        --card: rgba(0,0,0,0.02);
        --muted: #64748b;
        --accent: #34d399; /* verde */
        --accent2: #3b82f6; /* azul */
        --warning: #e74c3c;
        --glass: rgba(255,255,255,0.8);
        --glass-border: rgba(0,0,0,0.08);
        --glass-text: rgba(15,23,42,0.94);
        /* Tama√±os de botones principales (f√°cil de personalizar) */
        --top-btn-height: 64px; /* altura por defecto */
        --top-btn-max-width: 360px; /* anchura m√°xima por bot√≥n */
        --top-btn-font-size: 14px; /* tama√±o de la tipograf√≠a dentro del bot√≥n */
    }
    html,body{height:100%;margin:0;}
    /* Ocultar barras de scroll - navegaci√≥n solo con mouse */
    ::-webkit-scrollbar { display:none; }
    html { -ms-overflow-style:none; scrollbar-width:none; }
    /* ligera escala global para que la interfaz quepa mejor en pantallas grandes */
    body {
        transform: scale(1);
        transform-origin: top center;
        -webkit-transform: scale(1);
        -webkit-transform-origin: top center;
        font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: linear-gradient(135deg, var(--bg-1) 0%, var(--bg-2) 100%);
        color: var(--glass-text);
    }
    /* stage */
    .container {
        display: flex;
        gap: 10px;
        border-radius: 12px;
        padding: 12px 10px;
        background: linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0.92));
        box-shadow: 0 12px 30px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.9);
        max-width: 100%;
        width: 100%;
        border: 1px solid rgba(0,0,0,0.06);
        justify-content: flex-start;
        flex-wrap: nowrap;
        overflow: visible;
    }
    .column {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0 2px;
        flex: 1 1 0;
        min-width: 140px;
        max-width: 360px;
        background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.4));
        padding: 10px 8px;
        border-radius: 10px;
        border: 1px solid rgba(0,0,0,0.08);
        position: relative;
        z-index: 1;
        transition: transform 220ms ease, box-shadow 220ms ease;
        flex-shrink: 0;
        box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        max-height: none;
        overflow-y: auto;
        overflow-x: hidden;
    }
    .column:hover{ transform: translateY(-4px); box-shadow: 0 14px 30px rgba(0,0,0,0.1); }
    .column-header {
        font-weight: 800;
        text-align: center;
        margin-bottom: 10px;
        color: var(--glass-text);
        background: linear-gradient(90deg, rgba(0,0,0,0.04), rgba(0,0,0,0.02));
        padding: 6px 8px;
        border-radius: 8px;
        width: 100%;
        box-shadow: inset 0 -4px 12px rgba(0,0,0,0.03);
        font-size: 15px;
        letter-spacing: 0.3px;
    }
    .column .sol-timer{
        font-size: 12px;
        color: #06364a;
        margin-top: 6px;
        font-weight: 800;
        text-align: center;
        background: rgba(255,255,255,0.9);
        padding: 4px 6px;
        border-radius: 8px;
        box-shadow: 0 6px 18px rgba(2,6,23,0.06);
        min-width: 80px;
        margin-left: auto;
        margin-right: auto;
    }
    /* cabecera NO clickable: selecci√≥n por t√≠tulo deshabilitada */
    .column-header {
        cursor: default;
        user-select: none;
        pointer-events: auto; /* keep pointer events for future features but prevent click-to-select behavior */
    }
    .block {
        width: 86%;
        max-width: 240px;
        height: 64px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 10px;
        background: linear-gradient(180deg,#fff85a,#fff069 60%);
        border-radius: 6px;
        border: 1px solid rgba(0,0,0,0.14);
        margin: 8px 0;
        box-shadow: 0 6px 14px rgba(3,7,18,0.12), inset 0 -6px 18px rgba(255,255,255,0.35);
        transition: transform 180ms ease, opacity 160ms ease;
        cursor: pointer;
        touch-action: manipulation;
        -webkit-tap-highlight-color: rgba(59,130,246,0.3);
        user-select: none;
    }
    .block .label{ display:block; font-size:18px; text-align:center; margin:0; color:#0b1220; font-weight:800; pointer-events:none; 
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
    /* selecci√≥n de parcial (click) */
    .block.selected-parcial{
        outline: 3px solid rgba(59,130,246,0.95);
        box-shadow: 0 10px 30px rgba(59,130,246,0.18), inset 0 -4px 10px rgba(255,255,255,0.4);
        transform: translateY(-3px);
    }
    /* parcial en estado 'solicitado' ‚Äî titilar */
    @keyframes blink-partial {
        0% {
            box-shadow: 0 12px 28px rgba(34,197,94,0.40), 0 0 0 0 rgba(34,197,94,0);
            border-color: rgba(34,197,94,0.98);
            transform: translateY(-2px) scale(1);
            background: linear-gradient(180deg,#34d399,#10b981);
        }
        25% {
            box-shadow: 0 18px 44px rgba(231,76,60,0.48), 0 0 10px rgba(231,76,60,0.26);
            border-color: rgba(231,76,60,0.99);
            transform: translateY(-3px) scale(1.03);
            background: linear-gradient(180deg,#f87171,#ef4444);
        }
        50% {
            box-shadow: 0 14px 36px rgba(250,204,21,0.44), 0 0 10px rgba(250,204,21,0.24);
            border-color: rgba(250,204,21,0.99);
            transform: translateY(-2px) scale(1.02);
            background: linear-gradient(180deg,#fff85a,#fff069 60%);
        }
        75% {
            box-shadow: 0 18px 44px rgba(231,76,60,0.48), 0 0 14px rgba(231,76,60,0.26);
            border-color: rgba(231,76,60,0.99);
            transform: translateY(-3px) scale(1.03);
            background: linear-gradient(180deg,#f87171,#ef4444);
        }
        100% {
            box-shadow: 0 12px 28px rgba(34,197,94,0.40), 0 0 0 0 rgba(34,197,94,0);
            border-color: rgba(34,197,94,0.98);
            transform: translateY(-2px) scale(1);
            background: linear-gradient(180deg,#34d399,#10b981);
        }
    }
    .block.requested{
        animation: blink-partial 1.2s linear infinite;
        border-width: 2px;
        border-style: solid;
        z-index: 6;
        color: #0b1220;
        /* asegurar que el texto (si existe) sea visible sobre fondos cambiantes */
    }
    .block.appear{ animation: pop 320ms cubic-bezier(.2,.9,.3,1); }
    .block.removing{ animation: fadeOut 220ms ease forwards; }
    @keyframes pop{ 0%{ transform: scale(.86); opacity:0 } 60%{ transform: scale(1.04); opacity:1 } 100%{ transform: scale(1); } }
    @keyframes fadeOut{ to { transform: scale(.94); opacity:0 } }
    /* contenedor principal: layout vertical con botones arriba */
    .main-container {
        display: flex;
        flex-direction: column;
        gap: 12px;
        width: 100%;
        max-width: none; /* permitir que ocupe todo el ancho disponible */
    }
    /* fila superior: botones */
    .top-controls {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: auto auto;
        gap: 24px 300px;
        width: 100%;
        max-width: 100%;
        margin: 0 auto;
        padding: 6px 0 0 0;
        position: relative;
        z-index: 10;
        background: transparent;
    }
    
    /* Posicionamiento de botones en grid */
    #btn-anular-solicitud {
        grid-column: 3;
        grid-row: 1;
    }
    
    #btn-entrada {
        grid-column: 1;
        grid-row: 2;
    }
    
    #btn-salida {
        grid-column: 2;
        grid-row: 2;
    }
    
    #btn-solicitar {
        grid-column: 3;
        grid-row: 2;
    }
    /* contenedor inferior: b√∫squeda izq, l√≠neas der */
    .bottom-container {
        display: flex;
        gap: 12px;
        width: 100%;
        flex: 1;
    }
    /* panel izquierdo abajo: b√∫squeda y gestionar (m√°s angosto) */
    .controls {
        border-radius: 12px;
        padding: 8px 10px;
        background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.85));
        width: 240px; /* reducir ancho para ceder espacio a las columnas */
        min-width: 200px;
        border: 1px solid rgba(0,0,0,0.06);
        backdrop-filter: blur(6px) saturate(120%);
        box-shadow: 0 12px 30px rgba(0,0,0,0.08);
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-sizing: border-box; /* ensure padding included in width */
        overflow: hidden; /* keep children visually inside the panel */
    }

    /* Ocultar el panel izquierdo para aprovechar todo el ancho disponible */
    .controls{ display:none !important; width:0 !important; min-width:0 !important; padding:0 !important; margin:0 !important }
        /* floating top-left actions (visual style) */
        .floating-actions{ position: fixed; left: 18px; top: 18px; display:flex; flex-direction:column; gap:10px; z-index:120 }
        /* Botones flotantes: m√°s grandes y dispositivos amigables */
        .floating-actions button{
            min-width:110px;           /* anchura m√≠nima reducida */
            width:auto;
            height:40px;               /* altura reducida */
            padding:6px 10px;          /* menos padding */
            border-radius:10px;
            border:none;
            font-weight:600;
            color:white;
            background: linear-gradient(90deg,#3b82f6,#2563eb);
            box-shadow: 0 8px 18px rgba(37,99,235,0.12);
            cursor:pointer;
            transition: transform 120ms ease, box-shadow 120ms ease;
            display:flex;
            align-items:center;
            justify-content:center;
            text-align:center;
            white-space:normal;
            line-height:1.05;
            font-size:13px;            /* tama√±o de texto reducido */
        }
        .floating-actions button:hover{ transform: translateY(-3px); box-shadow: 0 16px 36px rgba(37,99,235,0.16); }
        /* make export button same color / look as manage button */
        .floating-actions .export-btn{ background: linear-gradient(90deg,#3b82f6,#2563eb); }
        @media (max-width:900px){
            .floating-actions{ position: static; margin-bottom:12px; display:flex; flex-direction:row; gap:8px }
            .floating-actions button{ width:auto; min-width:110px; height:48px; font-size:13px }
        }

        /* responsive for top-controls: keep compact info usable on small screens */
        @media (max-width:900px){
            .top-controls{ grid-template-columns: repeat(2,1fr); gap:12px 12px }
        }

        /* floating history card (moved m√°s a la derecha para separar de los botones) */
          /* hacer el panel un poco m√°s peque√±o y desplazado ligeramente hacia la derecha
              para que no se superponga con el bot√≥n "ABASTECER KAMBAN" */
        /* con el panel lateral eliminado, acercamos el hist√≥rico al borde izquierdo */
        /* Position floating history to the right side, below buttons */
        .floating-history{ position: fixed !important; left: 420px !important; top: 100px !important; width: 280px; z-index:5; pointer-events: none; }
        .floating-history .history-controls{ display:flex; gap:6px; align-items:center; justify-content:space-between; margin-bottom:6px }
        .floating-history .drag-handle{ width:34px; height:34px; border-radius:8px; border:0; background: rgba(11,18,32,0.06); cursor:grab; display:inline-flex; align-items:center; justify-content:center; font-weight:800; color: var(--glass-text); }
        .floating-history .drag-handle:active{ cursor:grabbing }
        .floating-history .history-reset{ width:34px; height:34px; border-radius:8px; border:0; background: rgba(11,18,32,0.04); cursor:pointer; display:inline-flex; align-items:center; justify-content:center; font-size:14px }
        .floating-history.dragging { opacity:0.96; transform: none; transition: none }
        .floating-history .history-card{ padding:12px; border-radius:12px; box-shadow: 0 18px 48px rgba(2,6,23,0.08); border:1px solid rgba(0,0,0,0.04); background:linear-gradient(180deg,rgba(255,255,255,0.98),rgba(250,250,250,0.96)); pointer-events: auto; }
        .floating-history .search-row{ display:flex; gap:8px; align-items:center; }
        .floating-history .search-input{ width:100%; }
        .floating-history .search-clear{ padding:6px;border-radius:8px }
        /* mostrar exactamente 1 tarjeta del historial (ni m√°s ni menos) */
        /* Elegimos una altura fija de tarjeta que contiene: t√≠tulo, l√≠nea, solicitud, entrega y tiempo */
        #recent-history-list{
            list-style:none;
            padding:0;           /* quitar padding para que la tarjeta encaje exactamente */
            margin:0;
            height:130px;       /* reducir altura para panel m√°s compacto */
            overflow-y:auto;    /* permitir desplazamiento con botones o rueda */
            scroll-snap-type: y mandatory; /* snap por tarjeta */
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            position:relative;
        }
        /* ocultar scrollbar visual (mantener funcionalidad) */
        #recent-history-list::-webkit-scrollbar{ width:8px; height:8px }
        #recent-history-list::-webkit-scrollbar-thumb{ background: rgba(0,0,0,0.12); border-radius:8px }
        #recent-history-list::-webkit-scrollbar-track{ background:transparent }
        /* centrar verticalmente los botones de navegaci√≥n respecto a la tarjeta visible */
        #recent-history .recent-nav{ position:absolute; right:8px; top:50%; transform:translateY(-50%); display:none; flex-direction:column; gap:6px; z-index:130 }
        #recent-history .recent-nav button{ width:34px; height:34px; border-radius:8px; border:0; background: rgba(11,18,32,0.06); cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:800; color: var(--glass-text); }
        #recent-history .recent-nav button:hover{ background: rgba(11,18,32,0.10); transform: translateY(-2px); }
        @media (max-width:900px){ .floating-history{ position: static; margin: 8px 0 12px 0; width: auto; left: auto } }

        /* estilo por defecto para los items de historial: tarjeta con altura fija que encaja exactamente en el contenedor */
        #recent-history-list li{
            background: linear-gradient(180deg,#ffffff,#fbfdff);
            border-radius:12px;
            padding:10px 12px;
            margin:0;
            box-shadow: 0 4px 16px rgba(2,6,23,0.06);
            border-left: 4px solid rgba(59,130,246,0.3);
            box-sizing: border-box;
            height: 130px;
            overflow: hidden;
            scroll-snap-align: start;
            transition: all 200ms ease;
        }
        
        #recent-history-list li:active {
            box-shadow: 0 8px 24px rgba(2,6,23,0.1);
            transform: translateY(-2px);
        }
        
        @media (max-width:768px) {
            #recent-history-list li {
                padding: 12px 12px;
                border-radius: 10px;
                box-shadow: 0 3px 12px rgba(2,6,23,0.05);
            }
        }
        #recent-history-list li .order-title{ font-weight:800; color:#0b2a55; margin-bottom:6px }
        #recent-history-list li .item-row{ display:flex; gap:8px; align-items:center; font-size:13px; color: #334155 }

        /* responsive: en pantallas peque√±as hacemos la tarjeta ligeramente m√°s corta para que encaje mejor */
        @media (max-width:900px){
            #recent-history-list{ height:120px }
            #recent-history-list li{ height:110px }
            #recent-history .recent-nav button{ width:30px; height:30px }
            .floating-history{ left: calc(18px + 140px); width: 240px }
        }

        /* Responsiveness for columns and blocks */
        @media (max-width:1400px){
            .column{ min-width:120px; max-width:300px }
            .block{ height:58px }
        }
        @media (max-width:1100px){
            .column{ min-width:110px; max-width:240px }
            .block{ height:52px }
        }
        @media (max-width:700px){
            .column{ min-width:92px; max-width:160px }
            .block{ height:50px; width:90% }
        }
        /* ===== OPTIMIZACI√ìN M√ìVIL - DISE√ëO COMPACTO Y T√ÅCTIL ===== */
        @media (max-width:768px){
            body {
                padding: 6px;
                gap: 6px;
                padding-bottom: 40px;
                background: linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%);
            }
            
            .title {
                font-size: 14px;
                margin: 0 0 6px 0;
                padding: 8px 10px;
                border-radius: 8px;
                line-height: 1.2;
                box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            }
            
            .main-container {
                gap: 6px;
                width: 100%;
            }
            
            /* Botones principales: compactos */
            .top-controls {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 6px;
                padding: 0;
                margin: 0;
                position: relative;
                z-index: 5;
            }
            
            #btn-anular-solicitud { grid-column: 1; grid-row: 1; }
            #btn-entrada { grid-column: 2; grid-row: 1; }
            #btn-salida { grid-column: 1; grid-row: 2; }
            #btn-solicitar { grid-column: 2; grid-row: 2; }
            #btn-panel-control { 
                grid-column: 1 / 3; 
                grid-row: 3; 
                height: 44px !important;
                font-size: 11px !important;
                padding: 8px !important;
            }
            
            /* INDICADOR ESCLUSA LLENA - ULTRA PREMIUM */
            #esclusa-indicator {
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                display: none;
                align-items: center;
                gap: 15px;
                padding: 18px 32px;
                background: linear-gradient(135deg, #ff0000 0%, #b91c1c 50%, #7f1d1d 100%);
                border-radius: 16px;
                cursor: pointer;
                animation: flash-ultra 1s ease-in-out infinite;
                border: 3px solid #fff;
                box-shadow: 0 0 30px rgba(255,0,0,0.8),
                            0 0 60px rgba(255,0,0,0.5),
                            0 10px 40px rgba(0,0,0,0.5),
                            inset 0 2px 4px rgba(255,255,255,0.3),
                            inset 0 -2px 4px rgba(0,0,0,0.3);
                backdrop-filter: blur(10px);
                transition: all 0.3s ease;
                transform-style: preserve-3d;
            }
            
            #esclusa-indicator.active {
                display: flex;
            }
            
            #esclusa-indicator:hover {
                transform: scale(1.08) translateY(-3px);
                box-shadow: 0 0 50px rgba(255,0,0,1),
                            0 0 80px rgba(255,0,0,0.6),
                            0 15px 50px rgba(0,0,0,0.6);
            }
            
            #esclusa-indicator::before {
                content: 'üö®';
                font-size: 32px;
                animation: rotate-pulse 1.5s ease-in-out infinite;
                filter: drop-shadow(0 0 10px rgba(255,255,255,0.8));
            }
            
            @keyframes rotate-pulse {
                0%, 100% { 
                    transform: rotate(0deg) scale(1); 
                }
                25% { 
                    transform: rotate(-20deg) scale(1.1); 
                }
                50% { 
                    transform: rotate(20deg) scale(1.15); 
                }
                75% { 
                    transform: rotate(-15deg) scale(1.1); 
                }
            }
            
            @keyframes flash-ultra {
                0%, 100% {
                    background: linear-gradient(135deg, #ff0000 0%, #b91c1c 50%, #7f1d1d 100%);
                    box-shadow: 0 0 30px rgba(255,0,0,0.8),
                                0 0 60px rgba(255,0,0,0.5),
                                0 10px 40px rgba(0,0,0,0.5),
                                inset 0 2px 4px rgba(255,255,255,0.3);
                    border-color: #fff;
                }
                50% {
                    background: linear-gradient(135deg, #ffff00 0%, #ff0000 50%, #ff0000 100%);
                    box-shadow: 0 0 50px rgba(255,255,0,1),
                                0 0 80px rgba(255,0,0,0.8),
                                0 0 100px rgba(255,0,0,0.5),
                                0 15px 50px rgba(0,0,0,0.6),
                                inset 0 2px 6px rgba(255,255,255,0.5);
                    border-color: #ffff00;
                }
            }
            
            .esclusa-text {
                color: #ffffff;
                font-size: 24px;
                font-weight: 900;
                letter-spacing: 3px;
                text-transform: uppercase;
                white-space: nowrap;
                text-shadow: 
                    -4px -4px 0 #000,
                    4px -4px 0 #000,
                    -4px 4px 0 #000,
                    4px 4px 0 #000,
                    -4px 0 0 #000,
                    4px 0 0 #000,
                    0 -4px 0 #000,
                    0 4px 0 #000,
                    -2px -2px 0 #000,
                    2px -2px 0 #000,
                    -2px 2px 0 #000,
                    2px 2px 0 #000,
                    0 8px 16px rgba(0,0,0,1),
                    0 0 30px rgba(255,255,0,0.8),
                    0 0 40px rgba(255,255,255,0.6);
                position: relative;
                filter: drop-shadow(0 0 15px rgba(255,255,255,0.9));
                animation: text-glow 1s ease-in-out infinite;
            }
            
            @keyframes text-glow {
                0%, 100% {
                    text-shadow: 
                        -4px -4px 0 #000, 4px -4px 0 #000,
                        -4px 4px 0 #000, 4px 4px 0 #000,
                        -4px 0 0 #000, 4px 0 0 #000,
                        0 -4px 0 #000, 0 4px 0 #000,
                        -2px -2px 0 #000, 2px -2px 0 #000,
                        -2px 2px 0 #000, 2px 2px 0 #000,
                        0 8px 16px rgba(0,0,0,1),
                        0 0 30px rgba(255,255,0,0.8),
                        0 0 40px rgba(255,255,255,0.6);
                }
                50% {
                    text-shadow: 
                        -4px -4px 0 #000, 4px -4px 0 #000,
                        -4px 4px 0 #000, 4px 4px 0 #000,
                        -4px 0 0 #000, 4px 0 0 #000,
                        0 -4px 0 #000, 0 4px 0 #000,
                        -2px -2px 0 #000, 2px -2px 0 #000,
                        -2px 2px 0 #000, 2px 2px 0 #000,
                        0 8px 16px rgba(0,0,0,1),
                        0 0 50px rgba(255,255,0,1),
                        0 0 70px rgba(255,255,255,1);
                }
            }
            
            .esclusa-text::after {
                content: '';
                position: absolute;
                bottom: -2px;
                left: 0;
                right: 0;
                height: 2px;
                background: linear-gradient(90deg, 
                    transparent 0%, 
                    rgba(255,255,255,0.5) 50%, 
                    transparent 100%);
                animation: shine 2s ease-in-out infinite;
            }
            
            @keyframes shine {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 1; }
            }
            
            .top-controls button {
                height: 38px;
                font-size: 9px;
                padding: 6px 8px;
                border-radius: 7px;
                font-weight: 700;
                box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                line-height: 1.1;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(59,130,246,0.2);
            }
            
            .top-controls button:active {
                transform: scale(0.96);
                box-shadow: 0 1px 4px rgba(0,0,0,0.06);
            }
            
            .right-panel {
                width: 100%;
                max-height: none;
                overflow: visible;
                position: relative;
            }
            
            .container {
                gap: 4px;
                padding: 6px 3px;
                flex-wrap: nowrap;
                overflow-x: auto;
                overflow-y: visible;
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch;
                background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.90));
                box-shadow: 0 2px 10px rgba(0,0,0,0.04);
                position: relative;
                z-index: 1;
            }
            
            .container::-webkit-scrollbar {
                height: 5px;
            }
            
            .container::-webkit-scrollbar-track {
                background: rgba(0,0,0,0.02);
            }
            
            .container::-webkit-scrollbar-thumb {
                background: rgba(59,130,246,0.4);
                border-radius: 3px;
            }
            
            /* Columnas muy compactas */
            .column {
                min-width: 70px;
                max-width: 85px;
                padding: 4px 3px;
                flex-shrink: 0;
                border-radius: 6px;
                background: rgba(255,255,255,0.96);
                border: 1px solid rgba(59,130,246,0.2);
                box-shadow: 0 2px 6px rgba(0,0,0,0.04);
                max-height: 450px;
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            .column::-webkit-scrollbar {
                width: 3px;
            }
            
            .column::-webkit-scrollbar-track {
                background: rgba(0,0,0,0.02);
            }
            
            .column::-webkit-scrollbar-thumb {
                background: rgba(59,130,246,0.3);
                border-radius: 2px;
            }
            
            .column:hover { transform: none; }
            
            .column.empty {
                border-color: rgba(239,68,68,0.4);
                background: rgba(254,242,242,0.96);
            }
            
            .column-header {
                font-size: 8px;
                font-weight: 800;
                padding: 3px 2px;
                margin-bottom: 4px;
                color: #1e293b;
                letter-spacing: 0.1px;
                background: rgba(0,0,0,0.02);
                border-radius: 4px;
            }
            
            /* Bloques/parciales: √°rea t√°ctil optimizada */
            .block {
                height: 32px;
                width: 100%;
                margin: 3px 0;
                font-size: 7px;
                font-weight: 700;
                border-radius: 5px;
                padding: 2px;
                line-height: 1.05;
                box-shadow: 0 1px 4px rgba(0,0,0,0.06);
                cursor: pointer;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(59,130,246,0.3);
                min-height: 32px;
                user-select: none;
            }
            
            .block:active {
                transform: scale(0.96);
                box-shadow: 0 1px 2px rgba(0,0,0,0.04);
            }
            
            .block .label {
                font-size: 7px;
                font-weight: 700;
                line-height: 1.05;
                pointer-events: none;
                user-select: none;
            }
            
            .sol-timer, .col-sol-timer, .col-empty-timer {
                font-size: 7px;
                margin-top: 2px;
                padding: 2px 2px;
                border-radius: 3px;
                font-weight: 700;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                text-align: center;
            }
            
            .floating-actions {
                display: none !important;
            }
            
            .floating-history {
                position: relative;
                margin: 10px 0 0 0;
                width: 100%;
                left: auto;
                top: auto;
                z-index: 5;
            }
            
            .history-card {
                padding: 8px;
                font-size: 10px;
                border-radius: 8px;
                background: rgba(255,255,255,0.98);
                border: 1px solid rgba(59,130,246,0.2);
                box-shadow: 0 3px 12px rgba(0,0,0,0.05);
            }
            
            #recent-history-list {
                height: 90px;
            }
            
            #recent-history-list li {
                height: 90px;
                padding: 6px 8px;
                font-size: 9px;
            }
            
            .bottom-container {
                padding: 0;
                gap: 0;
            }
            
            .controls {
                display: none !important;
            }
        }
        @media (max-width:480px){
            body {
                padding: 5px;
                gap: 5px;
                padding-bottom: 15px;
            }
            
            .title {
                font-size: 12px;
                padding: 6px 8px;
                margin: 0 0 5px 0;
                border-radius: 6px;
            }
            
            .container {
                gap: 3px;
                padding: 5px 2px;
            }
            
            .column {
                min-width: 65px;
                max-width: 78px;
                padding: 3px 2px;
                border-radius: 5px;
                max-height: 400px;
                overflow-y: auto;
            }
            
            .column::-webkit-scrollbar {
                width: 2px;
            }
            
            .column::-webkit-scrollbar-thumb {
                background: rgba(59,130,246,0.3);
            }
            
            .column-header {
                font-size: 7px;
                margin-bottom: 3px;
                padding: 2px 1px;
            }
            
            .block {
                height: 28px;
                font-size: 6px;
                margin: 2px 0;
                padding: 2px 1px;
                border-radius: 4px;
                min-height: 28px;
            }
            
            .block .label {
                font-size: 6px;
                line-height: 1;
            }
            
            .top-controls {
                gap: 5px;
            }
            
            .top-controls button {
                height: 36px;
                font-size: 8px;
                padding: 5px 6px;
                border-radius: 6px;
            }
            
            .sol-timer, .col-sol-timer, .col-empty-timer {
                font-size: 5px;
                padding: 1px 2px;
                margin-top: 2px;
            }
            
            .history-card {
                padding: 6px;
                font-size: 9px;
            }
            
            #recent-history-list {
                height: 80px;
            }
            
            #recent-history-list li {
                height: 80px;
                padding: 5px 6px;
                font-size: 8px;
            }
            
            .floating-history .drag-handle,
            .floating-history .history-reset,
            #recent-history .recent-nav button {
                width: 24px;
                height: 24px;
                font-size: 10px;
            }
        }
    /* panel derecho: contenedor de l√≠neas */
    .right-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: auto; /* permitir scroll interno en panel derecho */
        max-height: calc(100vh - 140px); /* dejar espacio para cabecera y controles */
    }
    .controls h3 {
        display: none;
    }
    /* Layout label + buscador en vertical */
    .controls .label-row {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 6px;
        margin-bottom: 10px;
        margin-top: 0;
    }
    .controls label {
        font-weight: bold;
        font-size: 10px;
        color: var(--glass-text);
    }
    .search-input {
        width: 100%;
        padding: 7px 9px;
        border: 1px solid rgba(0,0,0,0.08);
        border-radius: 7px;
        background: rgba(255,255,255,0.8);
        color: var(--glass-text);
        box-shadow: inset 0 4px 10px rgba(0,0,0,0.04);
        font-size: 11px;
    }
    /* buscador: atenuar elementos no coincidentes y resaltar coincidencias */
    .block.search-dim { opacity: 0.18; transform: scale(0.98); filter: grayscale(40%); }
    .block.search-match { outline: 3px solid rgba(59,130,246,0.92); box-shadow: 0 12px 32px rgba(59,130,246,0.16); transform: translateY(-4px); }
    .search-row { display:flex; gap:8px; align-items:center; }
    .search-clear { background:transparent;border:0;color:var(--muted);cursor:pointer;font-weight:700;padding:6px;border-radius:6px }
    /* historial: resaltar o atenuar entradas del historial cuando se busca */
    #recent-history-list li.history-dim { opacity: 0.28; filter: grayscale(50%); }
    #recent-history-list li.history-match { background: linear-gradient(90deg, rgba(59,130,246,0.06), rgba(59,130,246,0.02)); border-left: 4px solid rgba(59,130,246,0.9); padding-left:8px; }
    .color-boxes {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        gap: 8px;
        margin: 0;
        padding: 0;
    }
    .color-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }
    /* usar button para accesibilidad */
    .color-box {
        flex: 1;
        height: 32px;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.16s, box-shadow 0.16s, opacity 0.12s;
        background-clip: padding-box;
        padding: 0 6px;
        border: none;
        box-shadow: 0 6px 16px rgba(3,7,18,0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        color: white;
        font-size: 9px;
        text-align: center;
        line-height: 1.2;
        white-space: normal;
    }

    /* Botones principales (top-controls) ‚Äî m√°s altos y con acento superior */
    .top-controls .color-box{
        /* Usar anchura fluida dentro de la celda del grid y limitar por max-width */
        width: 100%;
        max-width: var(--top-btn-max-width);
        height: var(--top-btn-height);
        padding: 0 14px;
        font-size: var(--top-btn-font-size);
        letter-spacing: 0.6px;
        font-weight: 700;
        box-shadow: 0 12px 36px rgba(3,7,18,0.16);
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        justify-self: stretch; /* ocupar todo el ancho de la celda */
        align-self: center;
    }
    .top-controls .color-box::before{
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 12px; /* 'grosor' visual arriba */
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        background: linear-gradient(180deg, rgba(255,255,255,0.22), rgba(255,255,255,0.06));
        pointer-events: none;
    }
    .top-controls .color-box:active{ transform: translateY(1px) scale(0.996); }
    .color-box.blue{ box-shadow: 0 8px 30px rgba(59,130,246,0.14), 0 2px 6px rgba(0,0,0,0.25); }
    .color-box.green{ box-shadow: 0 8px 30px rgba(52,211,153,0.12), 0 2px 6px rgba(0,0,0,0.25); }
    .color-box:focus {
        outline: none;
        transform: translateY(-3px) scale(1.03);
        box-shadow: 0 14px 32px rgba(0,0,0,0.12);
    }
    .color-box:active {
        transform: translateY(0) scale(0.98);
        box-shadow: 0 6px 16px rgba(0,0,0,0.1);
    }
    /* drag ghost used during touch/pointer drag */
    .drag-ghost{ position:fixed; pointer-events:none; transform:translate(-50%,-50%); z-index:9999; opacity:0.95; border-radius:6px; box-shadow:0 12px 30px rgba(0,0,0,0.18); }
    /* global drag handle style (used by floating-history and top-info) */
    .drag-handle{ width:34px; height:34px; border-radius:8px; border:0; background: rgba(11,18,32,0.06); cursor:grab; display:inline-flex; align-items:center; justify-content:center; font-weight:800; color: var(--glass-text); touch-action:none; }
    .drag-handle:active{ cursor:grabbing }
    /* visual highlight for drop target */
    .btn-drop-target{ box-shadow: 0 0 0 6px rgba(59,130,246,0.12) !important; transform: translateY(-2px) scale(1.02) !important; }
    /* barcode modal */
    .barcode-modal{ position: fixed; left:50%; top:50%; transform:translate(-50%,-50%); background: #fff; border-radius:10px; box-shadow:0 20px 40px rgba(2,6,23,0.18); padding:14px; z-index:13000; width:360px; max-width:92vw; display:none; }
    .barcode-modal.open{ display:block; }
    .barcode-modal h3{ margin:0 0 8px 0; font-size:16px }
    .barcode-modal .scan-list{ max-height:220px; overflow:auto; margin:8px 0; padding:6px; border-radius:6px; background: #f8fafc; }
    .barcode-modal .scan-item{ padding:6px 8px; border-bottom:1px solid rgba(0,0,0,0.04); font-weight:600 }
    .barcode-modal .modal-actions{ display:flex; gap:8px; margin-top:8px }
    .color-box:hover {
        transform: translateY(-6px) scale(1.04);
        filter: saturate(1.08);
    }
    /* ajustar etiqueta debajo del bot√≥n para mantenerse legible */
    .color-label {
        font-size: 9px;
        text-align: center;
        color: var(--glass-text);
        font-weight: 600;
        line-height: 1.1;
        max-width: 100%;
    }
    .color-label {
        font-size: 12px;
        text-align: center;
        max-width: 110px;
        color: var(--glass-text);
        font-weight: 500;
    }
    .blue { background-color: #3498db; }
    .green { background-color: #2ecc71; }
    .orange { background-color: #f97316; }
    .status {
        min-height: 16px;
        color: var(--glass-text);
        font-size: 12px;
        margin-top: 10px;
        text-align: center;
    }
    /* resaltar columna seleccionada sin cambiar layout */
    .column.selected {
        box-shadow: 0 20px 50px rgba(59,130,246,0.14), 0 6px 18px rgba(0,0,0,0.1);
        transform: translateY(-8px);
    }
    /* alerta llamativa para l√≠neas vac√≠as */
    .alert {
        width: calc(100% - 80px);
        max-width: 1100px;
        background: linear-gradient(90deg,#e74c3c,#ec7063);
        color: #fff;
        padding: 12px 16px;
        border-radius: 6px;
        box-shadow: 0 6px 18px rgba(231,76,60,0.22);
        font-weight: 700;
        text-align: center;
        margin-bottom: 8px;
        animation: pulse 1.6s ease-in-out infinite;
        position: relative;
        z-index: 9999; /* ensure it's above other elements */
        transition: opacity 220ms ease, transform 260ms ease;
    }
    .alert.hidden { display: none !important; opacity:0 }
    @keyframes pulse {
        0% { transform: translateY(0); box-shadow: 0 6px 18px rgba(0,0,0,0.18); }
        50% { transform: translateY(-4px); box-shadow: 0 10px 24px rgba(0,0,0,0.26); }
        100% { transform: translateY(0); box-shadow: 0 6px 18px rgba(0,0,0,0.18); }
    }
    /* marcar visualmente columnas sin parciales */
    .column.empty {
        border: 3px solid rgba(231,76,60,0.95);
        outline: none;
        box-shadow: 0 14px 34px rgba(231,76,60,0.20), 0 0 0 6px rgba(231,76,60,0.06) inset;
        transform: translateY(-2px);
        transition: box-shadow 260ms ease, transform 260ms ease, border-color 260ms ease;
        position: relative;
    }
    @keyframes pulse-empty {
        0% { box-shadow: 0 10px 26px rgba(231,76,60,0.16), 0 0 0 0 rgba(231,76,60,0); transform: translateY(0); }
        50% { box-shadow: 0 18px 42px rgba(231,76,60,0.28), 0 0 16px rgba(231,76,60,0.08); transform: translateY(-4px); }
        100% { box-shadow: 0 10px 26px rgba(231,76,60,0.16), 0 0 0 0 rgba(231,76,60,0); transform: translateY(0); }
    }
    .column.empty.animate {
        animation: pulse-empty 1.6s ease-in-out infinite;
    }
    /* visual de l√≠nea inactiva */
    .column.inactive {
        opacity: 0.44;
        filter: grayscale(70%);
        transform: none !important;
    }
    .inactive-badge{
        position:absolute;
        top:-16px;
        right:8px;
        color:#fff;
        padding:4px 8px;
        border-radius:8px;
        font-size:11px;
        background: rgba(125,31,31,0.92);
        box-shadow: 0 6px 14px rgba(0,0,0,0.15);
    }
    /* toggle switch para activar/desactivar l√≠nea */
    .toggle-switch{
        position: absolute; top: -14px; left: 8px;
        width: 36px; height: 18px;
        background: #e5e7eb; border: none; border-radius: 9px;
        cursor: pointer; transition: all 220ms ease;
        display: flex; align-items: center; padding: 0 2px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }
    .toggle-switch.active{ background: #10b981; }
    .toggle-switch::after{
        content: '';
        width: 14px;
        height: 14px;
        background: white;
        border-radius: 50%;
        transition: transform 220ms ease;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }
    /* move the knob to the right based on the smaller width (36 - 14 - padding*2 = 20) */
    .toggle-switch.active::after{ transform: translateX(20px); }
    .toggle-switch:hover{ transform: scale(1.05); }
    
    /* Modal de password personalizado */
    .password-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100000;
        animation: fadeIn 0.2s ease;
    }
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    .password-modal {
        background: white;
        border-radius: 12px;
        padding: 24px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        max-width: 400px;
        width: 90%;
        animation: slideUp 0.3s ease;
    }
    @keyframes slideUp {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }
    .password-modal h3 {
        margin: 0 0 16px 0;
        font-size: 18px;
        color: #1e293b;
        font-weight: 600;
    }
    .password-input-wrapper {
        position: relative;
        margin-bottom: 20px;
    }
    .password-modal input {
        width: 100%;
        padding: 12px 45px 12px 12px;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 16px;
        box-sizing: border-box;
        transition: border-color 0.2s;
    }
    .password-modal input:focus {
        outline: none;
        border-color: #3b82f6;
    }
    .password-toggle-eye {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        cursor: pointer;
        font-size: 20px;
        padding: 4px;
        color: #64748b;
        transition: color 0.2s;
    }
    .password-toggle-eye:hover {
        color: #1e293b;
    }
    .password-modal-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
    }
    .password-modal-buttons button {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
    }
    .password-modal-buttons .btn-cancel {
        background: #f1f5f9;
        color: #475569;
    }
    .password-modal-buttons .btn-cancel:hover {
        background: #e2e8f0;
    }
    .password-modal-buttons .btn-accept {
        background: #6b7904;
        color: white;
    }
    .password-modal-buttons .btn-accept:hover {
        background: #5a6603;
    }
    
    /* t√≠tulo con efecto glassmorphism - MEJORADO */
    .title {
        font-size: 28px;
        font-weight: 800;
        letter-spacing: -0.8px;
        color: #0f172a;
        text-align: center;
        background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85));
        backdrop-filter: blur(12px) saturate(180%);
        padding: 16px 28px;
        border-radius: 16px;
        border: 1px solid rgba(59,130,246,0.15);
        box-shadow: 0 12px 40px rgba(59,130,246,0.08), inset 0 1px 1px rgba(255,255,255,0.95);
        max-width: 100%;
        margin-top: 8px;
        margin-bottom: 12px;
        background-clip: unset;
        word-break: break-word;
        line-height: 1.3;
        transition: all 200ms ease;
    }
    
    @media (max-width:768px){
        .title {
            font-size: 24px;
            font-weight: 800;
            padding: 14px 20px;
            margin-top: 4px;
            margin-bottom: 10px;
            letter-spacing: -0.6px;
            box-shadow: 0 6px 24px rgba(59,130,246,0.06);
        }
    }
    
    @media (max-width:480px){
        .title {
            font-size: 22px;
            padding: 12px 16px;
            margin-top: 2px;
            margin-bottom: 8px;
        }
    }
    
    .manage-btn{
        margin-top:12px;
        display:inline-block;
        width:100%;
        padding:12px 16px;
        border-radius:12px;
        background: linear-gradient(90deg, #3b82f6, #2563eb);
        color:white;
        border:none;
        cursor:pointer;
        font-weight:700;
        box-shadow: 0 8px 20px rgba(59,130,246,0.12);
        transition: all 200ms cubic-bezier(0.2,0.8,0.2,1);
        font-size: 14px;
    }
    .manage-btn:hover{ 
        transform: translateY(-4px);
        box-shadow: 0 12px 30px rgba(59,130,246,0.18);
    }
    .manage-btn:active{ 
        transform: translateY(1px);
        box-shadow: 0 4px 12px rgba(59,130,246,0.12);
    }
    
    @media (max-width:768px) {
        .manage-btn {
            padding: 12px 14px;
            font-size: 13px;
            margin-top: 8px;
        }
    }
    /* panel de reporte de l√≠neas vac√≠as (lista roja) */
    .empty-report{
        width: 280px;
        background: linear-gradient(180deg,#ff1f1f,#e73b3b);
        color: #fff;
        padding: 18px 16px;
        border-radius: 10px;
        box-shadow: 0 14px 36px rgba(231,76,60,0.18);
        font-weight:700;
        text-align: left;
        margin-bottom: 6px;
        display: none;
    }
    .empty-report.show{ display: block; }
    .empty-report h3{ margin:0 0 8px 0; font-size:18px; text-align:center }
    .empty-report ul{ margin:10px 0 0 12px; padding:0; list-style:none }
    .empty-report li{ margin:6px 0; font-weight:700; font-size:15px }
    .empty-report .note{ font-weight:600; font-size:12px; opacity:0.95; margin-top:8px }
    /* panel de gesti√≥n embebido (slide-over) */
    .manage-panel{
        position: fixed; right: 0; top: 0; bottom: 0; width: 420px; max-width: 92vw;
        background: #ffffff; box-shadow: -18px 0 40px rgba(2,6,23,0.12); transform: translateX(110%);
        transition: transform 280ms cubic-bezier(.2,.9,.25,1); z-index:12000; padding:18px; overflow:auto;
    }
    .manage-panel.open{ transform: translateX(0); }
    /* make sure controls-area stacks on small screens */
    @media (max-width:900px){
        .controls-area{ flex-direction: column; align-items: stretch }
        .empty-report{ width: 100%; }
        .controls{ width: 100% }
    }
    /* top-right info: current date/time and durations of empty lines */
    .top-info{
        position: static; margin-top:12px; z-index: 2;
        background: rgba(255,255,255,0.95); color:#0f172a; padding:10px 12px; border-radius:10px;
        box-shadow: 0 8px 18px rgba(2,6,23,0.06); font-size:13px; text-align:left;
        width:100%; max-width:100%; box-sizing: border-box; border:1px solid rgba(0,0,0,0.04);
        /* prevent the internal content from forcing the card wider than its parent */
        overflow: hidden;
    }
    .top-info .now{ font-weight:700; font-size:14px }
    .top-info .durations{ margin-top:8px; text-align:left; }
    .top-info .durations ul{ margin:0; padding:6px 8px; list-style:none; max-height:220px; overflow:auto }
    .top-info .durations li{ display:flex; justify-content:space-between; align-items:center; gap:8px; padding:4px 2px; margin:6px 0; box-sizing:border-box; }
    .top-info .durations li span.name{ display:block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:#6b7280; font-weight:600; font-size:13px; }
    .top-info .durations li span.time{ flex-shrink:0; color:#6b7280; font-weight:700; font-size:13px; margin-left:6px; }
    .top-info .durations li.current span.name{ color:#b91c1c; font-weight:800; }
    .top-info .durations li.current span.time{ color:#b91c1c; }
    .top-info .durations li.stopped span.name{ color:#6b7280; font-weight:700; }
    .top-info .durations li.stopped span.time{ color:#6b7280; opacity:0.92; font-weight:700; }

    /* versiones compactas del top-info cuando se inserta dentro del panel flotante */
    .floating-history .floating-top-info{
        background: rgba(255,255,255,0.96);
        padding:8px 10px;
        border-radius:10px;
        box-shadow: 0 8px 18px rgba(2,6,23,0.04);
        border:1px solid rgba(0,0,0,0.04);
        width:100%;
        box-sizing:border-box;
    }

    /* Top-info compact dentro de la fila superior de controles */
    /* mover la info compacta a un lugar fijo en la esquina superior derecha
       para que NO cambie la ubicaci√≥n original de los botones */
    .top-controls .top-info-compact{
        display: none !important;
    }
    .top-controls .top-info-compact .now{ font-weight:700; font-size:13px; margin-bottom:4px }
    .top-controls .top-info-compact .durations{ display:flex; gap:8px; align-items:center; justify-content:space-between }
    .top-controls .top-info-compact .durations ul{ margin:0; padding:0; list-style:none; display:flex; gap:8px; align-items:center; }
    .top-controls .top-info-compact .durations li{ font-weight:700; color:#b91c1c; font-size:13px }
    .floating-history .floating-top-info .now{ font-size:13px; font-weight:700 }
    .floating-history .floating-top-info .durations ul{ max-height:76px; overflow:auto; padding:0; margin:6px 0 0 0 }
    .manage-panel h2{ margin-top:0 }
    .manage-row{ display:flex; gap:8px; margin-bottom:10px }
    .manage-row input[type=text]{ flex:1; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.08) }
    .manage-row input[type=number]{ width:92px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.08) }
    .manage-list{ display:flex; flex-direction:column; gap:8px; margin-top:8px }
    .manage-item{ display:flex; gap:8px; align-items:center }
    .manage-item input{ padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.08) }
    .manage-actions{ display:flex; gap:8px; margin-top:12px }
    
    /* ===== BARRA DE NAVEGACI√ìN M√ìVIL - MEJORADA ===== */
    @media (max-width:768px){
        #mobile-bottom-nav {
            display: flex;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(251,253,255,0.96));
            border-top: 2px solid rgba(59,130,246,0.1);
            gap: 0;
            z-index: 110;
            box-shadow: 0 -8px 32px rgba(0,0,0,0.12);
            backdrop-filter: blur(10px) saturate(180%);
            padding: 0;
            margin: 0;
        }
        
        #mobile-bottom-nav button {
            flex: 1;
            background: transparent;
            border: none;
            border-top: 4px solid transparent;
            color: #64748b;
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 180ms cubic-bezier(0.2,0.8,0.2,1);
            padding: 6px 0;
            border-radius: 0;
            position: relative;
            overflow: hidden;
        }
        
        #mobile-bottom-nav button::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(59,130,246,0.08), rgba(59,130,246,0.02));
            opacity: 0;
            transition: opacity 180ms ease;
            pointer-events: none;
        }
        
        #mobile-bottom-nav button:active::before,
        #mobile-bottom-nav button.active::before {
            opacity: 1;
        }
        
        #mobile-bottom-nav button:active,
        #mobile-bottom-nav button.active {
            border-top-color: #3b82f6;
            color: #3b82f6;
            transform: translateY(-2px);
        }
        
        #mobile-bottom-nav button:active .icon {
            transform: scale(1.2);
        }
        
        #mobile-bottom-nav .icon {
            font-size: 22px;
            transition: transform 180ms ease;
            display: inline-block;
        }
        
        /* Agregar padding inferior al body para que no se oculte contenido */
        body {
            padding-bottom: 80px;
        }
    }
    
    @media (max-width:480px){
        #mobile-bottom-nav {
            height: 66px;
        }
        #mobile-bottom-nav button {
            font-size: 10px;
            gap: 3px;
            padding: 4px 0;
        }
        #mobile-bottom-nav .icon {
            font-size: 20px;
        }
        body {
            padding-bottom: 76px;
        }
    }
    
    @media (min-width:769px){
        #mobile-bottom-nav {
            display: none !important;
        }
    }
</style>
<!-- Firebase SDK (compat - works without modules) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<!-- Firebase Sync Module -->
<script src="firebase-sync.js"></script>
</head>
<body>
    <!-- Barra de navegaci√≥n inferior (solo en m√≥vil) -->
    <div id="mobile-bottom-nav">
        <button id="nav-kanban" class="active" data-tab="kanban">
            <span class="icon">üìä</span>
            <span>Kanban</span>
        </button>
        <button id="nav-panel" data-tab="panel">
            <span class="icon">‚öôÔ∏è</span>
            <span>Panel</span>
        </button>
        <button id="nav-export" data-tab="export">
            <span class="icon">üì•</span>
            <span>Exportar</span>
        </button>
    </div>
    
    <!-- floating action buttons in top-left (visual placement only) -->
    <div id="floating-actions" class="floating-actions" aria-hidden="false">
        <button id="manage-lines-btn" class="manage-btn" type="button">Gestionar l√≠neas</button>
        <!-- Export moved to internal control panel -->
        <!-- <button id="export-history-csv" class="export-btn" type="button">Exportar Excel</button> -->
    </div>
    <!-- floating history card to the right of actions (keeps same IDs so JS still works) -->
    <div id="floating-history" class="floating-history" aria-live="polite">
        <div id="recent-history" class="history-card small-box" aria-live="polite">
            <div style="font-weight:700;margin-bottom:6px">√öltimos 5 parciales abastecidos</div>
            <!-- top-info previously here ‚Äî moved to top-controls as compact version -->
            <div class="recent-list-wrap" style="position:relative">
                <ul id="recent-history-list"></ul>
                <div class="recent-nav" aria-hidden="true" style="display:none;">
                    <button id="recent-prev" aria-label="Ver anterior">‚ñ≤</button>
                    <button id="recent-next" aria-label="Ver siguiente">‚ñº</button>
                </div>
            </div>
        </div>
    </div>
    <!-- (alert banner removed ‚Äî using red report panel below) -->
    <!-- panel de reporte de l√≠neas vac√≠as (se ubicar√° junto al panel de controles) -->
    <!-- el elemento se inserta junto a .controls m√°s abajo -->

    <!-- panel embebido de gesti√≥n de l√≠neas -->
    <aside id="manage-panel" class="manage-panel" aria-hidden="true">
        <h2>Gestionar l√≠neas</h2>
        <p class="small">A√±ade, edita o quita l√≠neas. Los cambios se guardan autom√°ticamente en Firebase y se sincronizar√°n en todas tus pesta√±as.</p>
        <div class="manage-row">
            <input id="m-new-name" type="text" placeholder="Nombre nueva l√≠nea (ej. PK11)" />
            <button id="m-btn-add" class="btn btn-add">A√±adir</button>
        </div>
        <div id="m-lines-list" class="manage-list"></div>
        <div class="manage-actions">
            <button id="m-btn-save" class="btn btn-save">Sincronizar</button>
            <button id="m-btn-close" class="btn" style="margin-left:auto">Cerrar</button>
        </div>
    </aside>
    <h1 class="title" style="font-size:26px; font-weight:800; margin-top:20px; margin-bottom:20px; margin-left:auto; margin-right:auto; text-align:center; letter-spacing:0.5px; background: linear-gradient(135deg, rgba(255,255,255,0.85), rgba(255,255,255,0.65)); color:#0f172a; line-height:1.2; word-spacing:1px; max-width:800px; white-space: nowrap; padding: 12px 24px; border-radius: 12px;">Monitor de Parciales de Materiales</h1>
    <!-- (removed stray closing tag that broke DOM structure) -->
    <script>
    // wire the visible "Probar historial" button (creates a test entry and updates the UI)
    (function(){
        function showStatus(msg, timeout=3000){
            try{
                // Useful diagnostic: dynamic imports will fail if the page is opened via file://
                if(location.protocol === 'file:'){
                    const msg = 'No se puede importar m√≥dulos din√°micos cuando el archivo est√° abierto con file://. Usa un servidor local (python -m http.server o npx http-server) y abre http://localhost:PORT.';
                    console.error(msg);
                    showStatus(msg);
                    throw new Error(msg);
                }
                let el = document.getElementById('hist-test-status');
                if(!el){
                    // find the correct container: the element with id recent-history
                    const wrap = document.querySelector('#recent-history');
                    if(!wrap) {
                        console.warn('showStatus: recent-history container not found');
                    } else {
                        el = document.createElement('div');
                        el.id = 'hist-test-status';
                        el.style.fontSize = '12px';
                        el.style.color = '#0b1220';
                        el.style.opacity = 0.85;
                        el.style.marginTop = '6px';
                        wrap.appendChild(el);
                    }
                }
                el.textContent = msg;
                if(timeout>0) setTimeout(()=>{ try{ el.textContent = ''; }catch(e){} }, timeout);
            }catch(e){ console.warn('showStatus failed', e); }
        }

        const btn = document.getElementById('btn-test-history');
        if(btn){
            btn.addEventListener('click', async ()=>{
                try{
                    if(!window.testAddHistory) { showStatus('Helper no disponible (usa consola)'); return; }
                    showStatus('Creando entrada de prueba...', 60000);
                    await window.testAddHistory();
                    showStatus('Entrada de prueba solicitada. Revisa el historial (o consola).', 4000);
                }catch(e){ console.error('test history failed', e); showStatus('Error creando entrada, revisa la consola'); }
            });
        }
    })();
    // ==========================================
    // CARGAR DATOS DESDE FIREBASE AL INICIAR
    // ==========================================
    // CARGAR DATOS Y LISTENERS AL INICIAR (Se ejecutar√° cuando Firebase est√© listo)
    // ==========================================
    // Nota: Estos se llaman en DOMContentLoaded + initFirebaseSync m√°s adelante
    // (async function(){
    //     try{
    //         if(window.firebaseInitPromise){
    //             await window.firebaseInitPromise;
    //         }
    //         console.log('üöÄ Cargando datos desde Firebase al iniciar...');
    //         await loadAllDataFromFirebase();
    //         // Iniciar listeners en tiempo real despu√©s de la carga inicial
    //         await initFirebaseSync();
    //     }catch(e){
    //         console.warn('‚ö† Error en carga inicial de Firebase:', e);
    //     }
    // })();

    document.addEventListener('DOMContentLoaded', async function(){
        // ===== DIAGN√ìSTICO DE FIREBASE =====
        console.log('%cüîç DIAGN√ìSTICO FIREBASE', 'color: blue; font-weight: bold; font-size: 14px;');
        console.log('Firebase SDK cargado:', !!window.firebase);
        console.log('Firebase Database disponible:', !!window.firebase?.database);
        console.log('window.db disponible:', !!window.db);
        console.log('firebaseInitPromise disponible:', !!window.firebaseInitPromise);
        
        // ‚ö° INTENTAR CARGAR DESDE FIREBASE PRIMERO
        console.log('üöÄ Intentando cargar datos desde Firebase...');
        let firebaseDataLoaded = false;
        
        try {
            if(window.firebaseInitPromise) {
                await window.firebaseInitPromise;
                console.log('‚úÖ Firebase inicializado, esperando conexi√≥n...');
            }
            
            if(window.db) {
                const snapshot = await window.db.ref('kanban_estado').once('value');
                const firebaseKanban = snapshot.val();
                
                if(firebaseKanban && Object.keys(firebaseKanban).length > 0) {
                    console.log('üì• DATOS ENCONTRADOS EN FIREBASE:', firebaseKanban);
                    
                    // CONVERTIR objetos a arrays (Firebase convierte arrays en objetos)
                    const convertToArray = (obj) => {
                        if(!obj) return [];
                        if(Array.isArray(obj)) return obj;
                        const keys = Object.keys(obj).sort((a, b) => parseInt(a) - parseInt(b));
                        return keys.map(k => obj[k]);
                    };
                    
                    // Crear l√≠neas desde Firebase
                    const lines = Object.keys(firebaseKanban).map(lineName => ({
                        name: lineName,
                        count: (convertToArray(firebaseKanban[lineName]) || []).length,
                        active: true
                    }));
                    
                    console.log('üéØ L√≠neas creadas desde Firebase:', lines);
                    
                    try { localStorage.setItem('pk_lines', JSON.stringify(lines)); } catch(e) { console.warn('localStorage no disponible'); }
                    
                    // Guardar nombres de bloques en pk_block_names
                    const pk_block_names = {};
                    Object.keys(firebaseKanban).forEach(lineName => {
                        const parciales = convertToArray(firebaseKanban[lineName]);
                        pk_block_names[lineName] = {};
                        parciales.forEach((parcialName, idx) => {
                            pk_block_names[lineName][String(idx)] = parcialName;
                        });
                    });
                    try { localStorage.setItem('pk_block_names', JSON.stringify(pk_block_names)); } catch(e) { console.warn('localStorage no disponible'); }
                    
                    console.log('üè∑Ô∏è pk_block_names guardado:', pk_block_names);
                    
                    if(window.applyLinesToDOM) {
                        window.applyLinesToDOM(lines);
                        console.log('‚úÖ L√≠neas renderizadas desde Firebase');
                    }
                    
                    firebaseDataLoaded = true;
                }
            }
        } catch(e) {
            console.warn('‚ö†Ô∏è Error cargando desde Firebase:', e);
        }
        
        // SI NO HAY DATOS EN FIREBASE, usar l√≠neas por defecto
        if(!firebaseDataLoaded) {
            console.log('üìå Firebase vac√≠o, usando l√≠neas por defecto...');
            try{
                const storedLines = localStorage.getItem('pk_lines');
                if(!storedLines || JSON.parse(storedLines).length === 0){
                    const defaultLines = [
                        { name: 'PKB1', count: 0, active: true },
                        { name: 'PKB2', count: 0, active: true },
                        { name: 'PKB3', count: 0, active: true },
                        { name: 'PKB4', count: 0, active: true },
                        { name: 'PKB5', count: 0, active: true },
                        { name: 'PKB6', count: 0, active: true },
                        { name: 'JVH2', count: 0, active: true },
                        { name: 'EYS', count: 0, active: true },
                        { name: 'MAQ', count: 0, active: true }
                    ];
                    localStorage.setItem('pk_lines', JSON.stringify(defaultLines));
                    if(window.applyLinesToDOM){
                        window.applyLinesToDOM(defaultLines);
                        console.log('üé® L√≠neas por defecto aplicadas');
                    }
                }
            }catch(e){
                console.warn('Error inicializando l√≠neas por defecto:', e);
            }
        }

        // üìã CARGAR HISTORIAL INMEDIATAMENTE AL INICIO
        try{
            console.log('üìã Cargando historial al inicio...');
            
            // Leer de localStorage primero (r√°pido)
            let pk_history = [];
            try{ pk_history = JSON.parse(localStorage.getItem('pk_history') || '[]'); }catch(e){}
            
            if(pk_history.length > 0){
                // Ordenar por m√°s reciente
                const sorted = pk_history.sort((a, b) => {
                    const timeA = a.timestamp || a.suppliedAt || 0;
                    const timeB = b.timestamp || b.suppliedAt || 0;
                    return timeB - timeA;
                });
                
                // Preparar datos para el panel
                const recentItems = sorted.slice(0, 5).map(item => ({
                    id: `${item.lineName}_${item.parcial}`,
                    name: item.parcial,
                    orderId: item.parcial,
                    line: item.lineName,
                    action: 'abastecido',
                    suppliedAt: item.timestamp || Date.now(),
                    ts: item.timestamp || Date.now()
                }));
                
                // Actualizar el panel inmediatamente
                if(window.renderRecentHistory){
                    window.renderRecentHistory(recentItems);
                    console.log('‚úÖ Historial inicial cargado:', recentItems.length, 'items');
                }
            } else {
                console.log('‚ÑπÔ∏è No hay historial previo en localStorage');
            }
        }catch(e){
            console.warn('‚ö†Ô∏è Error cargando historial inicial:', e);
        }
        
        // üì¶ REGISTRAR LISTENER DE ABASTECIMIENTOS EN TIEMPO REAL
        (async function(){
            try{
                console.log('%cüì¶ REGISTRANDO LISTENER DE ABASTECIMIENTOS...', 'background: green; color: white; font-weight: bold; padding: 4px;');
                
                // Esperar a que Firebase est√© listo
                if(window.firebaseInitPromise){
                    await window.firebaseInitPromise;
                }
                
                if(!window.db){
                    console.error('‚ùå Firebase no disponible para listener de abastecimientos');
                    return;
                }
                
                window.db.ref('abastecimientos').on('value', (snap) => {
                    console.log('%cüîîüì¶ ¬°¬°¬° EVENTO DE ABASTECIMIENTOS RECIBIDO !!!', 'background: green; color: white; font-weight: bold; padding: 8px; font-size: 16px;');
                    const firebaseAbastecimientos = snap.val() || {};
                    console.log('üì• Abastecimientos de Firebase:', firebaseAbastecimientos);
                    localStorage.setItem('json_abastecimientos', JSON.stringify(firebaseAbastecimientos, null, 2));
                    
                    // Convertir abastecimientos a pk_history
                    const pk_history = [];
                    Object.keys(firebaseAbastecimientos).forEach(lineName => {
                        const lineData = firebaseAbastecimientos[lineName];
                        if(lineData && typeof lineData === 'object'){
                            Object.keys(lineData).forEach(key => {
                                const entry = lineData[key];
                                if(entry){
                                    pk_history.push({
                                        lineName: lineName,
                                        parcial: entry.parcial || entry.name || 'N/A',
                                        timestamp: entry.timestamp || entry.suppliedAt || Date.now(),
                                        fecha: entry.fecha || new Date().toLocaleDateString(),
                                        hora: entry.hora || new Date().toLocaleTimeString()
                                    });
                                }
                            });
                        }
                    });
                    
                    try { localStorage.setItem('pk_history', JSON.stringify(pk_history.slice(-200))); } catch(e) { console.warn('localStorage no disponible'); }
                    
                    // Actualizar historial en la UI
                    try{
                        console.log('%cüìã ACTUALIZANDO HISTORIAL EN TIEMPO REAL', 'background: purple; color: white; font-weight: bold; padding: 4px;');
                        console.log('üìä Total de items en pk_history:', pk_history.length);
                        
                        // Ordenar por fecha m√°s reciente primero
                        const sorted = pk_history.sort((a, b) => {
                            const timeA = a.timestamp || a.suppliedAt || 0;
                            const timeB = b.timestamp || b.suppliedAt || 0;
                            return timeB - timeA;
                        });
                        
                        // Preparar datos para renderRecentHistory
                        const recentItems = sorted.slice(0, 5).map(item => ({
                            id: `${item.lineName}_${item.parcial}`,
                            name: item.parcial,
                            orderId: item.parcial,
                            line: item.lineName,
                            action: 'abastecido',
                            suppliedAt: item.timestamp || Date.now(),
                            ts: item.timestamp || Date.now()
                        }));
                        
                        // Actualizar el panel
                        if(window.renderRecentHistory){
                            window.renderRecentHistory(recentItems);
                            console.log('‚úÖ Panel historial actualizado con', recentItems.length, 'items');
                        } else {
                            console.error('‚ùå window.renderRecentHistory NO EST√Å DISPONIBLE');
                        }
                    }catch(e){
                        console.error('‚ùå Error actualizando historial:', e);
                    }
                });
                
                console.log('‚úÖ Listener de abastecimientos registrado correctamente');
                
            }catch(e){
                console.error('‚ùå Error registrando listener de abastecimientos:', e);
            }
        })();
        
        // Do NOT reset persisted timers on load. Preserve `pk_solicitud_salida` and `pk_empty_since` so
        // durations survive page reloads. Run a small deferred refresh of timer UI to pick up stored values.
        try{ setTimeout(()=>{ try{ ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); window.updateEmptyDurationsDisplay && window.updateEmptyDurationsDisplay(); }catch(e){} }, 50); }catch(e){}

        // üîí SISTEMA DE COLA PARA PREVENIR OPERACIONES SIMULT√ÅNEAS
        window._operationQueue = window._operationQueue || [];
        window._processingOperation = false;
        
        async function queueOperation(operationFn, description) {
            return new Promise((resolve, reject) => {
                window._operationQueue.push({ fn: operationFn, description, resolve, reject });
                console.log(`üìã Operaci√≥n en cola: ${description} (total: ${window._operationQueue.length})`);
                processQueue();
            });
        }
        
        async function processQueue() {
            if(window._processingOperation || window._operationQueue.length === 0) return;
            
            window._processingOperation = true;
            const { fn, description, resolve, reject } = window._operationQueue.shift();
            
            console.log(`‚öôÔ∏è Procesando: ${description} (quedan ${window._operationQueue.length})`);
            
            try {
                const result = await fn();
                resolve(result);
            } catch(e) {
                console.error(`‚ùå Error en operaci√≥n: ${description}`, e);
                reject(e);
            } finally {
                window._processingOperation = false;
                // Peque√±a pausa antes de procesar siguiente operaci√≥n
                setTimeout(() => processQueue(), 50);
            }
        }
        
        window.queueOperation = queueOperation;

        const input = document.getElementById('line-name');
        const btnAdd = document.getElementById('btn-entrada');
        const btnRemove = document.getElementById('btn-salida');
        const status = document.getElementById('control-status');

        // poblar datalist con las l√≠neas existentes
        function populateDatalist(){
            const dl = document.getElementById('line-list');
            if(!dl) return;
            dl.innerHTML = '';
            const headers = document.querySelectorAll('.container .column .column-header');
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h.textContent.trim();
                dl.appendChild(opt);
            });
        }
        // helper global: append history entries and refresh the recent-history UI
        function addHistoryEntries(entries){
            try{
                if(!Array.isArray(entries) || entries.length === 0) return;
                let hist = [];
                try{ hist = JSON.parse(localStorage.getItem('pk_history')||'[]'); }catch(e){ hist = []; }
                hist = hist.concat(entries || []);
                hist = hist.slice(-200);
                localStorage.setItem('pk_history', JSON.stringify(hist));
                try{ window.historialModule && window.historialModule.renderizar(); }catch(e){}
                // Also persist to Firestore if available
                try{
                    // Local storage only
                }catch(e){ console.warn('addHistoryEntries -> firestore save failed', e); }
            }catch(err){ console.error('addHistoryEntries failed', err); }
        }
        // llenar la lista desplegable con las l√≠neas actuales
        populateDatalist();

        // funci√≥n que detecta l√≠neas sin parciales y muestra alerta
        function checkEmptyLines(){
            // only direct children columns to avoid accidental matches
            const cols = Array.from(document.querySelectorAll('.container > .column'));
            const emptyNames = [];
            // load existing empty timestamps mapping
            let emptySince = {};
            try{ emptySince = JSON.parse(localStorage.getItem('pk_empty_since')||'{}'); }catch(e){ emptySince = {}; }
            let changed = false;
            cols.forEach(c => {
                // skip inactive lines from empty checks
                if(c.classList.contains('inactive')) {
                    const header = (c.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    try{
                        const mapRaw = localStorage.getItem('pk_empty_since');
                        const map = mapRaw ? JSON.parse(mapRaw) : {};
                        if(map[header]){ delete map[header]; localStorage.setItem('pk_empty_since', JSON.stringify(map)); changed = true; }
                    }catch(e){}
                    c.classList.remove('empty');
                    return;
                }
                const blocks = c.querySelectorAll('.block').length;
                const header = (c.querySelector('.column-header')||{textContent:'?'}).textContent.trim();
                if(blocks === 0){
                    c.classList.add('empty');
                    if(header) {
                        emptyNames.push(header);
                        if(!emptySince[header]){ emptySince[header] = Date.now(); changed = true; }
                    }
                } else {
                    c.classList.remove('empty');
                    if(header && emptySince[header]){ delete emptySince[header]; changed = true; }
                }
            });
            // deduplicate and clean names
            const names = Array.from(new Set(emptyNames.map(n=>n.trim()).filter(Boolean)));
            
            // Alert if new lines became empty
            if(names.length > 0){
                const newEmpty = names.filter(n => !emptySince[n] || (emptySince[n] && Date.now() - emptySince[n] < 2000));
                if(newEmpty.length > 0){
                    console.warn('‚ö†Ô∏è L√≠neas sin parciales detectadas:', newEmpty);
                    // Only alert once per session per line to avoid spam
                    newEmpty.forEach(lineName => {
                        if(!window._emptyLineAlerted) window._emptyLineAlerted = {};
                        if(!window._emptyLineAlerted[lineName]){
                            // Alert user about empty line
                            // (commented out to avoid too many alerts, but logged to console)
                            window._emptyLineAlerted[lineName] = true;
                        }
                    });
                }
            }
            
            // render the red report panel
            const report = document.getElementById('empty-report');
            const list = document.getElementById('empty-report-list');
            if(report && list){
                list.innerHTML = '';
                if(names.length > 0){
                    names.forEach(n=>{
                        const li = document.createElement('li'); li.textContent = n; list.appendChild(li);
                    });
                    report.classList.add('show');
                    report.setAttribute('aria-hidden','false');
                } else {
                    report.classList.remove('show');
                    report.setAttribute('aria-hidden','true');
                    list.innerHTML = '';
                }
            }
            // persist empty timestamps if changed
            try{ if(changed) localStorage.setItem('pk_empty_since', JSON.stringify(emptySince)); }catch(e){}
            // update durations display
            try{ updateEmptyDurationsDisplay(); }catch(e){}
        }
        // ejecutar la comprobaci√≥n inicial
        checkEmptyLines();

        // desactivar selecci√≥n por click sobre la cabecera: la √∫nica forma de abastecer Kamban
        // ser√° mediante el bot√≥n "ABASTECER KAMBAN" (btn-entrada) que abre la ventana/modal.
        function setupHeaderClicks(){
            const headers = document.querySelectorAll('.container .column .column-header');
            headers.forEach(h => {
                // ensure header does not indicate clickability
                h.style.cursor = 'default';
                // remove any inline onclick handlers if present
                try{ h.onclick = null; }catch(e){}
            });
            // add a single capture-phase guard to prevent header clicks from triggering other handlers
            try{
                if(!window._headerClickGuardAdded){
                    document.addEventListener('click', function(e){
                        const hh = e.target && e.target.closest && e.target.closest('.column-header');
                        if(hh){
                            e.stopPropagation();
                            e.preventDefault();
                            // no-op: prevent using header to select or open modals
                        }
                    }, true);
                    window._headerClickGuardAdded = true;
                }
            }catch(e){ console.warn('failed to add header click guard', e); }
        }
        setupHeaderClicks();
        // setup selection of parciales (blocks)
        function setupBlockSelection(){
            const blocks = document.querySelectorAll('.container .column .block');
            console.log(`üñ±Ô∏è setupBlockSelection: Configurando ${blocks.length} bloques para selecci√≥n`);
            
            blocks.forEach(b => {
                b.style.cursor = 'pointer';
                // remove any existing handler we may have attached earlier
                if(b._selectHandler) b.removeEventListener('click', b._selectHandler);
                b._selectHandler = function(e){
                    // only allow selecting visible, non-inactive columns
                    const col = b.closest('.column');
                    const lineName = (col && col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    console.log(`üñ±Ô∏è Click en bloque de l√≠nea: ${lineName}`);
                    
                    if(col && col.classList.contains('inactive')) {
                        console.log(`‚ö†Ô∏è Columna ${lineName} est√° inactiva - ignorando click`);
                        return;
                    }
                    // ensure this block has correct data attributes before toggling
                    try{
                        if(!b.hasAttribute('data-line')) {
                            b.setAttribute('data-line', lineName);
                            console.log(`‚úèÔ∏è Agregado data-line="${lineName}" al bloque`);
                        }
                        // compute index if missing or inconsistent
                        if(!b.hasAttribute('data-index')){
                            const siblings = Array.from(col.querySelectorAll('.block'));
                            const idx = siblings.indexOf(b);
                            b.setAttribute('data-index', String(idx));
                            console.log(`‚úèÔ∏è Agregado data-index="${idx}" al bloque de ${lineName}`);
                        }
                    }catch(err){ console.warn('ensure data attrs failed', err); }
                    // enforce single selection: deselect others, then toggle this one
                    try{ document.querySelectorAll('.block.selected-parcial').forEach(x=>{ if(x!==b) x.classList.remove('selected-parcial'); }); }catch(e){}
                    if(b.classList.contains('selected-parcial')){
                        // if already selected, unselect it (no selection)
                        b.classList.remove('selected-parcial');
                        console.log(`‚ùå Bloque de ${lineName} des-seleccionado`);
                    } else {
                        // select this block only
                        b.classList.add('selected-parcial');
                        console.log(`‚úÖ Bloque de ${lineName} seleccionado`);
                    }
                    // update status: show how many selected
                    try{
                        const count = document.querySelectorAll('.block.selected-parcial').length;
                        if(count === 0) status.textContent = '';
                        else status.textContent = `${count} parcial(es) seleccionado(s).`;
                    }catch(e){}
                };
                b.addEventListener('click', b._selectHandler);
                // pointer/touch drag support: start drag on pointerdown
                if(b._pointerDownHandler) b.removeEventListener('pointerdown', b._pointerDownHandler);
                b._pointerDownHandler = function(ev){
                    try{ startDrag(b, ev); }catch(err){ console.warn('drag start failed', err); }
                };
                b.addEventListener('pointerdown', b._pointerDownHandler);
                // touch fallback for devices that don't support Pointer Events
                if(b._touchStartHandler) b.removeEventListener('touchstart', b._touchStartHandler);
                b._touchStartHandler = function(ev){
                    try{
                        // prevent default to avoid page scroll while dragging
                        if(ev.cancelable) ev.preventDefault();
                        // pass the touch event to the same startDrag function
                        startDrag(b, ev);
                    }catch(err){ console.warn('touch drag start failed', err); }
                };
                b.addEventListener('touchstart', b._touchStartHandler, { passive: false });
            });
        }
        setupBlockSelection();

        function findColumn(name){
            if(!name) return null;
            const cols = document.querySelectorAll('.container .column');
            const target = Array.from(cols).find(col => {
                const h = col.querySelector('.column-header');
                return h && h.textContent.trim().toLowerCase() === name.trim().toLowerCase();
            });
            return target || null;
        }

        // Drag and drop (pointer/touch) for blocks - drop on ABASTECER AB (btn-salida)
        let _dragState = null;
        const btnSalida = document.getElementById('btn-salida');

        function startDrag(block, ev){
            if(_dragState) return; // prevent nested drags
            // only start if primary button / primary pointer
            if(ev && ev.button && ev.button !== 0) return;
            ev.preventDefault && ev.preventDefault();
            // compute which blocks will be dragged: selected group or the single block
            // only allow one selected block: if exists use it, otherwise use the clicked block
            const selected = document.querySelector('.block.selected-parcial');
            const dragged = selected ? [selected] : [block];

            // create ghost element
            const ghost = block.cloneNode(true);
            ghost.classList.add('drag-ghost');
            ghost.style.width = Math.max(52, block.offsetWidth) + 'px';
            ghost.style.height = Math.max(32, block.offsetHeight) + 'px';
            document.body.appendChild(ghost);

            _dragState = { dragged, ghost, pointerId: ev.pointerId || null };

            // capture pointer for the initiating block if possible
            try{ if(ev.target && ev.pointerId) ev.target.setPointerCapture && ev.target.setPointerCapture(ev.pointerId); }catch(e){}

            // initial position
            const x = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || 0;
            const y = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 0;
            _dragState.ghost.style.left = x + 'px'; _dragState.ghost.style.top = y + 'px';

            // attach move/up listeners on document
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('pointercancel', onPointerUp);
            // touch fallbacks
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd);
            document.addEventListener('touchcancel', onTouchEnd);
            // small visual cue on target
            if(btnSalida) btnSalida.classList.add('drop-ready');
        }

        function onTouchMove(ev){
            if(!ev || !ev.touches || ev.touches.length === 0) return;
            // prevent native scrolling while dragging
            if(ev.cancelable) ev.preventDefault();
            const t = ev.touches[0];
            onPointerMove({ clientX: t.clientX, clientY: t.clientY });
        }

        function onTouchEnd(ev){
            // use changedTouches for end coordinate if available
            const t = (ev && ev.changedTouches && ev.changedTouches[0]) || (ev && ev.touches && ev.touches[0]) || null;
            const fake = t ? { clientX: t.clientX, clientY: t.clientY } : (ev || {});
            onPointerUp(fake);
        }

        function onPointerMove(ev){
            if(!_dragState) return;
            const x = ev.clientX; const y = ev.clientY;
            if(_dragState.ghost){ _dragState.ghost.style.left = x + 'px'; _dragState.ghost.style.top = y + 'px'; }
            // highlight drop target if hovering
            if(btnSalida){
                const el = document.elementFromPoint(x, y);
                if(el && (el === btnSalida || btnSalida.contains(el))){ btnSalida.classList.add('btn-drop-target'); }
                else btnSalida.classList.remove('btn-drop-target');
            }
        }

        async function onPointerUp(ev){
            if(!_dragState) return;
            const x = ev.clientX; const y = ev.clientY;
            // determine drop target
            let dropEl = document.elementFromPoint(x,y);
            const isOnBtn = dropEl && (dropEl === btnSalida || (btnSalida && btnSalida.contains(dropEl)));
                if(isOnBtn){
                    // perform abastecer-ab for all dragged blocks: collect info, save history, remove nodes,
                    // set solicitud+salida for their lines (now) and rebuild requested map from DOM.
                    const now = Date.now();
                    // collect unique dragged elements
                    const uniq = Array.from(new Set(_dragState.dragged || []));
                    // collect metadata for each dragged block BEFORE removing it
                    const removedBlocks = uniq.map(b => {
                        try{
                            const col = b.closest('.column');
                            const line = (col && col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                            const idx = parseInt(b.getAttribute('data-index')||'-1',10);
                            const name = b.getAttribute('data-name') || ((b.querySelector('.label')||{}).textContent||'').trim();
                            return { el: b, line, index: idx, name };
                        }catch(e){ return null; }
                    }).filter(Boolean);
                    const lines = Array.from(new Set(removedBlocks.map(r=>r.line))).filter(Boolean);

                    // load solicitud map BEFORE overwriting so we can compute durations
                    let solicitudMap = {};
                    try{ solicitudMap = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ solicitudMap = {}; }

                    // load existing history, append new entries for each removed block
                    let newEntries = [];
                    
                    // üî• IMPORTANTE: Usar sistema de cola para evitar conflictos en operaciones simult√°neas
                    for(const rb of removedBlocks) {
                        await queueOperation(async () => {
                        try{
                            const prevSolic = solicitudMap[rb.line] && solicitudMap[rb.line].solicitud ? parseInt(solicitudMap[rb.line].solicitud,10) : null;
                            const duration = prevSolic ? Math.max(0, now - prevSolic) : 0;
                            const parcialName = rb.name || (`${rb.line}#${rb.index}`);
                            newEntries.push({ 
                                name: parcialName, 
                                parcial: parcialName,
                                line: rb.line, 
                                lineName: rb.line,
                                index: rb.index, 
                                requestedAt: prevSolic || now, 
                                suppliedAt: now,
                                timestamp: now,
                                duration 
                            });
                            // NUEVO: Registrar abastecimiento en Firebase
                            if(window.FirebaseSync){
                                await window.FirebaseSync.addAbastecimiento(rb.line, rb.name || (`${rb.line}#${rb.index}`));
                            }
                            
                            // üóëÔ∏è ELIMINAR DE kanban_estado EN FIREBASE Y REORGANIZAR √çNDICES
                            if(window.db){
                                try{
                                    // 1. Leer todo kanban_estado
                                    const kanbanSnap = await window.db.ref('kanban_estado').once('value');
                                    const kanbanData = kanbanSnap.val() || {};
                                    
                                    // 2. Eliminar el parcial espec√≠fico
                                    const lineParciales = kanbanData[rb.line] || {};
                                    delete lineParciales[rb.index];
                                    
                                    // 3. Convertir a array limpio (sin huecos)
                                    const parcialesArray = Object.keys(lineParciales)
                                        .sort((a, b) => parseInt(a) - parseInt(b))
                                        .map(key => lineParciales[key]);
                                    
                                    // 4. Guardar nuevamente reorganizado
                                    if(parcialesArray.length > 0) {
                                        const reorganized = {};
                                        parcialesArray.forEach((parcial, idx) => {
                                            reorganized[idx] = parcial;
                                        });
                                        await window.db.ref(`kanban_estado/${rb.line}`).set(reorganized);
                                    } else {
                                        // Si no hay parciales, eliminar la l√≠nea
                                        await window.db.ref(`kanban_estado/${rb.line}`).remove();
                                    }
                                    
                                    // 5. üî• SOLO ELIMINAR LA SOLICITUD ESPEC√çFICA (NO reorganizar)
                                    // Los √≠ndices de solicitudes se mantienen vinculados a la posici√≥n DOM original
                                    try{
                                        await window.db.ref(`solicitudes/${rb.line}/${rb.index}`).remove();
                                        console.log(`üóëÔ∏è SOLICITUD ELIMINADA: ${rb.line}[${rb.index}]`);
                                    }catch(e){ 
                                        console.warn('Error eliminando solicitud:', e);
                                    }
                                    
                                    console.log(`‚úÖ Parcial eliminado y reorganizado en Firebase: ${rb.line}[${rb.index}]`);
                                    
                                    // ‚è±Ô∏è DETENER TIMER SIEMPRE (solo hay 1 solicitud por l√≠nea)
                                    try{
                                        await window.db.ref(`solicitud_times/${rb.line}`).remove();
                                        console.log(`%c‚è±Ô∏è‚úÖ TIMER DETENIDO EN FIREBASE: ${rb.line}`, 'background: #4CAF50; color: white; font-weight: bold;');
                                        
                                        // üî• Limpiar cache local INMEDIATAMENTE
                                        if(window.firebaseTimestampsCache) {
                                            delete window.firebaseTimestampsCache[rb.line];
                                            console.log('üóëÔ∏è Cache local limpiado:', rb.line);
                                        }
                                        
                                        // üî• FORZAR ACTUALIZACI√ìN EN TODAS LAS VENTANAS
                                        localStorage.setItem('solicitud_times_firebase', JSON.stringify(window.firebaseTimestampsCache || {}));
                                        
                                        // Disparar evento de storage para sincronizar otras pesta√±as
                                        window.dispatchEvent(new StorageEvent('storage', {
                                            key: 'solicitud_times_firebase',
                                            newValue: JSON.stringify(window.firebaseTimestampsCache || {})
                                        }));
                                        
                                        // Actualizar timers en esta ventana
                                        setTimeout(() => {
                                            try{ window.updateColumnTimers(); }catch(e){}
                                        }, 50);
                                    }catch(e){ console.warn('Error deteniendo timer:', e); }
                                }catch(e){ console.warn('Error eliminando/reorganizando parcial de Firebase:', e); }
                            }
                        }catch(e){ console.error('Error registrando abastecimiento en Firebase:', e); }
                        }, `Abastecer ${rb.line}#${rb.index}`);
                    }
                    // persist via helper so view is refreshed
                    try{ addHistoryEntries(newEntries); }catch(e){}

                    // remove dragged blocks from DOM
                    try{ uniq.forEach(b => { try{ if(b && b.parentNode) b.parentNode.removeChild(b); }catch(e){} }); }catch(e){}

                    // after removals, ensure attributes are consistent and rebuild names mapping
                    try{ ensureBlockDataAttributes(); rebuildBlockNamesFromDOM(); }catch(e){}

                    // update solicitud map for affected lines: set solicitud+salida = now
                    lines.forEach(lineName => {
                        if(!lineName) return;
                        solicitudMap[lineName] = solicitudMap[lineName] || {};
                        solicitudMap[lineName].solicitud = now;
                        solicitudMap[lineName].salida = now;
                    });
                    try{ localStorage.setItem('pk_solicitud_salida', JSON.stringify(solicitudMap)); }catch(e){}

                    // rebuild requested map based on remaining DOM (removes requested indices that no longer exist)
                    try{ rebuildRequestedFromDOM(); }catch(e){}
                    // persist current lines state (counts, active)
                    try{ saveState(); }catch(e){}
                    // apply UI updates
                    try{ applyRequestedToDOM(); ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); window.historialModule && window.historialModule.renderizar(); }catch(e){}
                    
                    // üîÑ Actualizar historial inmediatamente con los datos reci√©n guardados
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            try{
                                console.log('üìã Actualizando panel de historial inmediatamente...');
                                
                                // Leer TODO el historial de localStorage
                                let pk_history = [];
                                try{ pk_history = JSON.parse(localStorage.getItem('pk_history') || '[]'); }catch(e){}
                                
                                console.log('üìä pk_history tiene', pk_history.length, 'items');
                                console.log('üìä Contenido completo:', pk_history);
                                
                                // Ordenar por m√°s reciente
                                const sorted = pk_history.sort((a, b) => {
                                    const timeA = a.timestamp || a.suppliedAt || 0;
                                    const timeB = b.timestamp || b.suppliedAt || 0;
                                    return timeB - timeA;
                                });
                                
                                // Preparar datos para el panel (√∫ltimos 5)
                                const recentItems = sorted.slice(0, 5).map(item => ({
                                    id: `${item.lineName || item.line}_${item.parcial || item.name}`,
                                    name: item.parcial || item.name,
                                    orderId: item.parcial || item.name,
                                    line: item.lineName || item.line,
                                    action: 'abastecido',
                                    suppliedAt: item.timestamp || item.suppliedAt || Date.now(),
                                    ts: item.timestamp || item.suppliedAt || Date.now()
                                }));
                                
                                console.log('üì¶ Datos preparados para el panel:', recentItems);
                                
                                // Actualizar el panel inmediatamente
                                if(window.renderRecentHistory){
                                    window.renderRecentHistory(recentItems);
                                    console.log('‚úÖ Panel de historial actualizado con', recentItems.length, 'items');
                                } else {
                                    console.warn('‚ö†Ô∏è window.renderRecentHistory NO EXISTE');
                                }
                            }catch(e){
                                console.error('‚ùå Error actualizando panel de historial:', e);
                            }
                        });
                    });
                    
                    // üîÑ Sincronizar desde Firebase despu√©s de procesar abastecimiento
                    // NO RECARGAR - solo sincronizar silenciosamente
                    setTimeout(async ()=>{
                        try{
                            console.log('üîÑ Sincronizando estado actualizado con Firebase...');
                            
                            // Obtener estado actualizado del DOM
                            const currentState = getCurrentKanbanState();
                            
                            // Guardar en Firebase
                            if(window.db){
                                await window.db.ref('kanban_estado').set(currentState);
                                console.log('‚úÖ Estado sincronizado con Firebase sin recargar');
                            }
                            
                            // Actualizar cache local
                            window._lastKanbanUpdate = JSON.stringify(currentState);
                            localStorage.setItem('json_kanban_state', JSON.stringify(currentState, null, 2));
                            
                        }catch(e){ console.warn('‚ö†Ô∏è Error en sincronizaci√≥n post-abastecimiento:', e); }
                    }, 300);
                    
                    // üîÑ Recargar p√°gina autom√°ticamente de inmediato
                    setTimeout(() => {
                        location.reload();
                    }, 10);
                }

            // cleanup
            try{ if(_dragState.ghost) _dragState.ghost.remove(); }catch(e){}
            if(btnSalida) btnSalida.classList.remove('btn-drop-target','drop-ready');
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);
            document.removeEventListener('pointercancel', onPointerUp);
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onTouchEnd);
            document.removeEventListener('touchcancel', onTouchEnd);
            _dragState = null;
        }

        async function addPartial(name){
            // backward-compatible signature: addPartial(lineName, blockLabel)
            const lineName = name;
            const blockLabel = arguments.length > 1 ? arguments[1] : undefined;
            const col = findColumn(lineName);
            if(!col){
                status.textContent = `L√≠nea "${lineName}" no encontrada.`;
                return;
            }
            if(col.classList.contains('inactive')){
                status.textContent = `L√≠nea "${name}" est√° inactiva. No se pueden a√±adir parciales.`;
                return;
            }
            // Local storage only - Firebase removed

            const block = document.createElement('div');
            block.className = 'block appear';
            // set data attributes so persistence works
                // cleanup requested map: remove any requested indices >= new count
                try{
                    const lineName = name;
                    const map = getRequestedMap();
                    const arr = Array.isArray(map[lineName]) ? map[lineName] : [];
                    const newCount = col.querySelectorAll('.block').length;
                    const cleaned = arr.filter(i => i < newCount);
                    if(cleaned.length > 0) map[lineName] = cleaned; else delete map[lineName];
                    saveRequestedMap(map);
                }catch(e){}
            const idx = col.querySelectorAll('.block').length; // next index
                try{ saveState(); }catch(e){ /* ignore */ }
            block.setAttribute('data-index', String(idx));
            if(blockLabel){
                block.setAttribute('data-name', blockLabel);
                const span = document.createElement('span'); span.className = 'label'; span.textContent = blockLabel; block.appendChild(span);
                // persist name in pk_block_names
                try{
                    const names = JSON.parse(localStorage.getItem('pk_block_names')||'{}');
                    names[lineName] = names[lineName] || {};
                    names[lineName][String(idx)] = blockLabel;
                    localStorage.setItem('pk_block_names', JSON.stringify(names));
                }catch(e){}
            }
            // if this index is in requested map, mark requested
            try{
                const map = getRequestedMap();
                const arr = Array.isArray(map[lineName]) ? map[lineName] : [];
                if(arr.indexOf(idx) !== -1) block.classList.add('requested');
            }catch(e){}
            col.appendChild(block);
            // ensure the newly created block gets the selection/drag handlers
            try{ setupBlockSelection && setupBlockSelection(); }catch(e){ console.warn('setupBlockSelection failed for new block', e); }
            // quitar la clase appear despu√©s de la animaci√≥n
            setTimeout(()=>{ try{ block.classList.remove('appear'); }catch(e){} }, 420);
            // peque√±o pulso visual en la columna
            try{ col.animate([{ transform: 'scale(1)' },{ transform: 'scale(1.02)' }, { transform: 'scale(1)'}], { duration: 260, easing: 'ease-out' }); }catch(e){}
            status.textContent = `Agregado parcial a ${name}. Total: ${col.querySelectorAll('.block').length}`;
            checkEmptyLines();
            // persist change so it survives reloads
            try{ saveState(); }catch(e){ /* ignore */ }
            // re-apply requested map just in case
            try{ applyRequestedToDOM(); }catch(e){}
            
            // ‚úÖ SINCRONIZAR CON FIREBASE - Esperar un poco para que el DOM est√© actualizado
            setTimeout(async () => {
                try{
                    console.log('üîÑ INICIANDO SINCRONIZACI√ìN (addPartial)...');
                    
                    // Esperar a que Firebase est√© inicializado
                    if(window.firebaseInitPromise){
                        await window.firebaseInitPromise;
                        console.log('‚úÖ Firebase est√° inicializado');
                    }
                    
                    // üî• ELIMINAR TIMESTAMP DE SOLICITUD SI EXISTE (abastecido desde KAMBAN)
                    if(window.db && lineName){
                        try{
                            // Verificar si hay solicitudes activas para esta l√≠nea
                            const solicitudesSnap = await window.db.ref(`solicitudes/${lineName}`).once('value');
                            const solicitudesData = solicitudesSnap.val() || {};
                            const hasSolicitudes = Object.keys(solicitudesData).length > 0;
                            
                            console.log(`%cüîç ABASTECER KAMBAN - Verificando solicitudes de ${lineName}:`, 'background: #2196F3; color: white; font-weight: bold;', {
                                solicitudesData,
                                hasSolicitudes
                            });
                            
                            if(!hasSolicitudes){
                                // üî• NO HAY SOLICITUDES PENDIENTES - ELIMINAR TIMESTAMP
                                await window.db.ref(`solicitud_times/${lineName}`).remove();
                                console.log(`%c‚è±Ô∏è TIMER DETENIDO EN FIREBASE (abastecido desde KAMBAN): ${lineName}`, 'background: #4CAF50; color: white; font-weight: bold;');
                                
                                // Limpiar cache local
                                if(window.firebaseTimestampsCache) delete window.firebaseTimestampsCache[lineName];
                                
                                // Forzar actualizaci√≥n de timers
                                setTimeout(() => {
                                    try{ window.updateColumnTimers(); }catch(e){}
                                }, 100);
                            } else {
                                console.log(`%c‚è±Ô∏è TIMER SIGUE CORRIENDO (quedan solicitudes pendientes): ${lineName}`, 'background: #FF9800; color: white; font-weight: bold;', solicitudesData);
                            }
                        }catch(e){ console.warn('Error verificando/eliminando timer de solicitud:', e); }
                    }
                    
                    const kanbanState = getCurrentKanbanState();
                    console.log('üì§ Enviando estado completo del Kanban a Firebase...');
                    console.log('üì¶ Estado a enviar:', JSON.stringify(kanbanState, null, 2));
                    
                    if(window.FirebaseSync && window.FirebaseSync.updateKanbanState){
                        // Actualizar timestamp local antes de enviar
                        window._lastKanbanUpdate = JSON.stringify(kanbanState);
                        
                        const result = await window.FirebaseSync.updateKanbanState(kanbanState);
                        console.log('‚úÖ Resultado de sincronizaci√≥n con Firebase:', result);
                        
                        if(result.success){
                            console.log('üéâ SINCRONIZACI√ìN EXITOSA - Los otros dispositivos deber√≠an ver el cambio');
                            
                            // Verificar que realmente se escribi√≥ en Firebase
                            setTimeout(async () => {
                                try {
                                    const verifySnap = await window.db.ref('kanban_estado').once('value');
                                    const verifyData = verifySnap.val() || {};
                                    console.log('üîç VERIFICACI√ìN: Datos en Firebase:', verifyData);
                                } catch(e) {
                                    console.error('‚ùå Error verificando datos:', e);
                                }
                            }, 500);
                        } else {
                            console.error('‚ùå SINCRONIZACI√ìN FALL√ì:', result.error);
                        }
                    } else {
                        console.warn('‚ö† FirebaseSync no disponible');
                    }
                }catch(e){
                    console.error('‚ùå Error sincronizando con Firebase:', e);
                }
            }, 100);
        }

        async function removePartial(name){
            const col = findColumn(name);
            if(!col){
                status.textContent = `L√≠nea "${name}" no encontrada.`;
                return;
            }
            if(col.classList.contains('inactive')){
                status.textContent = `L√≠nea "${name}" est√° inactiva. No se pueden quitar parciales.`;
                return;
            }
            const blocks = col.querySelectorAll('.block');
            if(blocks.length === 0){
                status.textContent = `No hay parciales para eliminar en ${name}.`;
                return;
            }
            const last = blocks[blocks.length-1];
            // animar eliminaci√≥n y luego remover
            last.classList.add('removing');
            setTimeout(()=>{
                try{ last.remove(); }catch(e){}
                status.textContent = `Eliminado parcial de ${name}. Restan: ${col.querySelectorAll('.block').length}`;
                checkEmptyLines();
                // persist change so it survives reloads
                try{ saveState(); rebuildBlockNamesFromDOM(); }catch(e){ /* ignore */ }
            }, 260);
        }

        btnAdd.addEventListener('click', ()=>{
            // Open modal to allow manual naming via scanner or quick add
            openBarcodeModal(input.value);
        });

        btnRemove.addEventListener('click', async ()=>{
            try{
                const lineName = (input.value||'').trim();
                if(lineName){
                    // capture last block info for history BEFORE removing
                    const col = findColumn(lineName);
                    let lastInfo = null;
                    if(col){
                        const blocks = col.querySelectorAll('.block');
                        if(blocks.length > 0){
                            const last = blocks[blocks.length-1];
                            const idx = parseInt(last.getAttribute('data-index')||'-1',10);
                            const name = last.getAttribute('data-name') || ((last.querySelector('.label')||{}).textContent||'').trim();
                            lastInfo = { line: lineName, index: idx, name };
                        }
                    }

                    // compute duration based on existing solicitud timestamp and save history entry
                    const now = Date.now();
                    let solicitudMap = {};
                    try{ solicitudMap = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ solicitudMap = {}; }
                    let history = [];
                    try{ history = JSON.parse(localStorage.getItem('pk_history')||'[]'); }catch(e){ history = []; }
                    if(lastInfo){
                        const prevSolic = solicitudMap[lastInfo.line] && solicitudMap[lastInfo.line].solicitud ? parseInt(solicitudMap[lastInfo.line].solicitud,10) : null;
                        const duration = prevSolic ? Math.max(0, now - prevSolic) : 0;
                        try{ addHistoryEntries([{ name: lastInfo.name || (lastInfo.line + '#' + lastInfo.index), line: lastInfo.line, index: lastInfo.index, requestedAt: prevSolic || now, suppliedAt: now, duration }]); }catch(e){}
                    }

                    // üî• REGISTRAR ABASTECIMIENTO EN FIREBASE ANTES DE ELIMINAR
                    if(lastInfo && window.FirebaseSync){
                        try{
                            await window.FirebaseSync.addAbastecimiento(lastInfo.line, lastInfo.name || (`${lastInfo.line}#${lastInfo.index}`));
                            console.log('‚úÖ Abastecimiento registrado en Firebase');
                        }catch(e){
                            console.error('‚ùå Error registrando abastecimiento:', e);
                        }
                    }

                    // Local removal only
                    removePartial(lineName);

                    // ‚úÖ SINCRONIZAR ELIMINACI√ìN CON FIREBASE - Esperar a que se complete la animaci√≥n
                    setTimeout(async () => {
                        try{
                            console.log('üîÑ INICIANDO SINCRONIZACI√ìN (removePartial)...');
                            
                            // Esperar a que Firebase est√© inicializado
                            if(window.firebaseInitPromise){
                                await window.firebaseInitPromise;
                                console.log('‚úÖ Firebase est√° inicializado');
                            }
                            
                            // üóëÔ∏è ELIMINAR DE kanban_estado EN FIREBASE Y REORGANIZAR √çNDICES
                            if(window.db && lastInfo){
                                try{
                                    // 1. Leer todo kanban_estado
                                    const kanbanSnap = await window.db.ref('kanban_estado').once('value');
                                    const kanbanData = kanbanSnap.val() || {};
                                    
                                    // 2. Eliminar el parcial espec√≠fico
                                    const lineParciales = kanbanData[lastInfo.line] || {};
                                    delete lineParciales[lastInfo.index];
                                    
                                    // 3. Convertir a array limpio (sin huecos)
                                    const parcialesArray = Object.keys(lineParciales)
                                        .sort((a, b) => parseInt(a) - parseInt(b))
                                        .map(key => lineParciales[key]);
                                    
                                    // 4. Guardar nuevamente reorganizado
                                    if(parcialesArray.length > 0) {
                                        const reorganized = {};
                                        parcialesArray.forEach((parcial, idx) => {
                                            reorganized[idx] = parcial;
                                        });
                                        await window.db.ref(`kanban_estado/${lastInfo.line}`).set(reorganized);
                                    } else {
                                        // Si no hay parciales, eliminar la l√≠nea
                                        await window.db.ref(`kanban_estado/${lastInfo.line}`).remove();
                                    }
                                    
                                    // 5. üî• SOLO ELIMINAR LA SOLICITUD ESPEC√çFICA (NO reorganizar)
                                    // Los √≠ndices de solicitudes se mantienen vinculados a la posici√≥n DOM original
                                    try{
                                        await window.db.ref(`solicitudes/${lastInfo.line}/${lastInfo.index}`).remove();
                                        console.log(`üóëÔ∏è SOLICITUD ELIMINADA: ${lastInfo.line}[${lastInfo.index}]`);
                                    }catch(e){ 
                                        console.warn('Error eliminando solicitud:', e);
                                    }
                                    
                                    console.log(`‚úÖ Parcial eliminado y reorganizado en Firebase: ${lastInfo.line}[${lastInfo.index}]`);
                                    
                                    // ‚è±Ô∏è DETENER TIMER SIEMPRE (solo hay 1 solicitud por l√≠nea)
                                    try{
                                        await window.db.ref(`solicitud_times/${lastInfo.line}`).remove();
                                        console.log(`%c‚è±Ô∏è‚úÖ TIMER DETENIDO EN FIREBASE: ${lastInfo.line}`, 'background: #4CAF50; color: white; font-weight: bold;');
                                        
                                        // üî• Limpiar cache local INMEDIATAMENTE
                                        if(window.firebaseTimestampsCache) {
                                            delete window.firebaseTimestampsCache[lastInfo.line];
                                            console.log('üóëÔ∏è Cache local limpiado:', lastInfo.line);
                                        }
                                        
                                        // üî• FORZAR ACTUALIZACI√ìN EN TODAS LAS VENTANAS
                                        localStorage.setItem('solicitud_times_firebase', JSON.stringify(window.firebaseTimestampsCache || {}));
                                        
                                        // Disparar evento de storage para sincronizar otras pesta√±as
                                        window.dispatchEvent(new StorageEvent('storage', {
                                            key: 'solicitud_times_firebase',
                                            newValue: JSON.stringify(window.firebaseTimestampsCache || {})
                                        }));
                                        
                                        // Actualizar timers en esta ventana
                                        setTimeout(() => {
                                            try{ window.updateColumnTimers(); }catch(e){}
                                        }, 50);
                                    }catch(e){ console.warn('Error deteniendo timer:', e); }
                                }catch(e){ console.warn('Error eliminando/reorganizando parcial de Firebase:', e); }
                            }
                            
                            console.log('üéâ ELIMINACI√ìN SINCRONIZADA - Los otros dispositivos deber√≠an ver el cambio');
                        }catch(e){
                            console.error('‚ùå Error sincronizando eliminaci√≥n:', e);
                        }
                    }, 300); // Esperar a que se complete la animaci√≥n de removePartial

                    // Mostrar notificaci√≥n de √©xito DESPU√âS de la animaci√≥n de removePartial (260ms)
                    setTimeout(()=>{
                        try{ 
                            status.style.display = 'block';
                            status.textContent = '‚úÖ Parcial abastecido correctamente'; 
                            alert('‚úÖ Parcial abastecido correctamente');
                            setTimeout(()=>{ 
                                status.textContent = ''; 
                                status.style.display = 'none';
                            }, 3000); 
                        }catch(e){}
                    }, 300);
                }
            }catch(e){ console.error('btnRemove error', e); }
            input.focus();
        });

        // enter key in input triggers add
        input.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter'){
                e.preventDefault();
                addPartial(input.value);
            }
        });

        /** RENDER / STORAGE SYNC **/
        // render columns from an array of {name, count, active}
        function renderColumns(lines){
            const container = document.querySelector('.container');
            if(!container) return;
            container.innerHTML = '';
            lines.forEach((line, idx) => {
                const col = document.createElement('div');
                col.className = 'column';
                if(line.active === false){
                    col.classList.add('inactive');
                }
                // Toggle buttons eliminados - usar panel de gesti√≥n para activar/desactivar l√≠neas
                
                const h = document.createElement('div');
                h.className = 'column-header';
                h.textContent = line.name;
                // add a small timer element under the header to show solicitud/salida durations
                const timer = document.createElement('div');
                timer.className = 'sol-timer';
                timer.textContent = '';
                col.appendChild(h);
                col.appendChild(timer);
                if(line.active === false){
                    const badge = document.createElement('div');
                    badge.className = 'inactive-badge';
                    badge.textContent = 'INACTIVA';
                    col.appendChild(badge);
                }
                // Renderizar bloques en orden normal (primero del array = primero visual)
                for(let i=0; i<(line.count||0); i++){
                    const b = document.createElement('div');
                    b.className = 'block';
                    // mark which line and index this block belongs to so we can persist "requested" state
                    b.setAttribute('data-line', line.name);
                    b.setAttribute('data-index', String(i));
                    // if we have a saved name for this block, set it
                    try{
                        const namesMap = JSON.parse(localStorage.getItem('pk_block_names')||'{}');
                        const nm = namesMap[line.name] && namesMap[line.name][String(i)];
                        if(nm){ b.setAttribute('data-name', nm); const span = document.createElement('span'); span.className='label'; span.textContent = nm; b.appendChild(span); }
                    }catch(e){}
                    // if this block index is present in requested map, add requested class
                    try{
                        const reqRaw = localStorage.getItem('pk_requested') || '{}';
                        const reqMap = reqRaw ? JSON.parse(reqRaw) : {};
                        const arr = Array.isArray(reqMap[line.name]) ? reqMap[line.name] : [];
                        if(arr.indexOf(i) !== -1) b.classList.add('requested');
                    }catch(e){ }
                    col.appendChild(b);
                }
                container.appendChild(col);
            });
            // re-run header click setup so newly rendered headers are interactive
            setupHeaderClicks && setupHeaderClicks();
            setupBlockSelection && setupBlockSelection();
            populateDatalist && populateDatalist();
            checkEmptyLines && checkEmptyLines();

            

            // ADJUST container width so the white background expands to fit the columns
            try{
                // remove CSS max-width restriction so we can size freely
                container.style.maxWidth = 'none';
                const cols = container.querySelectorAll('.column');
                if(cols.length > 0){
                    const first = cols[0];
                    // measure a single column's rendered width
                    const colW = first.offsetWidth || (parseFloat(getComputedStyle(first).minWidth) || 122);
                    const gap = parseFloat(getComputedStyle(container).gap) || 9;
                    const cs = getComputedStyle(container);
                    const padL = parseFloat(cs.paddingLeft) || 0;
                    const padR = parseFloat(cs.paddingRight) || 0;
                    // use fluid width so columns distribute across available viewport
                    container.style.maxWidth = '100%';
                    container.style.width = '100%';
                }
            }catch(e){ console.warn('renderColumns: width adjust failed', e); }
        }

        // Persist current DOM state (name + count + active) to localStorage so changes survive reload
        function getStateFromDOM(){
            try{
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                return cols.map(c => {
                    const name = (c.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const count = c.querySelectorAll('.block').length;
                    const active = !c.classList.contains('inactive');
                    return { name, count, active };
                });
            }catch(e){ console.error('getStateFromDOM', e); return []; }
        }

        // Get kanban state in Firebase format (lineName -> [parcial1, parcial2, ...])
        function getCurrentKanbanState(){
            try{
                const kanbanState = {};
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                const blockNamesMap = JSON.parse(localStorage.getItem('pk_block_names')||'{}');
                
                console.log('üîç getCurrentKanbanState: Leyendo estado actual del DOM...');
                
                cols.forEach(col => {
                    const lineName = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const blocks = Array.from(col.querySelectorAll('.block'));
                    
                    console.log(`üìã L√≠nea ${lineName}: ${blocks.length} bloques`);
                    
                    const parciales = blocks.map((b, idx) => {
                        // Prioridad 1: data-name attribute (lo m√°s confiable)
                        let blockName = b.getAttribute('data-name');
                        
                        // Prioridad 2: pk_block_names del localStorage
                        if(!blockName && blockNamesMap[lineName]){
                            blockName = blockNamesMap[lineName][String(idx)];
                        }
                        
                        // Prioridad 3: texto del label visible
                        if(!blockName){
                            const labelEl = b.querySelector('.label');
                            blockName = labelEl ? labelEl.textContent.trim() : '';
                        }
                        
                        // Prioridad 4: fallback gen√©rico
                        if(!blockName){
                            blockName = `Parcial ${idx+1}`;
                        }
                        
                        console.log(`  üì¶ [${idx}] = "${blockName}"`);
                        return blockName;
                    });
                    
                    // Guardar el array en orden l√≥gico directo (sin invertir)
                    // porque ahora el renderizado tambi√©n es directo
                    
                    // SIEMPRE incluir la l√≠nea, incluso si est√° vac√≠a
                    kanbanState[lineName] = parciales;
                });
                
                console.log('‚úÖ Estado del Kanban capturado:', kanbanState);
                return kanbanState;
            }catch(e){ 
                console.error('‚ùå getCurrentKanbanState error:', e); 
                return {}; 
            }
        }

        // Requested parciales persistence helpers
        function getRequestedMap(){
            try{ return JSON.parse(localStorage.getItem('pk_requested')||'{}'); }catch(e){ return {}; }
        }
        function saveRequestedMap(map){
            try{ localStorage.setItem('pk_requested', JSON.stringify(map)); }catch(e){}
        }
        // ensure requested classes are applied to blocks currently in the DOM
        function applyRequestedToDOM(){
            try{
                const map = getRequestedMap();
                const blocks = document.querySelectorAll('.container .column .block');
                blocks.forEach(b => {
                    const line = b.getAttribute('data-line') || ((b.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const idx = parseInt(b.getAttribute('data-index')||'-1',10);
                    if(line && Number.isFinite(idx)){
                        const arr = Array.isArray(map[line]) ? map[line] : [];
                        if(arr.indexOf(idx) !== -1) b.classList.add('requested'); else b.classList.remove('requested');
                    }
                });
            }catch(e){}
        }

        // Ensure each column has a sol-timer element for showing solicitud/salida durations
        function ensureTimerElements(){
            try{
                console.log('ensureTimerElements: scanning columns for .sol-timer');
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                cols.forEach(col => {
                    if(!col.querySelector('.sol-timer')){
                        const timer = document.createElement('div');
                        timer.className = 'sol-timer';
                        timer.textContent = '';
                        // insert after header if header exists
                        const hdr = col.querySelector('.column-header');
                        if(hdr && hdr.nextSibling) col.insertBefore(timer, hdr.nextSibling);
                        else if(hdr) col.appendChild(timer);
                        else col.insertBefore(timer, col.firstChild);
                        console.log('ensureTimerElements: created .sol-timer for', (hdr||{}).textContent);
                    }
                });
            }catch(e){ console.error('ensureTimerElements error', e); }
        }

        // Rebuild pk_requested from DOM requested classes (keeps indices consistent after removals)
        function rebuildRequestedFromDOM(){
            try{
                const map = {};
                const blocks = document.querySelectorAll('.container .column .block.requested');
                blocks.forEach(b => {
                    try{
                        const line = (b.getAttribute('data-line') || ((b.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent).trim();
                        const idx = parseInt(b.getAttribute('data-index')||'-1',10);
                        if(!line || !Number.isFinite(idx) || idx < 0) return;
                        map[line] = map[line] || [];
                        map[line].push(idx);
                    }catch(e){}
                });
                Object.keys(map).forEach(k=> map[k].sort((a,b)=>a-b));
                try{ localStorage.setItem('pk_requested', JSON.stringify(map)); }catch(e){}
                return map;
            }catch(e){ return {}; }
        }

        // Rebuild pk_block_names from DOM (used after removals or reindexing)
        function rebuildBlockNamesFromDOM(){
            try{
                const map = {};
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                cols.forEach(col => {
                    const line = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    if(!line) return;
                    const blocks = Array.from(col.querySelectorAll('.block'));
                    blocks.forEach((b,i)=>{
                        const nm = b.getAttribute('data-name') || ((b.querySelector('.label')||{}).textContent||'').trim();
                        if(nm) {
                            map[line] = map[line] || {};
                            map[line][String(i)] = nm;
                            // ensure data-index up to date
                            b.setAttribute('data-index', String(i));
                            b.setAttribute('data-line', line);
                        }
                    });
                });
                try{ localStorage.setItem('pk_block_names', JSON.stringify(map)); }catch(e){}
                return map;
            }catch(e){ return {}; }
        }

        // Barcode modal logic
        function openBarcodeModal(prefillLine){
            try{
                const modal = document.getElementById('barcode-modal');
                const lineInput = document.getElementById('barcode-line-input');
                const scanInput = document.getElementById('barcode-input');
                const list = document.getElementById('barcode-scan-list');
                if(!modal || !scanInput) return;
                modal.classList.add('open'); modal.setAttribute('aria-hidden','false');
                if(prefillLine) lineInput.value = prefillLine;
                list.innerHTML = '';
                scanInput.value = '';
                scanInput.focus();

                function addScanned(name){
                    const lineName = (lineInput.value||'').trim() || input.value;
                    if(!lineName) { alert('Selecciona o escribe la l√≠nea antes.'); return; }
                    // add a new partial with this name
                    addPartial(lineName, name);
                    try{ ensureBlockDataAttributes(); rebuildBlockNamesFromDOM(); applyRequestedToDOM(); ensureTimerElements(); }catch(e){}
                    // close modal immediately after adding
                    try{ closeModal(); }catch(err){ /* closeModal is defined below */ }
                }

                function onKey(e){
                    if(e.key === 'Enter'){
                        const val = scanInput.value.trim();
                        if(val) { addScanned(val); scanInput.value = ''; }
                        e.preventDefault();
                    }
                }

                scanInput.addEventListener('keydown', onKey);

                // populate lines list inside the details so user can pick existing line quickly
                try{
                    const ul = document.getElementById('barcode-lines-ul');
                    ul.innerHTML = '';
                    // prefer stored pk_lines, fallback to DOM
                    let lines = [];
                    try{ lines = JSON.parse(localStorage.getItem('pk_lines')||'[]'); }catch(e){}
                    if(!Array.isArray(lines) || lines.length === 0){
                        try{ lines = Array.from(document.querySelectorAll('.container > .column')).map(c => ({ name: (c.querySelector('.column-header')||{textContent:''}).textContent.trim() })); }catch(e){}
                    }
                    lines.forEach(l => {
                        const li = document.createElement('li');
                        li.textContent = (l && l.name) ? l.name : (typeof l === 'string' ? l : '');
                        li.style.padding = '6px';
                        li.style.cursor = 'pointer';
                        li.addEventListener('click', ()=>{ document.getElementById('barcode-line-input').value = li.textContent; document.getElementById('barcode-input').focus(); try{ const d = document.getElementById('barcode-lines-list'); if(d && d.open) d.open = false; }catch(e){} });
                        ul.appendChild(li);
                    });
                }catch(e){ }

                // cancel
                const cancel = document.getElementById('barcode-cancel');
                const closeModal = function(){ try{ scanInput.removeEventListener('keydown', onKey); }catch(e){}; modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); try{ input.focus(); }catch(e){} };
                function onCancel(){ closeModal(); }
                cancel && cancel.addEventListener('click', onCancel);
            }catch(e){ console.error('openBarcodeModal failed', e); }
        }

        function formatDurationShort(ms){
            if(!ms || ms < 0) return '0s';
            const s = Math.floor(ms/1000);
            const hh = Math.floor(s/3600); const mm = Math.floor((s%3600)/60); const ss = s%60;
            if(hh>0) return `${hh}h ${mm}m ${ss}s`;
            if(mm>0) return `${mm}m ${ss}s`;
            return `${ss}s`;
        }
        
        // üî• OBJETO GLOBAL PARA ALMACENAR TIMESTAMPS DE FIREBASE EN TIEMPO REAL
        window.firebaseTimestampsCache = {};
        
        // Update per-column timers based on pk_solicitud_salida entries
        function updateColumnTimers(){
            try{
                const map = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}');
                
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                cols.forEach(col => {
                    const name = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const timerEl = col.querySelector('.sol-timer');
                    if(!timerEl) return;
                    
                    // üî• LEER DESDE CACHE DE FIREBASE (actualizado en tiempo real por listeners)
                    const firebaseStart = window.firebaseTimestampsCache ? window.firebaseTimestampsCache[name] : null;
                    
                    // DEBUG: Mostrar cache completo cada 5 segundos
                    if(!window._lastCacheLog || Date.now() - window._lastCacheLog > 5000){
                        console.log('%cüì¶ CACHE ACTUAL:', 'background: #9C27B0; color: white;', window.firebaseTimestampsCache);
                        window._lastCacheLog = Date.now();
                    }
                    
                    if(firebaseStart){
                        // ‚úÖ USAR TIMESTAMP DE FIREBASE (sincronizado)
                        const elapsed = Date.now() - firebaseStart;
                        timerEl.textContent = 'Solicitado: ' + formatDurationShort(elapsed);
                    } else {
                        // Fallback a localStorage si no hay en Firebase
                        const entry = map[name];
                        if(entry && entry.solicitud){
                            const solicitud = parseInt(entry.solicitud,10) || 0;
                            const salida = entry.salida ? (parseInt(entry.salida,10)||0) : 0;
                            if(solicitud && !salida){
                                timerEl.textContent = 'Solicitado: ' + formatDurationShort(Date.now() - solicitud);
                            } else if(solicitud && salida){
                                timerEl.textContent = 'Tiempo: ' + formatDurationShort(salida - solicitud);
                            } else timerEl.textContent = '';
                        } else {
                            timerEl.textContent = '';
                        }
                    }
                });
            }catch(e){ console.error('%c‚ùå updateColumnTimers ERROR:', 'background: #FF6B6B; color: white;', e); }
        }

        // start interval to refresh column timers (and keep a quick initial update)
        try{
            console.log('%c‚è±Ô∏è INICIANDO INTERVALO DE TIMERS CADA 100ms (M√ÅS R√ÅPIDO)...', 'background: #FF9800; color: white; font-weight: bold;');
            // store interval id in window for debugging/ability to clear
            // Reducido a 100ms para actualizaci√≥n casi en tiempo real
            window._colTimersInterval = setInterval(()=>{ 
                try{ 
                    ensureTimerElements(); 
                    updateColumnTimers(); 
                }catch(e){ 
                    console.error('%c‚ùå TIMER INTERVAL ERROR:', 'background: #FF6B6B; color: white;', e); 
                } 
            }, 100);
            console.log('%c‚úÖ INTERVALO INICIADO:', 'background: #4CAF50; color: white;', 'ID =', window._colTimersInterval);
        }catch(e){ 
            console.error('%c‚ùå FAILED TO START TIMERS INTERVAL:', 'background: #FF6B6B; color: white;', e); 
        }
        
        // üîÑ TAMBI√âN ESCUCHAR CAMBIOS EN localStorage PARA ACTUALIZACIONES CROSS-TAB
        window.addEventListener('storage', (e) => {
            if(e.key === 'solicitud_times_firebase'){
                console.log('%cüîÑ EVENTO STORAGE: solicitud_times_firebase CAMBI√ì EN OTRA PESTA√ëA', 'background: #2196F3; color: white; font-weight: bold;');
                try{ 
                    updateColumnTimers(); 
                }catch(err){ 
                    console.error('%c‚ùå Error en storage event handler:', 'background: #FF6B6B; color: white;', err); 
                }
            }
        });

        // expose functions for manual debugging in console
        try{ window.ensureTimerElements = ensureTimerElements; window.updateColumnTimers = updateColumnTimers; }catch(e){ }
        // expose requested-map helpers to other scripts (they run in separate script blocks)
        try{ window.getRequestedMap = getRequestedMap; window.saveRequestedMap = saveRequestedMap; window.applyRequestedToDOM = applyRequestedToDOM; window.ensureBlockDataAttributes = ensureBlockDataAttributes; }catch(e){ }

        // Ensure existing static DOM blocks have `data-line` and `data-index` attributes
        function ensureBlockDataAttributes(){
            try{
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                cols.forEach(col => {
                    const lineName = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const blocks = Array.from(col.querySelectorAll('.block'));
                    blocks.forEach((b, i) => {
                        if(!b.hasAttribute('data-line')) b.setAttribute('data-line', lineName);
                        if(!b.hasAttribute('data-index')) b.setAttribute('data-index', String(i));
                    });
                });
            }catch(e){}
        }

        function saveState(){
            try{
                const state = getStateFromDOM();
                localStorage.setItem('pk_lines', JSON.stringify(state));
                // no need to dispatch storage event here; other tabs will receive native event
            }catch(e){ console.error('saveState', e); }
        }

        // load lines from localStorage and render
        function loadLinesFromStorage(){
            try{
                const raw = localStorage.getItem('pk_lines');
                if(!raw) return false;
                const lines = JSON.parse(raw);
                if(Array.isArray(lines)){
                    renderColumns(lines);
                    return true;
                }
            }catch(e){ console.error('loadLinesFromStorage', e); }
            return false;
        }

        // expose a helper so other scripts (manage panel) can apply lines directly without reloading
        window.applyLinesToDOM = function(lines){
            try{ renderColumns(lines); populateDatalist && populateDatalist(); setupHeaderClicks && setupHeaderClicks(); setupBlockSelection && setupBlockSelection(); checkEmptyLines && checkEmptyLines(); }catch(e){ console.warn('applyLinesToDOM failed', e); }
        };

        // listen to storage changes from manage page
        window.addEventListener('storage', (e)=>{
            if(e.key === 'pk_lines'){
                loadLinesFromStorage();
                try{ ensureBlockDataAttributes(); applyRequestedToDOM(); ensureTimerElements(); updateColumnTimers(); }catch(e){}
            }
            // if requested map changed in another tab, reapply requested state and timers
            if(e.key === 'pk_requested' || e.key === 'pk_solicitud_salida'){
                try{ ensureBlockDataAttributes(); applyRequestedToDOM(); ensureTimerElements(); updateColumnTimers(); }catch(e){}
            }
        });

        // initial attempt to load from storage; if none, keep static DOM
        loadLinesFromStorage();
        
        // üßπ LIMPIAR SOLICITUDES LOCALES - Firebase ser√° la √∫nica fuente de verdad
        console.log('üßπ Limpiando pk_requested local (Firebase es la fuente de verdad)...');
        try{ 
            localStorage.setItem('pk_requested', JSON.stringify({})); 
            console.log('‚úÖ pk_requested limpiado - esperando datos de Firebase');
        }catch(e){}
        
        // ensure static DOM blocks have data attributes, then apply requested state and show timers
        try{ ensureBlockDataAttributes(); ensureTimerElements(); updateColumnTimers(); }catch(e){}

        // üîÑ FUNCI√ìN GLOBAL PARA SINCRONIZAR PANEL DE GESTI√ìN
        window.syncManagePanelFromFirebase = function(){
            console.log('üîÑ [SINCRONIZACI√ìN GLOBAL] Actualizando panel de gesti√≥n...');
            try{
                // Buscar la funci√≥n render() del panel de gesti√≥n y ejecutarla
                // La IIFE del panel debe estar expuesta globalmente o aqu√≠ la llamamos
                const listEl = document.getElementById('m-lines-list');
                if(listEl){
                    // Disparar evento de storage para que el listener del panel se active
                    window.dispatchEvent(new StorageEvent('storage', {key: 'pk_lines', newValue: localStorage.getItem('pk_lines')}));
                    console.log('‚úÖ [SINCRONIZACI√ìN GLOBAL] Evento de storage disparado para panel');
                }
            }catch(e){
                console.error('‚ùå Error en sincronizaci√≥n global:', e);
            }
        };

        // üî•üü† REGISTRAR LISTENER DE SOLICITUDES EN TIEMPO REAL (TITILADO)
        console.log('%cüî•üü† REGISTRANDO LISTENER DE SOLICITUDES...', 'background: orange; color: white; font-weight: bold; padding: 4px;');
        
        if(window.db){
            console.log('‚úÖ window.db disponible, registrando listener...');
            console.log('üîó Referencia:', window.db.ref('solicitudes').toString());
            
            window.db.ref('solicitudes').on('value', (snap) => {
                console.log('%cüîîüü† ¬°¬°¬° EVENTO DE SOLICITUDES RECIBIDO (TITILADO) !!!', 'background: orange; color: white; font-weight: bold; padding: 8px; font-size: 16px;');
                const firebaseSolicitudes = snap.val() || {};
                console.log('üì• Solicitudes de Firebase:', firebaseSolicitudes);
                
                if(!firebaseSolicitudes || Object.keys(firebaseSolicitudes).length === 0){
                    console.log('‚ö™ Firebase NO tiene solicitudes - limpiando todo el titilado');
                }
                
                // Convertir solicitudes de Firebase a pk_requested
                const pk_requested = {};
                
                Object.keys(firebaseSolicitudes).forEach(lineName => {
                    const lineData = firebaseSolicitudes[lineName];
                    if(lineData && typeof lineData === 'object'){
                        pk_requested[lineName] = Object.keys(lineData)
                            .filter(key => lineData[key] && lineData[key].requestedAt)
                            .map(key => parseInt(key));
                    }
                });
                
                console.log('üü† pk_requested construido:', pk_requested);
                
                try { 
                    localStorage.setItem('pk_requested', JSON.stringify(pk_requested)); 
                } catch(e) { 
                    console.warn('localStorage no disponible'); 
                }
                
                // üü†üéØ APLICAR TITILADO AL DOM (ROBUSTO - SIN REORGANIZAR √çNDICES)
                const columns = document.querySelectorAll('.container > .column');
                let totalActivado = 0;
                let totalDesactivado = 0;
                
                columns.forEach(col => {
                    try{
                        const lineName = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                        const blocks = Array.from(col.querySelectorAll('.block'));
                        const requestedIndices = pk_requested[lineName] || [];
                        
                        // üî• IMPORTANTE: NO actualizar data-index
                        // Los √≠ndices deben mantenerse fijos para que las solicitudes persistan correctamente
                        blocks.forEach((block, domPosition) => {
                            // Usar el data-index almacenado (si existe), sino usar posici√≥n DOM
                            let blockIdx = block.hasAttribute('data-index') 
                                ? parseInt(block.getAttribute('data-index'))
                                : domPosition;
                            
                            // Asegurar que tenga data-index si no lo tiene
                            if(!block.hasAttribute('data-index')){
                                block.setAttribute('data-index', String(domPosition));
                                blockIdx = domPosition;
                            }
                            
                            if(!block.hasAttribute('data-line')){
                                block.setAttribute('data-line', lineName);
                            }
                            
                            // Comparar con solicitudes usando el √≠ndice almacenado
                            if(requestedIndices.includes(blockIdx)) {
                                if(!block.classList.contains('requested')){
                                    block.classList.add('requested');
                                    console.log(`‚ú®üü† TITILADO ACTIVADO: ${lineName}[${blockIdx}] (DOM pos: ${domPosition})`);
                                    totalActivado++;
                                }
                            } else {
                                if(block.classList.contains('requested')){
                                    block.classList.remove('requested');
                                    console.log(`üîá TITILADO DESACTIVADO: ${lineName}[${blockIdx}] (DOM pos: ${domPosition})`);
                                    totalDesactivado++;
                                }
                            }
                        });
                    }catch(e){
                        console.warn('Error procesando columna para titilado:', e);
                    }
                });
                
                console.log(`‚úÖ Titilado sincronizado: ${totalActivado} activados, ${totalDesactivado} desactivados`);
            }, (error) => {
                console.error('‚ùå ERROR EN LISTENER DE SOLICITUDES:', error);
            });
            
            console.log('‚úÖ‚úÖ LISTENER DE SOLICITUDES REGISTRADO CORRECTAMENTE');
            
            // üîµüì¶ REGISTRAR LISTENER DE KANBAN_ESTADO (ABASTECIMIENTO EN TIEMPO REAL)
            console.log('%cüîµüì¶ REGISTRANDO LISTENER DE KANBAN_ESTADO...', 'background: blue; color: white; font-weight: bold; padding: 4px;');
            
            // üîç RASTREAR L√çNEAS VAC√çAS
            let emptyLineStates = {}; // { lineName: boolean } para rastrear si est√° vac√≠a
            
            window.db.ref('kanban_estado').on('value', (snap) => {
                console.log('%cüîîüîµ ¬°¬°¬° EVENTO DE KANBAN_ESTADO RECIBIDO (ABASTECIMIENTO) !!!', 'background: blue; color: white; font-weight: bold; padding: 8px; font-size: 16px;');
                const firebaseKanban = snap.val() || {};
                console.log('üì• Kanban de Firebase:', firebaseKanban);
                
                if(!firebaseKanban || Object.keys(firebaseKanban).length === 0){
                    console.log('‚ö™ Firebase no tiene datos de kanban');
                    return;
                }
                
                // Convertir objetos a arrays (Firebase convierte arrays en objetos)
                const convertToArray = (obj) => {
                    if(!obj) return [];
                    if(Array.isArray(obj)) return obj;
                    const keys = Object.keys(obj).sort((a, b) => parseInt(a) - parseInt(b));
                    return keys.map(k => obj[k]);
                };
                
                // Aplicar cambios al DOM
                Object.keys(firebaseKanban).forEach(lineName => {
                    try{
                        const col = findColumn(lineName);
                        if(!col) {
                            console.warn(`Columna ${lineName} no encontrada`);
                            return;
                        }
                        
                        const firebaseParciales = convertToArray(firebaseKanban[lineName]);
                        const domBlocks = Array.from(col.querySelectorAll('.block'));
                        
                        console.log(`üìä ${lineName}: Firebase=${firebaseParciales.length}, DOM=${domBlocks.length}`);
                        
                        // üîç DETECTAR CAMBIO DE ESTADO VAC√çO
                        const wasEmpty = emptyLineStates[lineName] || false;
                        const isEmpty = firebaseParciales.length === 0;
                        
                        if(wasEmpty !== isEmpty){
                            emptyLineStates[lineName] = isEmpty;
                            if(isEmpty){
                                console.log(`üü° L√çNEA VAC√çA DETECTADA: ${lineName}`);
                            } else {
                                console.log(`üü¢ L√çNEA CON PARCIALES: ${lineName}`);
                            }
                            // Aqu√≠ se podr√≠a agregar l√≥gica adicional si se necesita
                        }
                        
                        // üî• SINCRONIZACI√ìN COMPLETA: Reconstruir DOM para que coincida exactamente con Firebase
                        
                        // Si los parciales son diferentes, reconstruir completamente
                        const needsRebuild = firebaseParciales.length !== domBlocks.length ||
                            firebaseParciales.some((parcial, idx) => {
                                const block = domBlocks[idx];
                                return !block || block.getAttribute('data-name') !== parcial;
                            });
                        
                        if(needsRebuild){
                            console.log(`üîÑ RECONSTRUYENDO DOM de ${lineName} para sincronizar con Firebase`);
                            console.log(`   Firebase: [${firebaseParciales.join(', ')}]`);
                            console.log(`   DOM: [${domBlocks.map(b => b.getAttribute('data-name')).join(', ')}]`);
                            
                            // 1Ô∏è‚É£ Eliminar todos los bloques existentes con animaci√≥n
                            domBlocks.forEach((block, idx) => {
                                block.classList.add('removing');
                                setTimeout(() => {
                                    try{ 
                                        if(block.parentNode) {
                                            block.parentNode.removeChild(block);
                                        }
                                    }catch(e){}
                                }, 50 + (idx * 20)); // Animaci√≥n escalonada
                            });
                            
                            // 2Ô∏è‚É£ Despu√©s de eliminar, agregar los nuevos bloques desde Firebase
                            setTimeout(() => {
                                firebaseParciales.forEach((parcialName, idx) => {
                                    const block = document.createElement('div');
                                    block.className = 'block appear';
                                    block.setAttribute('data-line', lineName);
                                    block.setAttribute('data-index', String(idx));
                                    block.setAttribute('data-name', parcialName);
                                    
                                    const label = document.createElement('span');
                                    label.className = 'label';
                                    label.textContent = parcialName;
                                    block.appendChild(label);
                                    
                                    col.appendChild(block);
                                    
                                    // Remover clase de animaci√≥n
                                    setTimeout(() => {
                                        block.classList.remove('appear');
                                    }, 300);
                                });
                                
                                console.log(`‚úÖ DOM reconstruido: ${lineName} ahora tiene ${firebaseParciales.length} parciales`);
                            }, domBlocks.length > 0 ? (100 + (domBlocks.length * 20)) : 0);
                        } else {
                            console.log(`‚úÖ ${lineName} ya est√° sincronizado`);
                        }
                        
                    }catch(e){
                        console.warn(`Error procesando l√≠nea ${lineName}:`, e);
                    }
                });
                
                // üî• IMPORTANTE: Re-sincronizar √≠ndices de data-attributes despu√©s de cambios
                try{
                    ensureBlockDataAttributes();
                    console.log('üîÑ Data-attributes actualizados tras sincronizaci√≥n');
                }catch(e){
                    console.warn('Error actualizando data-attributes:', e);
                }
                
                // Actualizar contadores y UI
                try{ checkEmptyLines(); }catch(e){}
                try{ setupBlockSelection(); }catch(e){}
                
                // üü† Re-aplicar titilado despu√©s de reorganizaci√≥n para asegurar consistencia
                // Esperar un poco m√°s para que la reconstrucci√≥n termine
                setTimeout(() => {
                    try{
                        // Re-asegurar data-attributes despu√©s de reconstrucci√≥n
                        ensureBlockDataAttributes();
                        
                        // Re-aplicar titilado
                        if(window.applyRequestedToDOM){
                            window.applyRequestedToDOM();
                            console.log('üü† Titilado reaplicado tras sincronizaci√≥n de kanban');
                        }
                        
                        // Re-configurar event listeners en los nuevos bloques
                        if(window.setupBlockSelection){
                            window.setupBlockSelection();
                            console.log('üñ±Ô∏è Event listeners reconfigurados en bloques');
                        }
                    }catch(e){
                        console.warn('Error reaplicando titilado:', e);
                    }
                }, 400); // Aumentado para que la reconstrucci√≥n termine
                
                console.log('‚úÖ Kanban sincronizado desde Firebase');
            }, (error) => {
                console.error('‚ùå ERROR EN LISTENER DE KANBAN_ESTADO:', error);
            });
            
            console.log('‚úÖ‚úÖ LISTENER DE KANBAN_ESTADO REGISTRADO CORRECTAMENTE');
            
            // üü¢üÜï DETECTAR L√çNEAS NUEVAS O ELIMINADAS (child_added / child_removed)
            console.log('%cüü¢üÜï REGISTRANDO LISTENERS DE L√çNEAS NUEVAS/ELIMINADAS...', 'background: green; color: white; font-weight: bold; padding: 4px;');
            
            // Listener cuando se AGREGA una l√≠nea nueva
            // NOTA: Este evento tambi√©n se dispara en la carga inicial para cada l√≠nea existente
            let initialLoadComplete = false;
            setTimeout(() => { initialLoadComplete = true; }, 3000); // Despu√©s de 3s, considerar carga inicial completa
            
            window.db.ref('kanban_estado').on('child_added', (snap) => {
                const lineName = snap.key;
                const parciales = snap.val() || [];
                
                // Verificar si la l√≠nea ya existe en el DOM
                const existingCol = findColumn(lineName);
                if(existingCol){
                    // La l√≠nea ya existe, no hacer nada
                    return;
                }
                
                // Solo crear la l√≠nea si NO es parte de la carga inicial
                if(!initialLoadComplete){
                    console.log(`‚ö™ Carga inicial: l√≠nea ${lineName} ignorada (ya deber√≠a existir)`);
                    return;
                }
                
                console.log(`üü¢üÜï NUEVA L√çNEA DETECTADA EN FIREBASE: ${lineName}`);
                
                console.log(`‚ûï CREANDO NUEVA L√çNEA EN DOM: ${lineName}`);
                
                // Crear la nueva columna en el DOM
                try{
                    const container = document.querySelector('.container');
                    if(!container) return;
                    
                    const newCol = document.createElement('div');
                    newCol.className = 'column';
                    newCol.setAttribute('data-line', lineName);
                    
                    // Header
                    const header = document.createElement('div');
                    header.className = 'column-header';
                    header.textContent = lineName;
                    newCol.appendChild(header);
                    
                    // Timer
                    const timer = document.createElement('div');
                    timer.className = 'sol-timer';
                    newCol.appendChild(timer);
                    
                    // Agregar parciales si existen
                    const convertToArray = (obj) => {
                        if(!obj) return [];
                        if(Array.isArray(obj)) return obj;
                        const keys = Object.keys(obj).sort((a, b) => parseInt(a) - parseInt(b));
                        return keys.map(k => obj[k]);
                    };
                    
                    const parcialesArray = convertToArray(parciales);
                    parcialesArray.forEach((parcialName, idx) => {
                        const block = document.createElement('div');
                        block.className = 'block appear';
                        block.setAttribute('data-line', lineName);
                        block.setAttribute('data-index', String(idx));
                        block.setAttribute('data-name', parcialName);
                        
                        const label = document.createElement('span');
                        label.className = 'label';
                        label.textContent = parcialName;
                        block.appendChild(label);
                        
                        newCol.appendChild(block);
                        
                        setTimeout(() => block.classList.remove('appear'), 420);
                    });
                    
                    // Agregar al container
                    container.appendChild(newCol);
                    
                    // Actualizar localStorage
                    try{
                        let lines = JSON.parse(localStorage.getItem('pk_lines') || '[]');
                        if(!lines.find(l => l.name === lineName)){
                            lines.push({ name: lineName, count: parcialesArray.length, active: true });
                            localStorage.setItem('pk_lines', JSON.stringify(lines));
                        }
                    }catch(e){}
                    
                    // Actualizar UI
                    try{ setupBlockSelection(); }catch(e){}
                    try{ populateDatalist(); }catch(e){}
                    
                    console.log(`‚úÖ Nueva l√≠nea ${lineName} creada en DOM con ${parcialesArray.length} parcial(es)`);
                    
                }catch(e){
                    console.error(`Error creando l√≠nea ${lineName}:`, e);
                }
            });
            
            // üö´ NO ELIMINAR AUTOM√ÅTICAMENTE - Las l√≠neas vac√≠as deben permanecer
            // La √∫nica forma de eliminar l√≠neas es manualmente desde "GESTI√ìN L√çNEAS"
            console.log('‚ÑπÔ∏è Las l√≠neas vac√≠as NO se eliminar√°n autom√°ticamente');
            console.log('‚ÑπÔ∏è Para eliminar l√≠neas, usa el bot√≥n "GESTI√ìN L√çNEAS"');
            
            console.log('‚úÖ‚úÖ LISTENERS DE L√çNEAS NUEVAS/ELIMINADAS REGISTRADOS');
            
            // üîÑ LISTENER DE ORDEN DE L√çNEAS - Sincronizaci√≥n en tiempo real
            console.log('%cüîÑ REGISTRANDO LISTENER DE ORDEN DE L√çNEAS...', 'background: purple; color: white; font-weight: bold; padding: 4px;');
            
            window.db.ref('line_order').on('value', (snap) => {
                const orderData = snap.val();
                console.log('üîÑ [LISTENER line_order] DISPARADO - Valor:', orderData);
                
                if(!orderData){
                    console.log('‚ö™ line_order no existe, saltando...');
                    return;
                }
                
                // Extraer el array de l√≠neas (puede ser array directo o dentro de objeto con timestamp)
                let lineOrder = Array.isArray(orderData) ? orderData : (orderData.lines || []);
                
                if(!Array.isArray(lineOrder) || lineOrder.length === 0){
                    console.log('‚ö™ line_order no es array v√°lido, saltando...');
                    return;
                }
                
                console.log('%cüî¥ ORDEN DE L√çNEAS ACTUALIZADO EN FIREBASE:', 'background: red; color: white; font-weight: bold; padding: 8px;', lineOrder);
                
                // Actualizar localStorage pk_lines con el nuevo orden
                try{
                    let lines = JSON.parse(localStorage.getItem('pk_lines') || '[]');
                    if(lines.length === 0) lines = lineOrder.map(name => ({name, active: true, count: 0}));
                    
                    // Reordenar el array de l√≠neas seg√∫n lineOrder
                    const lineMap = {};
                    lines.forEach(line => {
                        lineMap[line.name] = line;
                    });
                    
                    const reorderedLines = lineOrder.map(name => lineMap[name] || {name, active: true, count: 0});
                    localStorage.setItem('pk_lines', JSON.stringify(reorderedLines));
                    console.log('‚úÖ localStorage pk_lines ACTUALIZADO con nuevo orden:', reorderedLines.map(l => l.name));
                    
                    // Disparar evento de storage para que el panel se actualice
                    window.dispatchEvent(new StorageEvent('storage', {key: 'pk_lines'}));
                    
                    // Tambi√©n llamar la funci√≥n global de sincronizaci√≥n
                    if(window.syncManagePanelFromFirebase) window.syncManagePanelFromFirebase();
                }catch(e){
                    console.error('‚ùå Error actualizando localStorage desde Firebase:', e);
                }
                
                // Aplicar orden al kanban
                try{
                    const container = document.querySelector('.container');
                    if(!container) return;
                    
                    // Crear mapa de columnas por nombre
                    const columnMap = {};
                    const columns = Array.from(container.querySelectorAll('.column'));
                    columns.forEach(col => {
                        const header = col.querySelector('.column-header');
                        if(header){
                            const name = header.textContent.trim();
                            columnMap[name] = col;
                        }
                    });
                    
                    // Reordenar seg√∫n lineOrder
                    lineOrder.forEach(lineName => {
                        const col = columnMap[lineName];
                        if(col){
                            container.appendChild(col); // mueve al final en orden
                        }
                    });
                    
                    console.log('‚úÖ ORDEN DE COLUMNAS APLICADO AL KANBAN:', lineOrder);
                }catch(e){
                    console.error('‚ùå Error aplicando orden al kanban:', e);
                }
            });
            
            console.log('‚úÖ LISTENER DE ORDEN DE L√çNEAS REGISTRADO');
            
            // üîÑ LISTENER DE ESTRUCTURA DE L√çNEAS - Sincronizar cambios en nombres y estado
            console.log('%cüìù REGISTRANDO LISTENER DE ESTRUCTURA DE L√çNEAS...', 'background: #FF6B6B; color: white; font-weight: bold; padding: 4px;');
            
            window.db.ref('line_structure').on('value', (snap) => {
                const structure = snap.val();
                if(!structure || !Array.isArray(structure)){
                    console.log('‚ö™ line_structure no existe o no es array, saltando...');
                    return;
                }
                
                console.log('üîÑ ESTRUCTURA DE L√çNEAS ACTUALIZADA EN FIREBASE:', structure);
                
                // Actualizar localStorage
                try{
                    const lines = JSON.parse(localStorage.getItem('pk_lines') || '[]');
                    
                    // Verificar si hay cambios
                    let hasChanges = false;
                    
                    // Sincronizar nombres y estados
                    structure.forEach((newLine, idx) => {
                        if(!lines[idx] || lines[idx].name !== newLine.name || lines[idx].active !== newLine.active){
                            if(!lines[idx]) lines[idx] = {};
                            const oldName = lines[idx].name;
                            lines[idx].name = newLine.name;
                            lines[idx].active = newLine.active;
                            hasChanges = true;
                            
                            // Renombrar columna en DOM si el nombre cambi√≥
                            if(oldName && oldName !== newLine.name){
                                try{
                                    const col = document.querySelector(`[data-line="${oldName}"]`)?.closest('.column');
                                    if(col){
                                        const header = col.querySelector('.column-header');
                                        if(header) header.textContent = newLine.name;
                                        col.setAttribute('data-line', newLine.name);
                                        
                                        // Actualizar todos los blocks en esa columna
                                        col.querySelectorAll('.block').forEach(block => {
                                            block.setAttribute('data-line', newLine.name);
                                        });
                                    }
                                }catch(e){console.error('Error renombrando columna:', e);}
                            }
                        }
                    });
                    
                    // Eliminar l√≠neas que no existen en la estructura
                    if(lines.length > structure.length){
                        lines.splice(structure.length);
                        hasChanges = true;
                    }
                    
                    if(hasChanges){
                        localStorage.setItem('pk_lines', JSON.stringify(lines));
                        console.log('‚úÖ ESTRUCTURA SINCRONIZADA EN LOCAL:', lines);
                        
                        // Disparar evento de storage para que otros listeners se actualicen
                        window.dispatchEvent(new StorageEvent('storage', {key: 'pk_lines'}));
                        
                        // Tambi√©n llamar la funci√≥n global de sincronizaci√≥n
                        if(window.syncManagePanelFromFirebase) window.syncManagePanelFromFirebase();
                    }
                }catch(e){
                    console.error('‚ùå Error sincronizando estructura local:', e);
                }
            });
            
            console.log('‚úÖ LISTENER DE ESTRUCTURA DE L√çNEAS REGISTRADO');
            
            // üü£ REGISTRANDO LISTENER DE TIMESTAMPS DE SOLICITUD (PARA SINCRONIZACI√ìN EN TIEMPO REAL)
            console.log('%c‚è±Ô∏è REGISTRANDO LISTENER DE SOLICITUD_TIMES...', 'background: #9C27B0; color: white; font-weight: bold; padding: 4px;');
            
            window.db.ref('solicitud_times').on('value', (snap) => {
                try{
                    const timesData = snap.val() || {};
                    console.log('%c‚è±Ô∏è EVENTO FIREBASE solicitud_times:', 'background: #9C27B0; color: white; font-weight: bold;', timesData);
                    
                    // üî• ACTUALIZAR CACHE GLOBAL CON NUEVOS TIMESTAMPS
                    window.firebaseTimestampsCache = timesData;
                    console.log('%c‚úÖ Cache de timestamps actualizado:', 'background: #4CAF50; color: white;', window.firebaseTimestampsCache);
                    
                    // Guardar tambi√©n en localStorage como respaldo
                    localStorage.setItem('solicitud_times_firebase', JSON.stringify(timesData));
                    
                    // Actualizar timers inmediatamente
                    setTimeout(() => {
                        try{ 
                            console.log('%c‚è±Ô∏è Actualizando timers por cambio en Firebase...', 'background: #9C27B0; color: white;');
                            window.updateColumnTimers(); 
                        }catch(e){ 
                            console.error('%c‚ùå ERROR CALLING updateColumnTimers:', 'background: #FF6B6B; color: white;', e); 
                        }
                    }, 10);
                    
                }catch(e){
                    console.error('%c‚ùå Error procesando solicitud_times:', 'background: #FF6B6B; color: white;', e);
                }
            });
            
            // üì± ESCUCHAR CAMBIOS EN localStorage DESDE OTRAS PESTA√ëAS (para sincronizaci√≥n m√°s r√°pida)
            window.addEventListener('storage', (event) => {
                if(event.key === 'solicitud_times_firebase'){
                    try{
                        console.log('%cüì≤ CAMBIO DE OTRA PESTA√ëA DETECTADO - solicitud_times_firebase:', 'background: #FF9800; color: white;', event.newValue);
                        const timesData = JSON.parse(event.newValue || '{}');
                        window.firebaseTimestampsCache = timesData;
                        setTimeout(() => {
                            try{ 
                                console.log('%c‚è±Ô∏è Actualizando timers por cambio desde otra pesta√±a...', 'background: #FF9800; color: white;');
                                window.updateColumnTimers(); 
                            }catch(e){ 
                                console.error('%c‚ùå ERROR CALLING updateColumnTimers:', 'background: #FF6B6B; color: white;', e); 
                            }
                        }, 0);
                    }catch(e){
                        console.error('%c‚ùå Error en storage event listener:', 'background: #FF6B6B; color: white;', e);
                    }
                }
            });
            
            console.log('‚úÖ LISTENER DE SOLICITUD_TIMES REGISTRADO');
            
            // üîÑ SINCRONIZACI√ìN PERI√ìDICA DESDE FIREBASE (cada 200ms) PARA ASEGURAR QUE TODAS LAS PESTA√ëAS EST√âN SINCRONIZADAS
            console.log('%c‚è±Ô∏è INICIANDO SINCRONIZACI√ìN PERI√ìDICA DESDE FIREBASE...', 'background: #00BCD4; color: white; font-weight: bold;');
            window._syncFromFirebaseInterval = setInterval(() => {
                if(!window.db) return;
                try{
                    window.db.ref('solicitud_times').once('value', (snap) => {
                        const timesData = snap.val() || {};
                        const cacheStr = JSON.stringify(window.firebaseTimestampsCache || {});
                        const firebaseStr = JSON.stringify(timesData);
                        
                        if(cacheStr !== firebaseStr){
                            console.log('%cüîÑ SINCRONIZACI√ìN PERI√ìDICA DETECT√ì CAMBIOS:', 'background: #00BCD4; color: white;', timesData);
                            window.firebaseTimestampsCache = timesData;
                            localStorage.setItem('solicitud_times_firebase', JSON.stringify(timesData));
                            
                            // Actualizar timers inmediatamente
                            try{ 
                                window.updateColumnTimers(); 
                            }catch(e){ 
                                console.error('%c‚ùå ERROR CALLING updateColumnTimers:', 'background: #FF6B6B; color: white;', e); 
                            }
                        }
                    });
                }catch(e){
                    console.error('%c‚ùå Error en sincronizaci√≥n peri√≥dica:', 'background: #FF6B6B; color: white;', e);
                }
            }, 200);
            
            console.log('‚úÖ SINCRONIZACI√ìN PERI√ìDICA INICIADA - Intervalo cada 200ms (m√°s r√°pido)');
            
            // üéØ INICIALIZAR ORDEN DE L√çNEAS SI NO EXISTE
            window.db.ref('line_order').once('value').then((snap) => {
                if(!snap.exists()){
                    console.log('üìù Inicializando orden de l√≠neas desde DOM...');
                    const columns = Array.from(document.querySelectorAll('.container > .column'));
                    const lineNames = columns.map(col => {
                        const header = col.querySelector('.column-header');
                        return header ? header.textContent.trim() : '';
                    }).filter(name => name);
                    
                    if(lineNames.length > 0){
                        window.db.ref('line_order').set(lineNames).then(() => {
                            console.log('‚úÖ ORDEN INICIAL DE L√çNEAS GUARDADO EN FIREBASE:', lineNames);
                        });
                    }
                }else{
                    console.log('‚úÖ Orden de l√≠neas ya existe en Firebase');
                }
            });
            
        } else {
            console.error('‚ùå‚ùå‚ùå window.db NO DISPONIBLE - esperando inicializaci√≥n...');
            // Reintentar despu√©s de que Firebase se inicialice
            if(window.firebaseInitPromise){
                window.firebaseInitPromise.then(() => {
                    console.log('üîÑ Reintentando registro de listener despu√©s de inicializaci√≥n...');
                    if(window.db){
                        window.db.ref('solicitudes').on('value', (snap) => {
                            console.log('üîîüü† EVENTO DE SOLICITUDES (reintento)');
                            // ... mismo c√≥digo de arriba ...
                        });
                        console.log('‚úÖ Listener registrado en reintento');
                    }
                }).catch(e => console.error('Error en reintento:', e));
            }
        }

    });
    </script>
    <!-- Firebase: modo removido eliminado para forzar sincronizaci√≥n en tiempo real -->

    <script>
    // Renderizador de historial: consume objetos devueltos por Firestore
    (function(){
        function safeTxt(s){ return String(s||''); }
        function formatTs(ts){
            if(!ts) return '';
            try{
                if(typeof ts.toDate === 'function') ts = ts.toDate();
                else if(ts && ts.seconds) ts = new Date(ts.seconds * 1000);
                else if(typeof ts === 'number') ts = new Date(ts);
                if(ts instanceof Date) return ts.toLocaleString();
            }catch(e){}
            return String(ts||'');
        }

        function renderRecentHistory(items){
            try{
                const list = document.getElementById('recent-history-list');
                if(!list) return;
                list.innerHTML = '';
                if(!Array.isArray(items) || items.length === 0){
                    // show placeholder when no history entries exist
                    const p = document.createElement('li');
                    p.className = 'empty-history';
                    p.style.opacity = '0.5';
                    p.style.padding = '18px';
                    p.textContent = 'No hay entradas recientes en el historial.';
                    list.appendChild(p);
                    return;
                }
                // take up to 5 most recent
                const arr = items.slice(0,5);
                arr.forEach(it => {
                    const id = it.id || '';
                    const title = it.orderId || it.name || ('#' + (it.index!=null?it.index:''));
                    const action = it.action || (it.suppliedAt || it.suppliedAt===0 ? 'abastecido' : (it.requestedAt ? 'solicitado' : 'registro'));
                    const line = it.line || it.columnId || '';
                    const time = formatTs(it.ts || it.suppliedAt || it.requestedAt || it.createdAt);

                    const li = document.createElement('li');
                    li.dataset.id = id;
                    li.innerHTML = `
                        <div class="order-title">${escapeHtml(title)}</div>
                        <div class="item-row">
                            <div style="flex:1">${escapeHtml(action || '')}${line ? (' ‚Äî ' + escapeHtml(line)) : ''}</div>
                            <div style="font-size:12px;color:#6b7280">${escapeHtml(time)}</div>
                        </div>`;
                    list.appendChild(li);
                });
            }catch(e){ console.error('renderRecentHistory failed', e); }
        }

        // small helper to escape HTML in strings
        function escapeHtml(str){
            return String(str||'').replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m]; });
        }

        // expose globally for listeners
        window.renderRecentHistory = renderRecentHistory;

        // test helper removed (Firebase dependency)

        // if page doesn't include a full historialModule, provide a small fallback implementation
        if(!window.historialModule){
            window.historialModule = {
                setRemoteData(items){ try{ renderRecentHistory(items); }catch(e){ console.warn(e); } },
                renderizar(){ try{ /* nothing ‚Äî remote data will trigger setRemoteData */ }catch(e){} }
            };
        }
    })();
    </script>
    <!-- Barcode / naming modal -->
    <div id="barcode-modal" class="barcode-modal" aria-hidden="true">
        <h3>Abastecer Kamban ‚Äî escanea o escribe nombre</h3>
        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
            <input id="barcode-line-input" type="text" placeholder="L√≠nea (ej. PK1)" style="flex:1;padding:8px;border:1px solid rgba(0,0,0,0.08);border-radius:6px" />
        </div>
        <details id="barcode-lines-list" style="margin-top:8px">
            <summary style="cursor:pointer;font-weight:700">L√≠neas existentes</summary>
            <ul id="barcode-lines-ul" style="list-style:none;padding:6px;margin:6px 0;max-height:160px;overflow:auto"></ul>
        </details>
        <div style="margin-top:8px">Escanea la orden de producci√≥n</div>
        <input id="barcode-input" type="text" style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);margin-top:6px;font-size:16px" placeholder="Escanea la orden de producci√≥n" />
        <div class="scan-list" id="barcode-scan-list"></div>
        <div class="modal-actions">
            <button id="barcode-cancel" class="btn" style="margin-left:auto">Cancelar</button>
        </div>
    </div>
    <!-- debug modal removed per user request -->
    <script>
    // top-info helpers: update current datetime and durations list
    (function(){
        function fmtDateTime(d){
            try{ return d.toLocaleString(); }catch(e){ return (new Date()).toString(); }
        }

        function formatDuration(ms){
            if(ms < 1000) return 'justo ahora';
            let s = Math.floor(ms/1000);
            const days = Math.floor(s/86400); s-= days*86400;
            const hours = Math.floor(s/3600); s-= hours*3600;
            const minutes = Math.floor(s/60); s-= minutes*60;
            const parts = [];
            if(days) parts.push(days + 'd');
            if(hours) parts.push(hours + 'h');
            if(minutes) parts.push(minutes + 'm');
            if(s) parts.push(s + 's');
            return parts.join(' ');
        }

        function updateDateTime(){
            const dtEl = document.getElementById('current-datetime');
            if(dtEl) dtEl.textContent = fmtDateTime(new Date());
        }

        function updateEmptyDurationsDisplay(){
            const listEl = document.getElementById('empty-durations-list');
            if(!listEl) return;
            listEl.innerHTML = '';
            let map = {};
            try{ map = JSON.parse(localStorage.getItem('pk_empty_since')||'{}'); }catch(e){ map = {}; }
            const entries = Object.keys(map).map(k=> ({name:k, since: parseInt(map[k],10)||0}));
            entries.sort((a,b)=> (a.since||0) - (b.since||0));
            entries.forEach(e=>{
                const li = document.createElement('li');
                const dur = e.since ? formatDuration(Date.now() - e.since) : 'desconocido';
                li.textContent = `${e.name} ‚Äî ${dur}`;
                listEl.appendChild(li);
            });
        }

        function updateSolicitudDurationsDisplay(){
            const listEl = document.getElementById('empty-durations-list');
            if(!listEl) return;
            listEl.innerHTML = '';
            let map = {};
            try{ map = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ map = {}; }
            const entries = Object.keys(map)
                .filter(k => map[k] && map[k].solicitud)
                .map(k=> ({ name: k, solicitud: parseInt(map[k].solicitud,10)||0, salida: parseInt((map[k].salida||0),10)||0 }));
            entries.sort((a,b)=> (a.solicitud||0) - (b.solicitud||0));
            // show active requests (no salida) first in red
            const active = entries.filter(x => x.solicitud && !x.salida).sort((a,b)=> (a.solicitud||0) - (b.solicitud||0));
            active.forEach(e => {
                const li = document.createElement('li');
                li.className = 'current';
                const nameSpan = document.createElement('span'); nameSpan.className = 'name'; nameSpan.textContent = e.name;
                const timeSpan = document.createElement('span'); timeSpan.className = 'time'; timeSpan.textContent = e.solicitud ? formatDuration(Date.now() - e.solicitud) : 'justo ahora';
                li.appendChild(nameSpan);
                li.appendChild(timeSpan);
                listEl.appendChild(li);
            });

            // also show recently completed requests (show 0s) for a short grace period so the top card shows stopped time
            const RECENT_MS = 10000; // show completed entries for 10s
            const now = Date.now();
            const recent = entries.filter(x => x.salida && (now - x.salida) <= RECENT_MS).sort((a,b)=> (b.salida||0) - (a.salida||0));
            recent.forEach(e => {
                const li = document.createElement('li');
                li.className = 'stopped';
                const nameSpan = document.createElement('span'); nameSpan.className = 'name'; nameSpan.textContent = e.name;
                const timeSpan = document.createElement('span'); timeSpan.className = 'time';
                const dur = (e.solicitud && e.salida) ? formatDuration((e.salida||0) - e.solicitud) : '0s';
                timeSpan.textContent = dur;
                li.appendChild(nameSpan);
                li.appendChild(timeSpan);
                listEl.appendChild(li);
            });
        }

        // initial update and interval
        updateDateTime(); updateSolicitudDurationsDisplay();
        // nota: renderRecentHistory ahora es manejado por historial.js
        setInterval(()=>{ updateDateTime(); updateSolicitudDurationsDisplay(); }, 1000);

        // make top-info draggable & persistent (same UX as floating-history)
        (function(){
            const el = document.getElementById('top-info');
            if(!el) return;
            const key = 'pk_top_info_pos';
            function apply(){
                try{
                    if(window.matchMedia && window.matchMedia('(max-width:900px)').matches) return;
                    const raw = localStorage.getItem(key);
                    if(!raw) return;
                    const pos = JSON.parse(raw);
                    if(pos && typeof pos.left === 'number' && typeof pos.top === 'number'){
                        el.style.position = 'fixed';
                        el.style.left = Math.max(6, Math.min(window.innerWidth - (el.offsetWidth||170) - 6, pos.left)) + 'px';
                        el.style.top = Math.max(6, Math.min(window.innerHeight - (el.offsetHeight||48) - 6, pos.top)) + 'px';
                        el.style.right = 'auto';
                    }
                }catch(e){ console.warn('apply top-info', e); }
            }
            apply();

            let dragging=false, sx=0, sy=0, sl=0, st=0, pid=null;
            const handle = document.getElementById('top-info-handle');
            const resetBtn = document.getElementById('top-info-reset');
            function within(){ return !(window.matchMedia && window.matchMedia('(max-width:900px)').matches); }
            function onMove(e){ if(!dragging) return; const cx = e.clientX!==undefined?e.clientX:(e.touches&&e.touches[0]&&e.touches[0].clientX); const cy = e.clientY!==undefined?e.clientY:(e.touches&&e.touches[0]&&e.touches[0].clientY); if(cx==null||cy==null) return; let nx = Math.round(sl + (cx - sx)); let ny = Math.round(st + (cy - sy)); const pad=6; const w=el.offsetWidth||170; const h=el.offsetHeight||48; nx=Math.max(pad,Math.min(window.innerWidth-w-pad,nx)); ny=Math.max(pad,Math.min(window.innerHeight-h-pad,ny)); el.style.left = nx+'px'; el.style.top = ny+'px'; }
            function endDrag(e){ if(!dragging) return; dragging=false; el.classList.remove('dragging'); try{ localStorage.setItem(key, JSON.stringify({left: parseInt(el.style.left||0,10), top: parseInt(el.style.top||0,10)})); }catch(err){} document.removeEventListener('pointermove', onMove); document.removeEventListener('pointerup', endDrag); document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', endDrag); try{ if(pid && e.target && e.target.releasePointerCapture) e.target.releasePointerCapture(pid); }catch(e){} pid=null; }
            function startDrag(e){
                if(!within()) return;
                try{
                    const t = e.target || (e.touches && e.touches[0]);
                    const node = t && (t.nodeType ? t : t.target) || e.target;
                    if(node && node.closest){
                        // allow drag if the interaction originates from the drag-handle itself
                        const isHandle = !!node.closest('.drag-handle');
                        const isInteractive = !!node.closest('button, a, input, textarea, select, [role="button"]');
                        if(isInteractive && !isHandle) return; // if it's an interactive element but not the handle, ignore
                    }
                }catch(_){ }

                try{ el.style.zIndex = 9999; }catch(e){}

                e.preventDefault && e.preventDefault();
                dragging = true; el.classList.add('dragging');

                try{
                    // if element wasn't fixed before, convert its current position into fixed coords
                    if(getComputedStyle(el).position !== 'fixed'){
                        const r = el.getBoundingClientRect();
                        el.style.position = 'fixed';
                        el.style.left = (r.left + window.scrollX) + 'px';
                        el.style.top = (r.top + window.scrollY) + 'px';
                        el.style.right = 'auto';
                    }
                }catch(_){ }

                sx = e.clientX!==undefined?e.clientX:(e.touches&&e.touches[0]&&e.touches[0].clientX);
                sy = e.clientY!==undefined?e.clientY:(e.touches&&e.touches[0]&&e.touches[0].clientY);
                sl = parseInt(el.style.left||el.getBoundingClientRect().left||0,10);
                st = parseInt(el.style.top||el.getBoundingClientRect().top||0,10);
                pid = e.pointerId||null;
                try{ if(pid && e.target && e.target.setPointerCapture) e.target.setPointerCapture(pid); }catch(e){}

                document.addEventListener('pointermove', onMove);
                document.addEventListener('pointerup', endDrag);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', endDrag);
            }
            if(handle){
                // prefer Pointer Events, fall back to mouse/touch
                handle.addEventListener('pointerdown', startDrag, { passive: false });
                handle.addEventListener('mousedown', startDrag, { passive: false });
                handle.addEventListener('touchstart', function(e){ e.preventDefault&&e.preventDefault(); startDrag(e); }, { passive:false });
            }
            // also allow grabbing the card itself (but avoid starting drag when clicking on interactive children)
            try{ el.addEventListener('pointerdown', startDrag, { passive:false }); el.addEventListener('mousedown', startDrag, { passive:false }); el.addEventListener('touchstart', function(e){ e.preventDefault&&e.preventDefault(); startDrag(e); }, { passive:false }); }catch(e){}
            if(resetBtn){ resetBtn.addEventListener('click', function(){ try{ localStorage.removeItem(key); el.style.left=''; el.style.top=''; el.style.position=''; el.style.right='18px'; el.style.top='18px'; }catch(e){} }); }
            window.addEventListener('resize', function(){ if(!within()) return; try{ const r = el.getBoundingClientRect(); const pad=6; const w=el.offsetWidth||170; const h=el.offsetHeight||48; let l=r.left, t=r.top; if(l + w > window.innerWidth - pad) l = Math.max(pad, window.innerWidth - w - pad); if(t + h > window.innerHeight - pad) t = Math.max(pad, window.innerHeight - h - pad); el.style.left = l+'px'; el.style.top = t+'px'; }catch(e){} });
        })();

        // expose for other code if needed
        window.updateEmptyDurationsDisplay = updateEmptyDurationsDisplay;
        window.updateSolicitudDurationsDisplay = updateSolicitudDurationsDisplay;

        // ‚úÖ Cargar datos de Firebase e inicializar listeners
        (async () => {
            try {
                console.log('üöÄ Inicializando Firebase despu√©s de DOMContentLoaded...');
                if(window.firebaseInitPromise){
                    await window.firebaseInitPromise;
                    console.log('‚úÖ Firebase inicializado');
                }
                
                // üü† LISTENER DE SOLICITUDES EN TIEMPO REAL (DIRECTO) - REGISTRAR LO M√ÅS PRONTO POSIBLE
                if(window.db) {
                    console.log('üü† Registrando listener de solicitudes DIRECTO...');
                    window.db.ref('solicitudes').on('value', (snap) => {
                        console.log('üîî ¬°¬°¬° EVENTO DE SOLICITUDES RECIBIDO !!!');
                        const firebaseSolicitudes = snap.val() || {};
                        console.log('üì• Solicitudes de Firebase:', firebaseSolicitudes);
                        
                        // üü† ACTUALIZAR VISUALMENTE LOS BLOQUES CON ESTADO "REQUESTED"
                        Object.keys(firebaseSolicitudes || {}).forEach(lineName => {
                            const lineData = firebaseSolicitudes[lineName] || {};
                            const indices = Object.keys(lineData)
                                .filter(key => lineData[key] && lineData[key].requestedAt)
                                .map(key => parseInt(key));
                            
                            console.log(`üü† L√≠nea ${lineName}: √≠ndices solicitados =`, indices);
                            
                            const blocks = Array.from(document.querySelectorAll(`[data-line="${lineName}"].block`));
                            blocks.forEach((block, idx) => {
                                if(indices.includes(idx)) {
                                    block.classList.add('requested');
                                    console.log(`üü† TITILANDO: ${lineName}[${idx}]`);
                                } else {
                                    block.classList.remove('requested');
                                }
                            });
                        });
                        
                        // Limpiar bloques que ya no est√°n solicitados
                        const allBlocks = Array.from(document.querySelectorAll('.block.requested'));
                        allBlocks.forEach(block => {
                            const lineName = block.getAttribute('data-line');
                            const idx = parseInt(block.getAttribute('data-index') || '-1', 10);
                            
                            if(!firebaseSolicitudes[lineName] || !firebaseSolicitudes[lineName][idx]) {
                                block.classList.remove('requested');
                                console.log(`üóëÔ∏è Ya no solicitado: ${lineName}[${idx}]`);
                            }
                        });
                        
                        console.log('‚úÖ Estados de solicitud sincronizados');
                    });
                    console.log('‚úÖ Listener de solicitudes registrado');
                }
                
                // Cargar datos iniciales
                if(typeof loadAllDataFromFirebase === 'function'){
                    await loadAllDataFromFirebase();
                    console.log('‚úÖ Datos cargados desde Firebase');
                }
                
                // üî•üü† REGISTRAR LISTENER DE SOLICITUDES EN TIEMPO REAL (TITILADO)
                console.log('üöÄüöÄüöÄ REGISTRANDO LISTENER DE SOLICITUDES (inline)...');
                if(window.db){
                    console.log('üîó Referencia de solicitudes:', window.db.ref('solicitudes').toString());
                    
                    window.db.ref('solicitudes').on('value', (snap) => {
                        console.log('üîîüü†üîîüü†üîî ¬°¬°¬° EVENTO DE SOLICITUDES RECIBIDO (TITILADO) !!!');
                        const firebaseSolicitudes = snap.val() || {};
                        console.log('üì• Solicitudes de Firebase:', firebaseSolicitudes);
                        
                        try { 
                            localStorage.setItem('json_solicitudes', JSON.stringify(firebaseSolicitudes, null, 2)); 
                        } catch(e) { 
                            console.warn('localStorage no disponible'); 
                        }
                        
                        // Convertir solicitudes de Firebase a pk_requested
                        const pk_requested = {};
                        
                        Object.keys(firebaseSolicitudes).forEach(lineName => {
                            const lineData = firebaseSolicitudes[lineName];
                            if(lineData && typeof lineData === 'object'){
                                pk_requested[lineName] = Object.keys(lineData)
                                    .filter(key => lineData[key] && lineData[key].requestedAt)
                                    .map(key => parseInt(key));
                            }
                        });
                        
                        console.log('üü† pk_requested construido:', pk_requested);
                        
                        try { 
                            localStorage.setItem('pk_requested', JSON.stringify(pk_requested)); 
                        } catch(e) { 
                            console.warn('localStorage no disponible'); 
                        }
                        
                        // üü†üéØ APLICAR TITILADO AL DOM
                        const columns = document.querySelectorAll('.container > .column');
                        columns.forEach(col => {
                            try{
                                const lineName = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                                const blocks = Array.from(col.querySelectorAll('.block'));
                                const requestedIndices = pk_requested[lineName] || [];
                                
                                console.log(`üìã L√≠nea: ${lineName}, Indices solicitados: [${requestedIndices.join(', ')}]`);
                                
                                blocks.forEach((block, idx) => {
                                    if(!block.hasAttribute('data-index')){
                                        block.setAttribute('data-index', String(idx));
                                    }
                                    if(!block.hasAttribute('data-line')){
                                        block.setAttribute('data-line', lineName);
                                    }
                                    
                                    const blockIdx = parseInt(block.getAttribute('data-index') || idx, 10);
                                    
                                    if(requestedIndices.includes(blockIdx)) {
                                        if(!block.classList.contains('requested')){
                                            block.classList.add('requested');
                                            console.log(`‚ú®üü† TITILADO ACTIVADO: ${lineName}[${blockIdx}]`);
                                        }
                                    } else {
                                        if(block.classList.contains('requested')){
                                            block.classList.remove('requested');
                                            console.log(`üîá TITILADO DESACTIVADO: ${lineName}[${blockIdx}]`);
                                        }
                                    }
                                });
                            }catch(e){
                                console.warn('Error procesando columna para titilado:', e);
                            }
                        });
                        
                        console.log('‚úÖ Titilado sincronizado desde Firebase');
                    }, (error) => {
                        console.error('‚ùå ERROR EN LISTENER DE SOLICITUDES:', error);
                    });
                    
                    console.log('‚úÖ‚úÖ LISTENER DE SOLICITUDES REGISTRADO CORRECTAMENTE');
                } else {
                    console.error('‚ùå‚ùå‚ùå window.db NO DISPONIBLE - no se puede registrar listener');
                }
                
                // ‚ö° CARGA INICIAL FORZADA - Esperar 1 segundo para que los listeners se registren
                setTimeout(async () => {
                    console.log('‚ö° Ejecutando carga inicial forzada de Firebase...');
                    try {
                        const snapshot = await window.db.ref('kanban_estado').once('value');
                        const firebaseKanban = snapshot.val() || {};
                        
                        if(Object.keys(firebaseKanban).length > 0) {
                            console.log('üì• Datos encontrados en Firebase:', firebaseKanban);
                            console.log('üîÑ Aplicando snapshot inicial...');
                            if(typeof applyKanbanSnapshot === 'function') {
                                applyKanbanSnapshot(firebaseKanban);
                            }
                        } else {
                            console.log('‚ö†Ô∏è Firebase vac√≠o');
                        }
                    } catch(e) {
                        console.error('‚ùå Error en carga inicial:', e);
                    }
                }, 1000);
                
            } catch(e) {
                console.error('‚ùå Error inicializando Firebase:', e);
            }
        })();
        
        // Bot√≥n de prueba de sincronizaci√≥n eliminado
    });
    </script>

    <!-- Monitor y Historial -->
    <!-- <script src="monitor.js"></script> -->
    <!-- Historial module (gestiona y muestra el historial de √≥rdenes) -->
    <script src="historial.js"></script>
        <script>
            // Funci√≥n para mostrar modal de password con ojito (disponible globalmente)
            function showPasswordModal(title) {
                return new Promise((resolve) => {
                    const overlay = document.createElement('div');
                    overlay.className = 'password-modal-overlay';
                    
                    const modal = document.createElement('div');
                    modal.className = 'password-modal';
                    
                    modal.innerHTML = `
                        <h3>${title}</h3>
                        <div class="password-input-wrapper">
                            <input type="password" id="password-input" placeholder="Ingresa la clave" autocomplete="off">
                            <button type="button" class="password-toggle-eye" id="toggle-password">üëÅÔ∏è</button>
                        </div>
                        <div class="password-modal-buttons">
                            <button class="btn-cancel">Cancelar</button>
                            <button class="btn-accept">Aceptar</button>
                        </div>
                    `;
                    
                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                    
                    const input = modal.querySelector('#password-input');
                    const toggleBtn = modal.querySelector('#toggle-password');
                    const btnCancel = modal.querySelector('.btn-cancel');
                    const btnAccept = modal.querySelector('.btn-accept');
                    
                    // Focus en el input
                    setTimeout(() => input.focus(), 100);
                    
                    // Toggle password visibility
                    toggleBtn.addEventListener('click', () => {
                        if(input.type === 'password'){
                            input.type = 'text';
                            toggleBtn.textContent = 'üôà';
                        } else {
                            input.type = 'password';
                            toggleBtn.textContent = 'üëÅÔ∏è';
                        }
                    });
                    
                    // Aceptar con Enter
                    input.addEventListener('keypress', (e) => {
                        if(e.key === 'Enter') btnAccept.click();
                    });
                    
                    // Cancelar con Escape
                    document.addEventListener('keydown', function escHandler(e) {
                        if(e.key === 'Escape'){
                            document.removeEventListener('keydown', escHandler);
                            overlay.remove();
                            resolve(null);
                        }
                    });
                    
                    btnCancel.addEventListener('click', () => {
                        overlay.remove();
                        resolve(null);
                    });
                    
                    btnAccept.addEventListener('click', () => {
                        const password = input.value;
                        overlay.remove();
                        resolve(password);
                    });
                    
                    overlay.addEventListener('click', (e) => {
                        if(e.target === overlay){
                            overlay.remove();
                            resolve(null);
                        }
                    });
                });
            }
            
            // üö® INDICADOR ESCLUSA LLENA - INNOVADOR
            document.addEventListener('DOMContentLoaded', function(){
                // Forzar recarga de estilos
                const styleTag = document.querySelector('style');
                if(styleTag) {
                    styleTag.textContent = styleTag.textContent;
                }
                
                const indicator = document.getElementById('esclusa-indicator');
                console.log('‚úÖ Indicador encontrado:', indicator);
                if(!indicator) {
                    console.error('‚ùå Indicador no encontrado');
                    return;
                }
                
                let activo = localStorage.getItem('esclusa_llena_estado') === 'true';
                
                function actualizar(){
                    console.log('üìù Actualizando indicador, activo:', activo);
                    if(activo){
                        indicator.classList.add('active');
                        indicator.style.display = 'flex';
                        console.log('‚úÖ Indicador ACTIVADO (visible)');
                    } else {
                        indicator.classList.remove('active');
                        indicator.style.display = 'none';
                        console.log('‚ö™ Indicador DESACTIVADO (oculto)');
                    }
                    localStorage.setItem('esclusa_llena_estado', activo ? 'true' : 'false');
                }
                
                actualizar();
                console.log('üéØ Estado inicial aplicado');
                
                // Click para desactivar
                indicator.addEventListener('click', function(){
                    if(activo){
                        activo = false;
                        actualizar();
                    }
                });
                
                // Funciones globales
                window.toggleEsclusaLlena = function(){
                    activo = !activo;
                    console.log('üîÑ TOGGLE ejecutado, nuevo estado:', activo);
                    actualizar();
                    return activo;
                };
                
                // ATAJO DE TECLADO: Ctrl + I para activar/desactivar
                document.addEventListener('keydown', function(e){
                    if(e.ctrlKey && e.key === 'i'){
                        e.preventDefault();
                        window.toggleEsclusaLlena();
                    }
                });
                
                // Sincronizar con otras ventanas
                window.addEventListener('storage', function(e){
                    if(e.key === 'esclusa_llena_estado'){
                        activo = e.newValue === 'true';
                        actualizar();
                    }
                });
            });
            
            // Mostrar panel de control interno en vez de abrir nueva pesta√±a
            document.addEventListener('DOMContentLoaded', function(){
                const btn = document.getElementById('btn-panel-control');
                if(btn){
                    btn.addEventListener('click', async (ev)=>{
                        ev.preventDefault && ev.preventDefault();
                        
                        // Ask for password con modal personalizado (mismo que anular solicitud)
                        const password = await showPasswordModal('Ingresa la clave para acceder al panel de control:');
                        if(password === null) return; // user cancelled
                        
                        const correctPassword = localStorage.getItem('pk_admin_password_anular') || 'Almacen2025*';
                        if(password !== correctPassword){
                            alert('‚ùå Clave incorrecta. Acceso denegado.');
                            return;
                        }
                        
                        // Password correct, proceed with panel
                        const panel = document.getElementById('panel-control-interno');
                        if(panel){
                            panel.style.display = 'block';
                            document.body.style.overflow = 'hidden';
                            // Guardar estado para persistir despu√©s de refresh
                            sessionStorage.setItem('panelControlOpen', 'true');
                            // render content
                            if(typeof renderPanelContent === 'function') renderPanelContent();
                        } else {
                            // fallback: open existing page if internal panel not present
                            window.open('panel_control.html','_blank');
                        }
                    });
                }
            });
        </script>
    <!-- INDICADOR ESCLUSA LLENA - TITILANTE -->
    <div id="esclusa-indicator" title="Click para desactivar" style="
        position: fixed !important;
        top: 20px !important;
        right: 20px !important;
        z-index: 10000 !important;
        display: none !important;
        align-items: center !important;
        gap: 15px !important;
        padding: 18px 32px !important;
        background: linear-gradient(135deg, #ff0000 0%, #b91c1c 50%, #7f1d1d 100%) !important;
        border-radius: 16px !important;
        cursor: pointer !important;
        animation: flash-ultra 1s ease-in-out infinite !important;
        border: 3px solid #fff !important;
        box-shadow: 0 0 30px rgba(255,0,0,0.8), 0 0 60px rgba(255,0,0,0.5), 0 10px 40px rgba(0,0,0,0.5) !important;
        backdrop-filter: blur(10px) !important;
    ">
        <span style="font-size: 32px; animation: rotate-pulse 1.5s ease-in-out infinite; filter: drop-shadow(0 0 10px rgba(255,255,255,0.8));">üö®</span>
        <div class="esclusa-text" style="
            color: #ffffff !important;
            font-size: 24px !important;
            font-weight: 900 !important;
            letter-spacing: 3px !important;
            text-transform: uppercase !important;
            text-shadow: -4px -4px 0 #000, 4px -4px 0 #000, -4px 4px 0 #000, 4px 4px 0 #000, -4px 0 0 #000, 4px 0 0 #000, 0 -4px 0 #000, 0 4px 0 #000, 0 8px 16px rgba(0,0,0,1), 0 0 30px rgba(255,255,0,0.8) !important;
            filter: drop-shadow(0 0 15px rgba(255,255,255,0.9)) !important;
        ">ESCLUSA LLENA</div>
    </div>
    
    <!-- LAYOUT: Botones arriba, b√∫squeda/gestionar abajo-izq, l√≠neas derecha -->
    <div class="main-container">
        <!-- Fila superior: BOTONES -->
        <div class="top-controls">
            <button id="btn-entrada" class="color-box blue" type="button" aria-label="Abastecer Kamban">ABASTECER<br>KAMBAN</button>
            <button id="btn-salida" class="color-box green" type="button" aria-label="Abastecer AB">ABASTECER<br>AB</button>
            <button id="btn-anular-solicitud" class="color-box red" type="button" aria-label="Anular solicitud" style="background:linear-gradient(90deg,#ff6b6b,#ff5252);color:white;">ANULAR<br>SOLICITUD</button>
            <button id="btn-solicitar" class="color-box orange" type="button" aria-label="Solicitar parciales">SOLICITAR<br>PARCIALES</button>
            <button id="btn-panel-control" class="color-box purple" type="button" aria-label="Panel de control" style="background:linear-gradient(90deg,#7c3aed,#6d28d9);color:white;">PANEL<br>DE CONTROL</button>
            
            <!-- top-info compacta: fecha y resumen de tiempos (una l√≠nea) -->
            <div id="top-info" class="top-info top-info-compact" aria-live="polite" style="display:none !important;visibility:hidden">
                <div style="display:flex;align-items:center;gap:8px;justify-content:space-between;width:100%">
                    <div style="display:flex;align-items:center;gap:8px">
                        <button id="top-info-handle" class="drag-handle" aria-label="Mover info" title="Mover" type="button">‚â°</button>
                        <div id="current-datetime" class="now">--</div>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px">
                        <button id="top-info-reset" class="history-reset" title="Resetear posici√≥n" aria-label="Resetear posici√≥n">‚§æ</button>
                    </div>
                    <div id="auth-controls" style="display:flex;align-items:center;gap:8px;margin-left:12px">
                        <div id="user-info" style="font-size:12px;color:#222;min-width:140px;text-align:right"></div>
                        <button id="btn-signin-google" class="btn" type="button" style="padding:6px 8px;font-size:12px">Entrar con Google</button>
                        <button id="btn-signout" class="btn" type="button" style="padding:6px 8px;font-size:12px;display:none">Cerrar sesi√≥n</button>
                    </div>
                    </div>
                </div>
                <div class="durations">
                    <!-- Panel de tiempos oculto por solicitud del usuario -->
                    <div style="display:none !important">Gestion (S‚ÜíS):</div>
                    <ul id="empty-durations-list" style="display:none !important"></ul>
                </div>
            </div>
        </div>
        <!-- Contenedor inferior: b√∫squeda izq, l√≠neas der -->
        <div class="bottom-container">
            <!-- Panel izquierdo: b√∫squeda y gestionar -->
            <div class="controls">
                <!-- 'NOMBRE DE LA L√çNEA' y buscador removidos por petici√≥n del usuario. -->
                <!-- Mantener un input oculto con id 'line-name' para compatibilidad con el JS existente. -->
                <input id="line-name" type="text" value="" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;border:0;padding:0;margin:0" aria-hidden="true" />
                <div id="control-status" class="status" aria-live="polite" style="font-size:11px;color:#333;display:none"></div>
                <!-- moved info panel (fecha y duraciones) -->
                        <!-- top-info movido a la tarjeta flotante para agrupar historial y duraciones -->
                <!-- Historial y buscador se han movido a la tarjeta flotante (floating-history) para mejor colocaci√≥n visual -->
            </div>
            <!-- Panel izquierdo: l√≠neas y parciales -->
            <div class="right-panel">
                <div class="container">
        <div class="column">
            <div class="column-header">PKB1</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB2</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB3</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB4</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB5</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB6</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">JVH2</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">EYS</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">MAQ</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // attach manage button behavior (runs after controls exist)
        (function(){
            const btn = document.getElementById('manage-lines-btn');
            const panel = document.getElementById('manage-panel');
            const closeBtn = document.getElementById('m-btn-close');
            if(!btn || !panel) return;
            
            // üîê FLAG PARA CONTROLAR SI SE PUEDE CERRAR
            window.managePanelSynced = false;
            
            function openPanel(){ 
                panel.classList.add('open'); 
                panel.setAttribute('aria-hidden','false');
                window.managePanelSynced = false; // Reset al abrir
                closeBtn.style.opacity = '0.5';
                closeBtn.style.cursor = 'not-allowed';
                closeBtn.title = 'Debes hacer clic en "Sincronizar" antes de cerrar';
            }
            function closePanel(){ 
                // üîê VALIDAR SI EST√Å SINCRONIZADO
                if(!window.managePanelSynced){
                    alert('‚ö†Ô∏è Debes hacer clic en "Sincronizar" antes de cerrar');
                    return;
                }
                panel.classList.remove('open'); 
                panel.setAttribute('aria-hidden','true');
            }
            btn.addEventListener('click', ()=>{ openPanel(); });
            closeBtn && closeBtn.addEventListener('click', closePanel);
            // close on Escape
            window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape' && window.managePanelSynced) closePanel(); });
        })();
    </script>

    <script>
    // buscador de √≥rdenes: filtra y resalta bloques que contienen el texto buscado
    (function(){
        const input = document.getElementById('order-search');
        const clearBtn = document.getElementById('order-search-clear');
        if(!input) return;

        function normalize(s){ return String(s||'').trim().toLowerCase(); }

        function applyFilter(){
            const q = normalize(input.value);
            const historyItems = Array.from(document.querySelectorAll('#recent-history-list li'));
            let firstHistMatch = null;
            if(!q){
                historyItems.forEach(li => li.classList.remove('history-dim','history-match'));
                return;
            }
            // search history list only
            historyItems.forEach(li =>{
                const text = normalize(li.textContent || li.innerText || '');
                if(text.indexOf(q) !== -1){
                    li.classList.add('history-match');
                    li.classList.remove('history-dim');
                    if(!firstHistMatch) firstHistMatch = li;
                } else {
                    li.classList.add('history-dim');
                    li.classList.remove('history-match');
                }
            });
            // scroll first history match into view
            if(firstHistMatch){
                try{ firstHistMatch.scrollIntoView({ behavior: 'smooth', block: 'center' }); }catch(e){}
            }
        }

        input.addEventListener('input', applyFilter);
        input.addEventListener('search', applyFilter);
        clearBtn && clearBtn.addEventListener('click', ()=>{ input.value=''; input.focus(); applyFilter(); });

        // expose for debugging
        window.pkFilterOrders = applyFilter;

        // attach export buttons (if module exists later, they'll call it)
        function attachExportButtons(){
            const btnCsv = document.getElementById('export-history-csv');
            const btnJson = document.getElementById('export-history-json');
            const btnJsonStorage = document.getElementById('export-json-btn');
            if(btnCsv){ btnCsv.addEventListener('click', ()=>{ if(window.historialModule && window.historialModule.exportCSV) window.historialModule.exportCSV(); else alert('M√≥dulo historial no disponible a√∫n. Intenta de nuevo.'); }); }
            if(btnJson){ btnJson.addEventListener('click', ()=>{ if(window.historialModule && window.historialModule.exportar) window.historialModule.exportar(); else alert('M√≥dulo historial no disponible a√∫n. Intenta de nuevo.'); }); }
            if(btnJsonStorage){
                btnJsonStorage.addEventListener('click', ()=>{
                    if(window.JSONStorage){
                        window.JSONStorage.saveAll();
                        alert('‚úÖ Datos guardados. Descargando archivos JSON...');
                        setTimeout(()=>{ window.JSONStorage.downloadAllJSONs(); }, 500);
                    } else {
                        alert('Sistema JSON no disponible. Recarga la p√°gina.');
                    }
                });
            }
        }
        // intentar conectar inmediatamente y tambi√©n tras carga completa
        attachExportButtons();
        window.addEventListener('DOMContentLoaded', attachExportButtons);
    })();
    // navegaci√≥n por el historial: mostrar solo una entrada y permitir avanzar/retroceder
    (function(){
        const list = document.getElementById('recent-history-list');
        const prev = document.getElementById('recent-prev');
        const next = document.getElementById('recent-next');
        if(!list) return;

        // hacer la lista enfocables para accesibilidad
        try{ list.tabIndex = 0; }catch(e){}

        function getStep(){
            // navegar exactamente por la altura del contenedor (una tarjeta completa)
            return list.clientHeight || 170;
        }

        function stepScroll(dir){
            const step = getStep();
            list.scrollBy({ top: dir * step, behavior: 'smooth' });
        }

        prev && prev.addEventListener('click', ()=> stepScroll(-1));
        next && next.addEventListener('click', ()=> stepScroll(1));

        // teclas cuando la lista tiene foco
        list.addEventListener('keydown', (e)=>{
            if(e.key === 'ArrowDown'){ e.preventDefault(); stepScroll(1); }
            if(e.key === 'ArrowUp'){ e.preventDefault(); stepScroll(-1); }
        });

        // mostrar/ocultar controles si hay 0 o 1 items
        const nav = document.querySelector('#recent-history .recent-nav');
        function adjustNavVisibility(){
            const items = Array.from(list.querySelectorAll('li'));
            if(!nav) return;
            // Deshabilitado: navegaci√≥n solo con mouse (scroll)
            nav.style.display = 'none'; 
        }

        const obs = new MutationObserver(adjustNavVisibility);
        obs.observe(list, { childList: true, subtree: false });
        // run once now in case items are already present
        adjustNavVisibility();
    })();

    // Posicionar el panel de historial de forma segura para evitar solapamientos
    (function(){
        const history = document.getElementById('floating-history');
        if(!history) return;

        function positionHistory(){
            // en pantallas peque√±as dejamos la posici√≥n est√°tica (CSS media query ya maneja esto)
            if(window.matchMedia && window.matchMedia('(max-width:900px)').matches){
                history.style.position = '';
                history.style.left = '';
                history.style.top = '';
                history.style.right = '';
                return;
            }

            const topControls = document.querySelector('.top-controls');
            const actions = document.getElementById('floating-actions');

            let left = 18 + window.scrollX;
            // si hay acciones flotantes a la izquierda, colocamos el historial a su derecha
            if(actions){
                try{ left = Math.round(actions.getBoundingClientRect().right) + 12 + window.scrollX; }catch(e){}
            }

            // if the history panel has been explicitly locked to a fixed position, avoid repositioning it
            try{
                if(history && history.dataset && history.dataset.fixed === 'true') return;
            }catch(e){}

            // colocamos el historial justo debajo de la fila superior (top-controls)
            let top = 18 + window.scrollY;
            if(topControls){
                try{ top = Math.round(topControls.getBoundingClientRect().bottom) + 10 + window.scrollY; }catch(e){}
            }

            // asegurar que no salga del viewport por la derecha
            const w = Math.min(history.offsetWidth || 300, 360);
            if(left + w > window.innerWidth - 18){ left = Math.max(18, window.innerWidth - w - 18); }

            history.style.position = 'fixed';
            history.style.left = left + 'px';
            history.style.top = top + 'px';
            history.style.right = 'auto';
            history.style.zIndex = 115;
        }

        // recalcular en eventos clave
        window.addEventListener('resize', positionHistory);
        window.addEventListener('scroll', positionHistory);
        window.addEventListener('DOMContentLoaded', positionHistory);
        // run once now
        setTimeout(positionHistory, 40);

        // --- floating-history behavior: can be draggable/persisted OR fixed ---
        (function(){
            // toggle this to true if later you want the history panel draggable again
            const FLOATING_HISTORY_DRAGGABLE = false;
            // If you want this panel locked to an exact viewport position, set fixed coords here
            // (left, top) in pixels. Set to null to let positionHistory compute a place automatically.
            // positioned between ABASTECER KAMBAN and ABASTECER AB buttons
            const FLOATING_HISTORY_FIXED_POS = { left: 320, top: 70 };
            const key = 'pk_floating_history_pos';
               const el = document.getElementById('floating-history');
            if(!el) return;

            // apply persisted position if present and screen is wide enough
            function applySaved(){
                try{
                    if(window.matchMedia && window.matchMedia('(max-width:900px)').matches) return; // ignore mobile
                    const raw = localStorage.getItem(key);
                    if(!raw) return;
                    const pos = JSON.parse(raw);
                    if(pos && typeof pos.left === 'number' && typeof pos.top === 'number'){
                        el.style.position = 'fixed';
                        el.style.left = Math.max(8, Math.min(window.innerWidth - (el.offsetWidth||300) - 8, pos.left)) + 'px';
                        el.style.top = Math.max(8, Math.min(window.innerHeight - (el.offsetHeight||150) - 8, pos.top)) + 'px';
                        el.style.right = 'auto';
                    }
                }catch(e){ console.warn('applySaved pos failed', e); }
            }
            // if we're using draggable mode apply previously saved position, otherwise keep fixed layout
            if(FLOATING_HISTORY_DRAGGABLE){
                // initial apply on load
                applySaved();
            } else {
                // clear any previously stored position so old values don't move the panel
                try{ localStorage.removeItem(key); }catch(e){}
                // if a fixed position was requested, apply it exactly; otherwise use the default placement
                try{
                    if(FLOATING_HISTORY_FIXED_POS && typeof FLOATING_HISTORY_FIXED_POS.left === 'number'){
                        el.style.position = 'fixed';
                        el.style.left = Math.max(8, Math.min(window.innerWidth - (el.offsetWidth||300) - 8, FLOATING_HISTORY_FIXED_POS.left)) + 'px';
                        el.style.top = Math.max(8, Math.min(window.innerHeight - (el.offsetHeight||150) - 8, FLOATING_HISTORY_FIXED_POS.top)) + 'px';
                        el.style.right = 'auto';
                        el.style.zIndex = 115;
                        // mark as fixed so positionHistory won't move it later
                        try{ el.dataset.fixed = 'true'; }catch(e){}
                    } else { positionHistory(); }
                }catch(e){ positionHistory(); }
            }

            let dragging = false; let startX=0, startY=0, startLeft=0, startTop=0, pointerId=null;

            const handle = el.querySelector('.drag-handle');
            const resetBtn = document.getElementById('floating-history-reset');

            function withinDesktop(){ return !(window.matchMedia && window.matchMedia('(max-width:900px)').matches); }

            function onPointerMove(e){
                if(!dragging) return;
                const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
                const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
                if(clientX == null || clientY == null) return;
                let nx = Math.round(startLeft + (clientX - startX));
                let ny = Math.round(startTop + (clientY - startY));
                // constrain to viewport with small padding
                const pad = 8;
                const w = el.offsetWidth || 300;
                const h = el.offsetHeight || 150;
                nx = Math.max(pad, Math.min(window.innerWidth - w - pad, nx));
                ny = Math.max(pad, Math.min(window.innerHeight - h - pad, ny));
                el.style.left = nx + 'px';
                el.style.top = ny + 'px';
            }

            function onPointerUp(e){
                if(!dragging) return;
                dragging = false;
                el.classList.remove('dragging');
                // persist
                try{
                    const l = parseInt(el.style.left||0,10); const t = parseInt(el.style.top||0,10);
                    localStorage.setItem(key, JSON.stringify({ left: l, top: t }));
                }catch(err){ console.warn('save pos failed', err); }
                // cleanup
                document.removeEventListener('pointermove', onPointerMove);
                document.removeEventListener('pointerup', onPointerUp);
                document.removeEventListener('touchmove', onPointerMove);
                document.removeEventListener('touchend', onPointerUp);
                pointerId = null;
            }

            function startDrag(e){
                if(!withinDesktop()) return;
                e.preventDefault && e.preventDefault();
                dragging = true; el.classList.add('dragging');
                startX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
                startY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
                startLeft = parseInt(el.style.left||el.getBoundingClientRect().left||0,10);
                startTop = parseInt(el.style.top||el.getBoundingClientRect().top||0,10);
                // capture pointer
                pointerId = e.pointerId || null;
                try{ if(pointerId && e.target && e.target.setPointerCapture) e.target.setPointerCapture(pointerId); }catch(e){}

                document.addEventListener('pointermove', onPointerMove);
                document.addEventListener('pointerup', onPointerUp);
                document.addEventListener('touchmove', onPointerMove, { passive: false });
                document.addEventListener('touchend', onPointerUp);
            }

            // only wire drag handlers when draggable allowed
            if(FLOATING_HISTORY_DRAGGABLE && handle){
                handle.addEventListener('pointerdown', startDrag);
                handle.addEventListener('touchstart', function(e){ e.preventDefault && e.preventDefault(); startDrag(e); }, { passive:false });
            }

            // if not draggable, hide/reset button to avoid confusion
            if(resetBtn){
                if(FLOATING_HISTORY_DRAGGABLE){
                    resetBtn.addEventListener('click', function(){ try{ localStorage.removeItem(key); positionHistory(); applySaved(); }catch(e){ } });
                } else {
                    // visually disable/reset button when history is fixed
                    try{ resetBtn.style.opacity = '0.5'; resetBtn.title = 'Panel fijo ‚Äî reset deshabilitado'; }catch(e){}
                }
            }

            // if resized or scrolled keep position sane
            window.addEventListener('resize', ()=>{ if(!withinDesktop()) return; // keep current pos
                // ensure still inside viewport
                try{ const rect = el.getBoundingClientRect(); const pad=8; const w=el.offsetWidth||300; const h=el.offsetHeight||150; let l = rect.left; let t = rect.top; if(l + w > window.innerWidth - pad) l = Math.max(pad, window.innerWidth - w - pad); if(t + h > window.innerHeight - pad) t = Math.max(pad, window.innerHeight - h - pad); el.style.left = l + 'px'; el.style.top = t + 'px'; }catch(e){}
            });
        })();
    })();
    </script>

    <!-- Gesti√≥n: l√≥gica embebida que reemplaza manage-lines.html -->
    <script>
    // üîÑ FUNCI√ìN GLOBAL PARA SINCRONIZAR L√çNEAS CON FIREBASE
    window.syncLinesToFirebase = function(lines){
        console.log('%cüì§ [syncLinesToFirebase] GUARDANDO EN FIREBASE...', 'background: #FF9800; color: white; font-weight: bold; padding: 8px;', lines);
        
        if(!window.db) {
            console.warn('‚ùå window.db no disponible para sincronizar');
            return;
        }
        
        // Guardar estructura: nombres y estado activo
        const lineStructure = lines.map(l => ({
            name: l.name,
            active: l.active !== false
        }));
        
        window.db.ref('line_structure').set(lineStructure).then(() => {
            console.log('‚úÖ ESTRUCTURA DE L√çNEAS SINCRONIZADA EN FIREBASE:', lineStructure);
        }).catch(err => {
            console.error('‚ùå Error sincronizando estructura:', err);
        });
        
        // Guardar orden de l√≠neas - CR√çTICO
        const lineNames = lines.map(l => l.name);
        console.log('%cüîÑ GUARDANDO ORDEN EN FIREBASE:', 'background: purple; color: white; font-weight: bold;', lineNames);
        
        // Guardar con timestamp para forzar que el listener se dispare
        const orderData = {
            lines: lineNames,
            timestamp: Date.now()
        };
        
        window.db.ref('line_order').set(orderData).then(() => {
            console.log('%c‚úÖ ORDEN DE L√çNEAS GUARDADO EN FIREBASE:', 'background: green; color: white; font-weight: bold;', lineNames);
        }).catch(err => {
            console.error('‚ùå Error guardando orden:', err);
        });
    };

    (function(){
        const STORAGE_KEY = 'pk_lines';
        const listEl = document.getElementById('m-lines-list');
        const btnAdd = document.getElementById('m-btn-add');
        const btnSave = document.getElementById('m-btn-save');
    const btnReset = null;
        const openMain = document.getElementById('open-main');

        function defaultLines(){
            const out = [];
            for(let i=1;i<=10;i++) out.push({ name: 'PK'+i, count: 0 });
            return out;
        }

        function load(){
            try{
                const raw = localStorage.getItem(STORAGE_KEY);
                if(raw){
                    const parsed = JSON.parse(raw);
                    if(Array.isArray(parsed)) return parsed;
                }
                // no stored state: try to infer from current DOM so the manage panel reflects actual parciales
                try{
                    const cols = Array.from(document.querySelectorAll('.container > .column'));
                    if(cols.length > 0){
                        return cols.map(c=>({ name: (c.querySelector('.column-header')||{textContent:''}).textContent.trim(), count: c.querySelectorAll('.block').length }));
                    }
                }catch(e){/* ignore DOM read errors */}
            }catch(e){ console.error(e) }
            return defaultLines();
        }

        function save(lines){
            try{
                localStorage.setItem(STORAGE_KEY, JSON.stringify(lines));
                // üîÑ GUARDAR NOMBRES Y ESTRUCTURA EN FIREBASE
                syncLinesToFirebase(lines);
                return true;
            }catch(e){ console.error(e); return false; }
        }

        function render(){
            const lines = load();
            listEl.innerHTML = '';
            lines.forEach((l,idx)=>{
                const row = document.createElement('div'); 
                row.className = 'manage-item';
                row.draggable = true; // üéØ HACER DRAGGABLE
                row.dataset.index = idx; // guardar √≠ndice para reordenar
                row.style.cursor = 'grab';
                
                // üé® Event handlers para drag & drop
                row.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', idx);
                    row.style.opacity = '0.4';
                    row.style.cursor = 'grabbing';
                });
                
                row.addEventListener('dragend', (e) => {
                    row.style.opacity = '1';
                    row.style.cursor = 'grab';
                });
                
                row.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    // highlight drop zone
                    row.style.borderTop = '2px solid #4CAF50';
                });
                
                row.addEventListener('dragleave', (e) => {
                    row.style.borderTop = '';
                });
                
                row.addEventListener('drop', (e) => {
                    e.preventDefault();
                    row.style.borderTop = '';
                    
                    const draggedIdx = parseInt(e.dataTransfer.getData('text/plain'), 10);
                    const targetIdx = parseInt(row.dataset.index, 10);
                    
                    if(draggedIdx !== targetIdx){
                        // reordenar array
                        const lines = load();
                        const [movedItem] = lines.splice(draggedIdx, 1);
                        lines.splice(targetIdx, 0, movedItem);
                        save(lines); // ‚úÖ Auto-guarda en Firebase al reordenar
                        render();
                        
                        window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY}));
                        console.log('‚úÖ L√çNEAS REORDENADAS Y AUTO-GUARDADAS EN FIREBASE');
                    }
                });
                
                const name = document.createElement('input'); name.type='text'; name.value = l.name;
                // mostrar la cantidad como texto (no editable)
                const countSpan = document.createElement('div'); countSpan.style.minWidth = '48px'; countSpan.style.padding = '8px'; countSpan.style.borderRadius = '8px'; countSpan.style.background = 'rgba(0,0,0,0.03)'; countSpan.style.textAlign = 'center'; countSpan.textContent = String(l.count || 0);
                const chkActive = document.createElement('input');
                chkActive.type = 'checkbox';
                chkActive.checked = (l.active !== false);
                chkActive.title = 'L√≠nea activa';
                chkActive.style.width = '18px';
                chkActive.style.height = '18px';
                chkActive.style.cursor = 'pointer';
                const del = document.createElement('button'); del.className='btn btn-del'; del.textContent='Eliminar';
                del.addEventListener('click', ()=>{ 
                    const deletedName = lines[idx].name;
                    lines.splice(idx,1); 
                    save(lines); // ‚úÖ Auto-guarda en Firebase al eliminar
                    render(); 
                    window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY}));
                    console.log(`‚úÖ L√çNEA ELIMINADA Y AUTO-GUARDADA: ${deletedName}`);
                });
                // update on change - SINCRONIZAR NOMBRE EN TIEMPO REAL
                name.addEventListener('change', ()=>{ 
                    const oldName = lines[idx].name;
                    const newName = name.value.trim() || ('PK'+(idx+1));
                    
                    if(oldName !== newName){
                        lines[idx].name = newName;
                        save(lines); // ‚úÖ Auto-guarda en Firebase al cambiar nombre
                        
                        // üîÑ SINCRONIZAR RENOMBRADO EN kanban_estado
                        if(window.db){
                            window.db.ref('kanban_estado').once('value', (snapshot) => {
                                const kanbanData = snapshot.val() || {};
                                
                                // Si existe la l√≠nea vieja en kanban_estado, renombrarla
                                if(kanbanData[oldName]){
                                    kanbanData[newName] = kanbanData[oldName];
                                    delete kanbanData[oldName];
                                    
                                    // Guardar el cambio
                                    window.db.ref('kanban_estado').set(kanbanData).then(() => {
                                        console.log(`‚úÖ L√çNEA RENOMBRADA EN KANBAN_ESTADO: ${oldName} ‚Üí ${newName}`);
                                    }).catch(err => {
                                        console.error(`‚ùå Error renombrando en kanban_estado:`, err);
                                    });
                                }
                            });
                        }
                        
                        // Renombrar columna en DOM
                        try{
                            const col = document.querySelector(`[data-line="${oldName}"]`)?.closest('.column');
                            if(col){
                                const header = col.querySelector('.column-header');
                                if(header) header.textContent = newName;
                                col.setAttribute('data-line', newName);
                            }
                        }catch(e){}
                        
                        render();
                        window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY}));
                        console.log(`‚úÖ L√çNEA RENOMBRADA Y AUTO-GUARDADA: ${oldName} ‚Üí ${newName}`);
                    }
                });
                // count is not editable from the manage UI per user request
                chkActive.addEventListener('change', ()=>{
                    lines[idx].active = !!chkActive.checked;
                    save(lines); // ‚úÖ Auto-guarda en Firebase al cambiar estado
                    render();
                    try{ if(window.applyLinesToDOM) window.applyLinesToDOM(lines); }catch(e){}
                    // if deactivating, remove timestamp
                    if(!lines[idx].active){
                        try{
                            const mapRaw = localStorage.getItem('pk_empty_since');
                            const map = mapRaw ? JSON.parse(mapRaw) : {};
                            if(map[lines[idx].name]){ delete map[lines[idx].name]; localStorage.setItem('pk_empty_since', JSON.stringify(map)); }
                        }catch(e){}
                    }
                    window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY}));
                    console.log(`‚úÖ ESTADO DE L√çNEA ACTUALIZADO Y AUTO-GUARDADO: ${lines[idx].name} = ${lines[idx].active}`);
                });
                row.appendChild(name); row.appendChild(countSpan); row.appendChild(chkActive); row.appendChild(del);
                listEl.appendChild(row);
            });
        }

        btnAdd && btnAdd.addEventListener('click', ()=>{
            const nameInput = document.getElementById('m-new-name');
            const name = (nameInput.value || '').trim();
            const defaultCount = 0; // fixed default now 0 per user request
            if(!name){ nameInput.focus(); return; }
            if(!confirm(`¬øA√±adir nueva l√≠nea "${name}"?`)) return;
            const lines = load();
            lines.push({ name, count: defaultCount });
            save(lines); // ‚úÖ Auto-guarda en Firebase
            nameInput.value = '';
            render();
            // notify other tabs via storage event
            window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY}));
            console.log('‚úÖ NUEVA L√çNEA A√ëADIDA Y AUTO-GUARDADA');
        });
        
        // üîÑ LISTENER PARA SINCRONIZAR CAMBIOS DE pk_lines ENTRE PESTA√ëAS
        window.addEventListener('storage', (e) => {
            if(e.key === STORAGE_KEY){
                console.log('üìù CAMBIO EN pk_lines DETECTADO, RE-RENDERIZANDO PANEL...');
                render(); // Re-renderizar el panel de gesti√≥n
            }
        });

        // manejar bot√≥n "Solicitar parcial"
        (function(){
            const solicitar = document.getElementById('btn-solicitar');
            if(!solicitar) return;
            solicitar.addEventListener('click', ()=>{
                const selected = Array.from(document.querySelectorAll('.block.selected-parcial'));
                if(selected.length === 0){
                    try{ status.textContent = 'Selecciona primero un parcial para solicitar.'; }catch(e){}
                    return;
                }
                
                // üî• VERIFICAR QUE TODOS LOS SELECCIONADOS SEAN DE L√çNEAS DIFERENTES
                const linesMap = {};
                const reqMap = getRequestedMap();
                
                for(const s of selected){
                    const lineName = (s.getAttribute('data-line') || ((s.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent||'').trim();
                    
                    // ‚ùå Si ya hay una solicitud en esta l√≠nea, avisar
                    if(reqMap[lineName] && reqMap[lineName].length > 0){
                        alert(`‚ö†Ô∏è La l√≠nea "${lineName}" ya tiene un parcial solicitado.\nSolo se puede solicitar 1 parcial por l√≠nea a la vez.`);
                        try{ status.textContent = `Error: ${lineName} ya tiene solicitud pendiente.`; }catch(e){}
                        return;
                    }
                    
                    // ‚ùå Si ya seleccionaron otro de esta l√≠nea, avisar
                    if(linesMap[lineName]){
                        alert(`‚ö†Ô∏è No puedes solicitar m√∫ltiples parciales de la misma l√≠nea "${lineName}".\nSolo se permite 1 parcial por l√≠nea.`);
                        try{ status.textContent = 'Error: Solo 1 parcial por l√≠nea.'; }catch(e){}
                        return;
                    }
                    
                    linesMap[lineName] = true;
                }
                
                if(!confirm(`¬øSolicitar ${selected.length} parcial(es)?`)) return;
                // ensure data attributes are present
                try{ ensureBlockDataAttributes(); }catch(e){}

                let added = 0, removed = 0;
                // load or create solicitud map once
                let solicitudMap = {};
                try{ solicitudMap = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ solicitudMap = {}; }

                selected.forEach(s => {
                    try{
                        let lineName = s.getAttribute('data-line') || ((s.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent;
                        lineName = (lineName||'').trim();
                        const idx = parseInt(s.getAttribute('data-index')||'-1',10);
                        const blockText = (s.textContent || s.innerText || '').trim(); // get the order number
                        if(!lineName || !Number.isFinite(idx)){
                            // toggle visual only
                            if(s.classList.contains('requested')){ s.classList.remove('requested'); removed++; }
                            else { s.classList.add('requested'); added++; }
                            s.classList.remove('selected-parcial');
                            return;
                        }

                        // normalize key to avoid whitespace/case mismatches
                        const key = lineName;
                        const arr = Array.isArray(reqMap[key]) ? reqMap[key].slice() : [];
                        const pos = arr.indexOf(idx);
                        if(s.classList.contains('requested') || pos !== -1){
                            // remove request
                            s.classList.remove('requested');
                            if(pos !== -1) arr.splice(pos,1);
                            removed++;
                            
                            // üóëÔ∏è ELIMINAR DE FIREBASE CUANDO SE CANCELA
                            (async () => {
                                try{
                                    if(window.db){
                                        const solicitudRef = window.db.ref(`solicitudes/${lineName}/${idx}`);
                                        await solicitudRef.remove();
                                        console.log(`üóëÔ∏è SOLICITUD ELIMINADA DE FIREBASE: ${lineName}[${idx}]`);
                                        
                                        // üü£ ELIMINAR TIMESTAMP DE SOLICITUD_TIMES
                                        await window.db.ref(`solicitud_times/${lineName}`).remove();
                                        console.log(`‚è±Ô∏è TIMESTAMP DE SOLICITUD ELIMINADO: ${lineName}`);
                                        
                                        // üî• Limpiar cache local INMEDIATAMENTE
                                        if(window.firebaseTimestampsCache) {
                                            delete window.firebaseTimestampsCache[lineName];
                                        }
                                        
                                        // üî• FORZAR ACTUALIZACI√ìN EN TODAS LAS VENTANAS
                                        localStorage.setItem('solicitud_times_firebase', JSON.stringify(window.firebaseTimestampsCache || {}));
                                        
                                        // Disparar evento de storage para sincronizar otras pesta√±as
                                        window.dispatchEvent(new StorageEvent('storage', {
                                            key: 'solicitud_times_firebase',
                                            newValue: JSON.stringify(window.firebaseTimestampsCache || {})
                                        }));
                                        
                                        console.log(`‚úÖ localStorage ACTUALIZADO (CANCELADO): ${lineName}`);
                                        
                                        // Actualizar timers en esta ventana
                                        setTimeout(() => {
                                            try{ window.updateColumnTimers(); }catch(e){}
                                        }, 50);
                                    }
                                }catch(e){ console.warn('Error eliminando solicitud de Firebase:', e); }
                            })();
                        } else {
                            // add request
                            s.classList.add('requested');
                            if(pos === -1) arr.push(idx);
                            added++;
                            // set solicitud timestamp for this line (overwrite to now)
                            solicitudMap[key] = solicitudMap[key] || {};
                            solicitudMap[key].solicitud = Date.now();
                            delete solicitudMap[key].salida; // clear salida while new request open
                            try{ console.log('saved solicitud for', key, solicitudMap[key].solicitud); }catch(e){}
                            
                            // üîÑ GUARDAR EN FIREBASE EN TIEMPO REAL
                            (async () => {
                                try{
                                    if(window.db){
                                        const now = Date.now();
                                        const solicitudRef = window.db.ref(`solicitudes/${lineName}/${idx}`);
                                        await solicitudRef.set({
                                            parcial: blockText,
                                            requestedAt: now,
                                            timestamp: new Date().toISOString()
                                        });
                                        console.log(`üü† SOLICITUD GUARDADA EN FIREBASE: ${lineName}[${idx}]`);
                                        
                                        // üü£ GUARDAR TIMESTAMP EN solicitud_times PARA SINCRONIZACI√ìN EN TIEMPO REAL
                                        await window.db.ref(`solicitud_times/${lineName}`).set(now);
                                        console.log(`‚è±Ô∏è TIMESTAMP DE SOLICITUD GUARDADO EN FIREBASE: ${lineName} = ${now}`);
                                        
                                        // üî• ACTUALIZAR CACHE GLOBAL INMEDIATAMENTE (para esta pesta√±a)
                                        window.firebaseTimestampsCache = window.firebaseTimestampsCache || {};
                                        window.firebaseTimestampsCache[lineName] = now;
                                        console.log(`‚úÖ CACHE ACTUALIZADO LOCALMENTE: ${lineName} = ${now}`, window.firebaseTimestampsCache);
                                        
                                        // üî• FORZAR ACTUALIZACI√ìN EN TODAS LAS VENTANAS
                                        localStorage.setItem('solicitud_times_firebase', JSON.stringify(window.firebaseTimestampsCache));
                                        
                                        // Disparar evento de storage para sincronizar otras pesta√±as
                                        window.dispatchEvent(new StorageEvent('storage', {
                                            key: 'solicitud_times_firebase',
                                            newValue: JSON.stringify(window.firebaseTimestampsCache)
                                        }));
                                        
                                        // Actualizar timers en esta pesta√±a INMEDIATAMENTE
                                        setTimeout(() => {
                                            try{ window.updateColumnTimers(); }catch(e){}
                                        }, 50);
                                    }
                                }catch(e){ console.warn('Error guardando solicitud en Firebase:', e); }
                            })();
                        }

                        if(arr.length > 0) reqMap[key] = Array.from(new Set(arr)).sort((a,b)=>a-b); else delete reqMap[key];
                        s.classList.remove('selected-parcial');
                    }catch(err){ console.error('solicitar loop error', err); }
                });

                // persist both maps
                try{ saveRequestedMap(reqMap); localStorage.setItem('pk_solicitud_salida', JSON.stringify(solicitudMap)); try{ console.log('saved pk_requested for', Object.keys(reqMap)); }catch(e){} }catch(e){ console.error('failed to save request maps', e); }

                // refresh timers immediately after toggling requests
                try{ ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); }catch(e){ console.error('timer refresh failed', e); }

                // status message
                try{
                    if(added > 0 && removed === 0) status.textContent = `${added} parcial(es) solicitados.`;
                    else if(removed > 0 && added === 0) status.textContent = `${removed} solicitud(es) cancelada(s).`;
                    else status.textContent = `${added} solicitados, ${removed} cancelados.`;
                }catch(e){ }
            });
        })();

        // Funci√≥n para mostrar modal de password con ojito
        function showPasswordModal(title) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'password-modal-overlay';
                
                const modal = document.createElement('div');
                modal.className = 'password-modal';
                
                modal.innerHTML = `
                    <h3>${title}</h3>
                    <div class="password-input-wrapper">
                        <input type="password" id="password-input" placeholder="Ingresa la clave" autocomplete="off">
                        <button type="button" class="password-toggle-eye" id="toggle-password">üëÅÔ∏è</button>
                    </div>
                    <div class="password-modal-buttons">
                        <button class="btn-cancel">Cancelar</button>
                        <button class="btn-accept">Aceptar</button>
                    </div>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                const input = modal.querySelector('#password-input');
                const toggleBtn = modal.querySelector('#toggle-password');
                const btnCancel = modal.querySelector('.btn-cancel');
                const btnAccept = modal.querySelector('.btn-accept');
                
                // Focus en el input
                setTimeout(() => input.focus(), 100);
                
                // Toggle password visibility
                toggleBtn.addEventListener('click', () => {
                    if(input.type === 'password'){
                        input.type = 'text';
                        toggleBtn.textContent = 'üôà';
                    } else {
                        input.type = 'password';
                        toggleBtn.textContent = 'üëÅÔ∏è';
                    }
                });
                
                // Aceptar con Enter
                input.addEventListener('keypress', (e) => {
                    if(e.key === 'Enter') btnAccept.click();
                });
                
                // Cancelar con Escape
                document.addEventListener('keydown', function escHandler(e) {
                    if(e.key === 'Escape'){
                        document.removeEventListener('keydown', escHandler);
                        overlay.remove();
                        resolve(null);
                    }
                });
                
                btnCancel.addEventListener('click', () => {
                    overlay.remove();
                    resolve(null);
                });
                
                btnAccept.addEventListener('click', () => {
                    const password = input.value;
                    overlay.remove();
                    resolve(password);
                });
                
                overlay.addEventListener('click', (e) => {
                    if(e.target === overlay){
                        overlay.remove();
                        resolve(null);
                    }
                });
            });
        }
        
        // manejar bot√≥n "Anular solicitud"
        (function(){
            const btnAnular = document.getElementById('btn-anular-solicitud');
            if(!btnAnular) return;
            btnAnular.addEventListener('click', async ()=>{
                // üéØ SOLO ANULAR LOS PARCIALES SELECCIONADOS, NO TODOS LOS SOLICITADOS
                const selected = Array.from(document.querySelectorAll('.block.selected-parcial'));
                if(selected.length === 0){
                    try{ status.textContent = 'Selecciona primero uno o m√°s parciales para anular.'; }catch(e){}
                    return;
                }
                
                // Ask for password con modal personalizado
                const password = await showPasswordModal('Ingresa la clave para anular solicitud:');
                if(password === null) return; // user cancelled
                
                const correctPassword = localStorage.getItem('pk_admin_password_anular') || 'Almacen2025*';
                if(password !== correctPassword){
                    alert('‚ùå Clave incorrecta. La anulaci√≥n no ha sido realizada.');
                    return;
                }
                
                if(!confirm(`¬øAnular ${selected.length} solicitud(es) seleccionada(s)?`)) return;
                
                // Password correct, proceed with cancellation
                try{ ensureBlockDataAttributes(); }catch(e){}
                
                let canceled = 0;
                const reqMap = getRequestedMap();
                let solicitudMap = {};
                try{ solicitudMap = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ solicitudMap = {}; }
                
                selected.forEach(s => {
                    try{
                        let lineName = s.getAttribute('data-line') || ((s.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent;
                        lineName = (lineName||'').trim();
                        const idx = parseInt(s.getAttribute('data-index')||'-1',10);
                        const blockText = (s.textContent || s.innerText || '').trim(); // get the order number
                        if(!lineName || !Number.isFinite(idx)) return;
                        
                        const key = lineName;
                        const arr = Array.isArray(reqMap[key]) ? reqMap[key].slice() : [];
                        const pos = arr.indexOf(idx);
                        
                        // üü† ELIMINAR DE FIREBASE INMEDIATAMENTE (sincronizaci√≥n en tiempo real)
                        (async () => {
                            try{
                                if(window.db){
                                    const solicitudRef = window.db.ref(`solicitudes/${lineName}/${idx}`);
                                    await solicitudRef.remove();
                                    console.log(`üóëÔ∏è SOLICITUD ANULADA EN FIREBASE: ${lineName}[${idx}]`);
                                    
                                    // üîç VERIFICAR SI QUEDAN M√ÅS SOLICITUDES DE ESTA L√çNEA
                                    const remainingSolicitudes = await window.db.ref(`solicitudes/${lineName}`).once('value');
                                    const solicitudesData = remainingSolicitudes.val() || {};
                                    const hasMoreSolicitudes = Object.keys(solicitudesData).length > 0;
                                    
                                    if(!hasMoreSolicitudes){
                                        // üî• ELIMINAR TIMESTAMP DE SOLICITUD_TIMES SOLO SI NO HAY M√ÅS SOLICITUDES
                                        await window.db.ref(`solicitud_times/${lineName}`).remove();
                                        console.log(`‚è±Ô∏è Timer detenido en Firebase (no hay m√°s solicitudes): ${lineName}`);
                                        
                                        // Limpiar cache local
                                        if(window.firebaseTimestampsCache) delete window.firebaseTimestampsCache[lineName];
                                    } else {
                                        console.log(`‚è±Ô∏è Timer sigue corriendo (quedan ${Object.keys(solicitudesData).length} solicitudes): ${lineName}`);
                                    }
                                }
                            }catch(e){ console.warn('Error eliminando solicitud de Firebase:', e); }
                        })();
                        
                        // Remove from requested
                        s.classList.remove('requested');
                        s.classList.remove('selected-parcial');
                        if(pos !== -1) arr.splice(pos, 1);
                        canceled++;
                        
                        // Update maps
                        if(arr.length > 0) reqMap[key] = Array.from(new Set(arr)).sort((a,b)=>a-b);
                        else delete reqMap[key];
                        
                        // Clear solicitud timestamp if no more requested items for this line
                        if(arr.length === 0){
                            delete solicitudMap[key];
                        }
                        
                        // NUEVO: Agregar inmediatamente a anulaciones.json
                        try{
                            const now = new Date();
                            const newAnulacion = {
                                linea: lineName,
                                orden_produccion: blockText,
                                fecha_anulacion: now.toLocaleDateString('es-ES'),
                                hora_anulacion: now.toLocaleTimeString('es-ES'),
                                timestamp: now.toISOString()
                            };
                            
                            // Guardar en Firebase
                            try{
                                if(window.FirebaseSync){
                                    window.FirebaseSync.addAnulacion(lineName, blockText).catch(e=>console.warn('Error en anulaci√≥n Firebase:', e));
                                }
                            }catch(e){ console.warn('Error registrando anulaci√≥n:', e); }
                        }catch(e){ console.warn('Error registrando anulaci√≥n:', e); }
                    }catch(err){ console.error('anular loop error', err); }
                });
                
                // Persist changes
                try{ saveRequestedMap(reqMap); localStorage.setItem('pk_solicitud_salida', JSON.stringify(solicitudMap)); }catch(e){ console.error('failed to save anular changes', e); }
                
                // Refresh timers and UI
                try{ ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); }catch(e){ console.error('timer refresh failed', e); }
                
                // Status message
                try{
                    status.style.display = 'block';
                    status.textContent = `‚úÖ ${canceled} solicitud(es) anulada(s) correctamente.`;
                    setTimeout(()=>{ status.textContent = ''; status.style.display = 'none'; }, 3000);
                }catch(e){}
            });
        })();

        // manejar bot√≥n "Abastecer AB" (procesa parciales solicitados y los registra en abastecimientos.json)
        (function(){
            const btnSalida = document.getElementById('btn-salida');
            if(!btnSalida) return;
            btnSalida.addEventListener('click', async ()=>{
                const requested = Array.from(document.querySelectorAll('.block.requested'));
                if(requested.length === 0){
                    try{ status.textContent = 'No hay parciales solicitados para abastecer.'; }catch(e){}
                    return;
                }
                if(!confirm(`¬øAbastecer ${requested.length} parcial(es) en AB?`)) return;

                // procesar cada solicitud: enviar a servidor y remover del DOM
                for(const s of requested){
                    try{
                        try{ ensureBlockDataAttributes(); }catch(e){}
                        let lineName = s.getAttribute('data-line') || ((s.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent;
                        lineName = (lineName||'').trim();
                        const idx = parseInt(s.getAttribute('data-index')||'-1',10);
                        const blockText = (s.textContent || s.innerText || '').trim();
                        if(!lineName || !blockText) continue;

                        // enviar al Firebase
                        if(window.FirebaseSync){
                            await window.FirebaseSync.addAbastecimiento(lineName, blockText).catch(e=>console.warn('Error en abastecimiento Firebase:', e));
                        }

                        // üóëÔ∏è ELIMINAR DE SOLICITUDES EN FIREBASE (ya fue abastecido)
                        console.log(`%cüîç DEBUG ABASTECER: lineName="${lineName}", idx=${idx}, isFinite=${Number.isFinite(idx)}`, 'background: #9C27B0; color: white;');
                        
                        if(window.db && Number.isFinite(idx)){
                            try{
                                await window.db.ref(`solicitudes/${lineName}/${idx}`).remove();
                                console.log(`üóëÔ∏è Solicitud eliminada de Firebase (abastecido): ${lineName}[${idx}]`);
                                
                                // üîç VERIFICAR SI QUEDAN M√ÅS SOLICITUDES DE ESTA L√çNEA
                                const remainingSolicitudes = await window.db.ref(`solicitudes/${lineName}`).once('value');
                                const solicitudesData = remainingSolicitudes.val() || {};
                                const remainingKeys = Object.keys(solicitudesData);
                                const hasMoreSolicitudes = remainingKeys.length > 0;
                                
                                console.log(`%cüîç VERIFICANDO SOLICITUDES RESTANTES DE ${lineName}:`, 'background: #2196F3; color: white; font-weight: bold;', {
                                    solicitudesData,
                                    remainingKeys,
                                    hasMoreSolicitudes
                                });
                                
                                if(!hasMoreSolicitudes){
                                    // üî• ELIMINAR TIMESTAMP DE SOLICITUD_TIMES SOLO SI NO HAY M√ÅS SOLICITUDES
                                    await window.db.ref(`solicitud_times/${lineName}`).remove();
                                    console.log(`%c‚è±Ô∏è TIMER DETENIDO EN FIREBASE (no hay m√°s solicitudes): ${lineName}`, 'background: #4CAF50; color: white; font-weight: bold;');
                                    
                                    // Limpiar cache local
                                    if(window.firebaseTimestampsCache) delete window.firebaseTimestampsCache[lineName];
                                    
                                    // Forzar actualizaci√≥n de timers
                                    setTimeout(() => {
                                        try{ window.updateColumnTimers(); }catch(e){}
                                    }, 100);
                                } else {
                                    console.log(`%c‚è±Ô∏è TIMER SIGUE CORRIENDO (quedan ${remainingKeys.length} solicitudes): ${lineName}`, 'background: #FF9800; color: white; font-weight: bold;', remainingKeys);
                                }
                            }catch(e){ console.warn('Error eliminando solicitud:', e); }
                        }

                        // visual: eliminar bloque (animaci√≥n)
                        s.classList.remove('requested');
                        s.classList.add('removing');
                        setTimeout(()=>{ try{ s.remove(); }catch(e){} }, 260);
                    }catch(e){ console.error('Error procesando abastecimiento', e); }
                }

                // actualizar estado de kanban en Firebase
                try{
                    const state = (window.DataSync && window.DataSync.getCurrentKanbanState) ? window.DataSync.getCurrentKanbanState() : {};
                    if(window.FirebaseSync){
                        window.FirebaseSync.updateKanbanState(state).catch(()=>{});
                    }
                }catch(e){}

                // refrescar timers y UI
                try{ ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); }catch(e){}
                try{ status.textContent = `‚úÖ ${requested.length} parcial(es) abastecido(s).`; setTimeout(()=>status.textContent='',3000); }catch(e){}
                
                // üîÑ Recargar la p√°gina despu√©s de 1 segundo (como si se presionara F5)
                setTimeout(() => {
                    console.log('üîÑ Recargando p√°gina (como F5)...');
                    location.reload(false);
                }, 1000);
           
            });
        })();

        btnSave && btnSave.addEventListener('click', ()=>{
            const lines = load();
            const ok = save(lines);
            if(ok){
                // apply immediately to main UI in same tab
                try{ if(window.applyLinesToDOM) window.applyLinesToDOM(lines); }catch(e){}
                // Mostrar confirmaci√≥n r√°pida (ya todo se guarda autom√°ticamente)
                const status = document.createElement('div');
                status.textContent = '‚úÖ Cambios sincronizados';
                status.style.position = 'fixed';
                status.style.top = '20px';
                status.style.right = '20px';
                status.style.background = '#4CAF50';
                status.style.color = 'white';
                status.style.padding = '12px 16px';
                status.style.borderRadius = '6px';
                status.style.zIndex = '10000';
                document.body.appendChild(status);
                setTimeout(()=>status.remove(), 2000);
                
                // üîì PERMITIR CERRAR DESPU√âS DE SINCRONIZAR
                window.managePanelSynced = true;
                const closeBtn = document.getElementById('m-btn-close');
                if(closeBtn){
                    closeBtn.style.opacity = '1';
                    closeBtn.style.cursor = 'pointer';
                    closeBtn.title = 'Cerrar';
                }
                
                console.log('‚úÖ Cambios sincronizados con Firebase');
            } else {
                const status = document.createElement('div');
                status.textContent = '‚ùå Error al sincronizar';
                status.style.position = 'fixed';
                status.style.top = '20px';
                status.style.right = '20px';
                status.style.background = '#e74c3c';
                status.style.color = 'white';
                status.style.padding = '12px 16px';
                status.style.borderRadius = '6px';
                status.style.zIndex = '10000';
                document.body.appendChild(status);
                setTimeout(()=>status.remove(), 2000);
            }
        });

        // reset button removed per user request

        // initial
        render();
    })();

    // Ocultar completamente el elemento top-info
    (function(){
        const topInfo = document.getElementById('top-info');
        if(topInfo) {
            topInfo.style.display = 'none !important';
            topInfo.style.visibility = 'hidden';
            topInfo.style.position = 'absolute';
            topInfo.style.left = '-9999px';
            topInfo.style.top = '-9999px';
        }
    })();
    </script>

    <!-- Sistema de almacenamiento JSON sin servidor (solo localStorage + descarga manual) -->
    <script>
    (function(){
        // Sistema completo de sincronizaci√≥n sin necesidad de servidor Node.js
        const DataSync = {
            // Obtener estado actual del kanban desde el DOM
            getCurrentKanbanState() {
                const state = {};
                const blockNamesMap = JSON.parse(localStorage.getItem('pk_block_names')||'{}');
                const cols = document.querySelectorAll('.container .column');
                cols.forEach(col => {
                    const header = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    if(header){
                        const blocks = [];
                        col.querySelectorAll('.block').forEach((b, idx) => {
                            // Prioridad: data-name -> pk_block_names -> label -> fallback
                            let name = b.getAttribute('data-name');
                            if(!name && blockNamesMap[header]) name = blockNamesMap[header][String(idx)];
                            if(!name){
                                const labelEl = b.querySelector('.label');
                                name = labelEl ? labelEl.textContent.trim() : '';
                            }
                            if(!name) name = (b.textContent || b.innerText || '').trim();
                            if(!name) name = `Parcial ${idx+1}`;
                            blocks.push(name);
                        });
                        state[header] = blocks;
                    }
                });
                return state;
            },

            // Obtener solicitudes desde historial
            getCurrentSolicitudes() {
                const solicitudes = [];
                let history = [];
                try { history = JSON.parse(localStorage.getItem('pk_history')||'[]'); } catch(e){}
                
                const solicitudMap = {};
                history.forEach(entry => {
                    if(entry && entry.line && entry.requestedAt){
                        if(!solicitudMap[entry.name]){
                            solicitudMap[entry.name] = {
                                linea: entry.line,
                                nombre: entry.name,
                                requestedAt: entry.requestedAt
                            };
                        }
                    }
                });
                
                Object.values(solicitudMap).forEach(item => {
                    if(item.requestedAt){
                        const date = new Date(parseInt(item.requestedAt, 10));
                        solicitudes.push({
                            linea: item.linea,
                            orden_produccion: item.nombre,
                            fecha_solicitud: date.toLocaleDateString('es-ES'),
                            hora_solicitud: date.toLocaleTimeString('es-ES'),
                            timestamp: date.toISOString()
                        });
                    }
                });
                return solicitudes;
            },

            // Obtener abastecimientos desde historial
            getCurrentAbastecimientos() {
                const abastecimientos = [];
                let history = [];
                try { history = JSON.parse(localStorage.getItem('pk_history')||'[]'); } catch(e){}
                
                history.forEach(entry => {
                    if(entry && entry.suppliedAt && entry.line && entry.name){
                        const date = new Date(parseInt(entry.suppliedAt, 10));
                        abastecimientos.push({
                            linea: entry.line,
                            orden_produccion: entry.name,
                            fecha_abastecimiento: date.toLocaleDateString('es-ES'),
                            hora_abastecimiento: date.toLocaleTimeString('es-ES'),
                            timestamp: date.toISOString()
                        });
                    }
                });
                return abastecimientos;
            },

            // Guardar datos en localStorage + Firebase (sincronizaci√≥n autom√°tica)
            syncAll() {
                try {
                    const kanban = this.getCurrentKanbanState();
                    const solicitudes = this.getCurrentSolicitudes();
                    const abastecimientos = this.getCurrentAbastecimientos();
                    const anulaciones = [];
                    
                    console.log('üì§ Enviando a Firebase - Kanban:', kanban, 'Solicitudes:', solicitudes);
                    
                    // Guardar en localStorage
                    localStorage.setItem('json_kanban_state', JSON.stringify(kanban, null, 2));
                    localStorage.setItem('json_solicitudes', JSON.stringify(solicitudes, null, 2));
                    localStorage.setItem('json_abastecimientos', JSON.stringify(abastecimientos, null, 2));
                    localStorage.setItem('json_anulaciones', JSON.stringify(anulaciones, null, 2));
                    
                    // Guardar en Firebase AHORA (sin esperar callbacks)
                    if(window.db){
                        window.db.ref('kanban_estado').set(kanban, (error) => {
                            if(error) {
                                console.error('‚ùå Error guardando kanban en Firebase:', error);
                            } else {
                                console.log('‚úÖ Kanban guardado en Firebase:', kanban);
                            }
                        });
                        
                        window.db.ref('solicitudes').set(solicitudes, (error) => {
                            if(error) {
                                console.error('‚ùå Error guardando solicitudes en Firebase:', error);
                            } else {
                                console.log('‚úÖ Solicitudes guardadas en Firebase');
                            }
                        });
                        
                        window.db.ref('abastecimientos').set(abastecimientos, (error) => {
                            if(error) {
                                console.error('‚ùå Error guardando abastecimientos en Firebase:', error);
                            } else {
                                console.log('‚úÖ Abastecimientos guardados en Firebase');
                            }
                        });
                    } else {
                        console.warn('‚ö† Firebase no disponible. Solo localStorage.');
                    }
                    
                    console.log('‚úÖ Datos sincronizados en localStorage y Firebase');
                } catch(e) {
                    console.error('‚ùå Error sincronizando:', e);
                }
            },

            // Descargar un JSON como archivo
            downloadJSON(key, filename) {
                try {
                    const data = localStorage.getItem(key);
                    if(!data){
                        alert(`‚ùå No hay datos para: ${filename}`);
                        return;
                    }
                    const blob = new Blob([data], { type: 'application/json; charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    console.log(`‚úÖ Descargando: ${filename}`);
                } catch(e) {
                    console.error('‚ùå Error descargando:', e);
                }
            },

            // Descargar todos los JSONs
            downloadAllJSONs() {
                console.log('üì• Iniciando descarga de archivos JSON...');
                this.downloadJSON('json_kanban_state', 'kanban_estado.json');
                setTimeout(()=>this.downloadJSON('json_solicitudes', 'solicitudes.json'), 300);
                setTimeout(()=>this.downloadJSON('json_abastecimientos', 'abastecimientos.json'), 600);
                setTimeout(()=>this.downloadJSON('json_anulaciones', 'anulaciones.json'), 900);
            }
        };

        // Exponer globalmente
        window.DataSync = DataSync;

        // Sincronizar cada 5 segundos a Firebase (no localStorage)
        try{
            // Flags para evitar que un cliente sin cambios sobrescriba Firebase
            window._pendingLocalSync = false;
            window._lastLocalChange = 0;
            window._lastFirebaseApply = 0;

            // Marcar cambio local
            const markLocalChange = () => {
                window._pendingLocalSync = true;
                window._lastLocalChange = Date.now();
            };

            // Send data to Firebase √∫nicamente si hubo cambios locales
            const sendToFirebase = () => {
                try{
                    if(window._isUpdatingFromFirebase) return; // no enviar mientras se aplica remoto
                    if(!window._pendingLocalSync) return; // nada que enviar
                    // Enviar s√≥lo el estado del kanban cuando hay cambios locales
                    try{
                        const state = DataSync.getCurrentKanbanState();
                        if(window.FirebaseSync){
                            window.FirebaseSync.updateKanbanState(state).catch(()=>{});
                            window._pendingLocalSync = false;
                            window._lastFirebaseApply = Date.now();
                        }
                    }catch(e){ console.warn('Error enviando kanban state a Firebase', e); }
                }catch(e){ console.warn('Error sending to Firebase:', e); }
            };

            // DESACTIVAMOS autosync peri√≥dico y por mutaci√≥n para evitar sobrescrituras desde clientes vac√≠os.
            // Solo se sincroniza cuando se ejecutan acciones expl√≠citas (addPartial/removePartial/abastecer/solicitar).

            console.log('‚úÖ Sistema de sincronizaci√≥n listo (sync solo en acciones, sin autosync cada 5s)');
        }catch(e){ console.error('Error configuring autosync', e); }
    })();
    </script>

    <!-- Limpieza segura al iniciar: elimina bloques est√°ticos si no hay datos persistentes -->
    <script>
    (function(){
        try{
            const requiredKeys = ['json_kanban_state','pk_lines','pk_history'];
            const hasData = requiredKeys.some(k=>{
                const v = localStorage.getItem(k);
                if(!v) return false;
                try{
                    const s = v.toString().trim();
                    if(s === '' || s === '{}' || s === '[]') return false;
                }catch(e){ }
                return true;
            });

            if(!hasData){
                const blocks = document.querySelectorAll('.block');
                if(blocks.length > 0){
                    console.warn('Startup cleanup: removing', blocks.length, 'static .block elements because no persisted data found.');
                    blocks.forEach(b=>b.remove());
                    try{ if(window.applyLinesToDOM) window.applyLinesToDOM([]); }catch(e){}

                    // Tambi√©n eliminar claves residuales que pueden causar repoblado
                    ['pk_lines','pk_block_names','pk_requested','pk_solicitud_salida','pk_empty_since','json_kanban_state','json_solicitudes','json_abastecimientos','json_anulaciones'].forEach(k=>localStorage.removeItem(k));
                    console.log('Startup cleanup completed.');
                }
            }
        }catch(e){ console.error('Startup cleanup failed', e); }
    })();
    </script>
        <!-- Panel de Control Interno (oculto por defecto) -->
        <div id="panel-control-interno" style="display:none; position:fixed; inset:0; background:#ffffff; z-index:9999;">
            <style id="panel-styles">
                #panel-control-interno { font-family: Inter, system-ui, Arial, sans-serif; }
                #panel-control-interno .panel-shell { width:100%; height:100vh; margin:0; background: linear-gradient(180deg,#fbfdff,#ffffff); border-radius:0; padding:28px 32px; box-shadow:none; position:relative; display:flex; flex-direction:column; }
                #panel-control-interno h2 { font-size:28px; color:#4b2991; margin:6px 0 18px 0; font-weight:800; }
                #panel-control-interno .panel-actions { display:flex; gap:14px; justify-content:center; margin:8px 0 18px 0; flex-wrap:wrap; }
                #panel-control-interno .panel-actions button { padding:12px 20px; font-size:16px; border-radius:10px; box-shadow:0 8px 20px rgba(12,20,30,0.06); border:0; color:white; font-weight:700; cursor:pointer; transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease; }
                #panel-control-interno .panel-actions button:hover { transform: translateY(-3px); box-shadow:0 18px 36px rgba(12,20,30,0.12); }
                #btn-cerrar-panel { position:absolute; left:14px; top:14px; background:#fff; border:1px solid #e6e6e9; padding:8px 12px; border-radius:8px; color:#333; }
                #panel-export-excel { background:linear-gradient(90deg,#f59e0b,#f97316); }
                #panel-sync-firebase { background:linear-gradient(90deg,#3b82f6,#0ea5e9); }
                #panel-refresh-db { background:#6b7280; }
                #panel-reset-firebase { background:#ef4444; }
                #panel-change-pass { background:#10b981; }
                #panel-control-interno .change-pass-row { display:flex; gap:10px; align-items:center; justify-content:center; margin-bottom:12px; }
                #panel-control-interno input#panel-new-pass { padding:10px; border-radius:8px; border:1px solid #e5e7eb; font-size:15px; min-width:180px; }
                #panel-control-interno #panel-content { margin-top:10px; flex:1; overflow:auto; }
                #panel-control-interno #panel-historial-list { 
                    max-height:680px; 
                    overflow:auto; 
                    background:linear-gradient(180deg,#ffffff,#fbfbff); 
                    padding:14px; 
                    border-radius:10px; 
                    border:1px solid #f0f0f5;
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                    gap: 12px;
                }
                #panel-control-interno #panel-historial-list .hist-item { 
                    padding:14px; 
                    border:none;
                    border-radius:10px;
                    font-size:13px; 
                    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
                    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
                    transition: all 200ms ease;
                }
                #panel-control-interno #panel-historial-list .hist-item:hover {
                    transform: translateY(-4px);
                    box-shadow: 0 8px 24px rgba(79,70,229,0.15);
                }
                #panel-control-interno #panel-historial-list .hist-item strong { font-size:14px; color:#111827; }
            </style>
            <div class="panel-shell">
                <button id="btn-cerrar-panel">Volver</button>
                <h2 style="text-align:center;">Panel de Control</h2>
                <div class="panel-actions">
                    <button id="panel-export-excel">Exportar Excel</button>
                    <button id="panel-reset-firebase">Reiniciar Firebase</button>
                </div>
                <div class="change-pass-row">
                    <label for="panel-new-pass" style="font-weight:700;">Cambiar clave Anular:</label>
                    <input id="panel-new-pass" type="password" placeholder="Nueva clave" />
                    <button id="panel-change-pass">Cambiar</button>
                </div>
                <div id="panel-content">
                    <h3 style="margin-left:8px;">Historial (√∫ltimos 20)</h3>
                    <div id="panel-historial-list"></div>
                </div>
            </div>
        </div>
    </body>
<!-- Removed duplicate closing html tag -->
    <!-- SheetJS Library for Excel generation con estilos -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
    <script>
    // Funciones utilitarias para exportar datos - EXCEL con formato HTML
    async function exportAllData(){
        try{
            const result = {};
            const paths = ['anulaciones','historial'];
            
            // Cargar datos desde localStorage o Firebase
            if(window.db){
                for(const p of paths){
                    try{
                        const snap = await window.db.ref(p).once('value');
                        result[p] = snap.val() || {};
                    }catch(e){ console.warn('Error leyendo',p,e); result[p] = {}; }
                }
            } else {
                try{ result.anulaciones = JSON.parse(localStorage.getItem('json_anulaciones')||'{}'); }catch(e){ result.anulaciones = {}; }
                try{ result.historial = (window.historialModule && window.historialModule.obtenerHistorial && window.historialModule.obtenerHistorial()) || {}; }catch(e){ result.historial = {}; }
            }

            // Funci√≥n para generar tabla HTML con estilos
            function generateStyledTable(data, headers, title) {
                let html = `
                <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; width: 100%; font-family: Arial;">
                    <thead>
                        <tr style="background-color: #4F46E5; color: white; font-size: 14px; font-weight: bold; height: 35px;">`;
                
                headers.forEach(h => {
                    html += `<th style="border: 2px solid black; text-align: center; padding: 8px;">${h}</th>`;
                });
                
                html += `</tr></thead><tbody>`;
                
                data.forEach((row, idx) => {
                    const bgColor = idx % 2 === 0 ? '#F8F9FA' : '#FFFFFF';
                    html += `<tr style="background-color: ${bgColor};">`;
                    headers.forEach(h => {
                        html += `<td style="border: 1px solid black; text-align: center; padding: 6px; font-size: 11px;">${row[h] || ''}</td>`;
                    });
                    html += `</tr>`;
                });
                
                html += `</tbody></table>`;
                return html;
            }
            
            // Funci√≥n para convertir timestamp a fecha y hora legibles
            function formatTimestamp(ts) {
                if(!ts) return { fecha: '', hora: '' };
                const date = new Date(ts);
                const fecha = date.toLocaleDateString('es-ES');
                const hora = date.toLocaleTimeString('es-ES');
                return { fecha, hora };
            }
            
            // Preparar datos de Historial
            const historial = result.historial || {};
            const histArray = Array.isArray(historial) ? historial : Object.entries(historial).map(([id,v])=>({id,...v}));
            const histData = histArray.map(h => {
                const tsSol = formatTimestamp(h.requestedAt);
                const tsAbast = formatTimestamp(h.suppliedAt);
                const durMs = h.duration || 0;
                const durMin = Math.floor(durMs / 60000);
                const durSec = Math.floor((durMs % 60000) / 1000);
                const durText = durMin > 0 ? `${durMin}m ${durSec}s` : `${durSec}s`;
                
                return {
                    'Parcial': h.name || h.parcial || '',
                    'L√≠nea': h.line || h.linea || '',
                    'Fecha Solicitud': tsSol.fecha,
                    'Hora Solicitud': tsSol.hora,
                    'Fecha Abastecimiento': tsAbast.fecha,
                    'Hora Abastecimiento': tsAbast.hora,
                    'Duraci√≥n': durText
                };
            });
            
            // Preparar datos de Anulaciones
            const anulaciones = result.anulaciones || {};
            const anulArray = Array.isArray(anulaciones) ? anulaciones : Object.entries(anulaciones).map(([id,v])=>({id,...v}));
            const anulData = anulArray.map(an => {
                const ts = formatTimestamp(an.cancelledAt || an.timestamp);
                return {
                    'L√≠nea': an.line || an.linea || '',
                    'Orden Producci√≥n': an.parcial || an.orderNumber || '',
                    'Fecha Anulaci√≥n': ts.fecha,
                    'Hora Anulaci√≥n': ts.hora
                };
            });
            
            // Generar archivo Excel con m√∫ltiples hojas usando XML
            const fecha = new Date().toISOString().split('T')[0];
            
            // Funci√≥n para generar contenido XML de una hoja
            function generateWorksheetXML(data, headers, sheetName) {
                let xml = `
                <Worksheet ss:Name="${sheetName}">
                    <Table>`;
                
                // Encabezados
                xml += `<Row ss:Height="30">`;
                headers.forEach(h => {
                    xml += `
                        <Cell ss:StyleID="Header">
                            <Data ss:Type="String">${h}</Data>
                        </Cell>`;
                });
                xml += `</Row>`;
                
                // Datos
                data.forEach((row, idx) => {
                    const styleID = idx % 2 === 0 ? 'EvenRow' : 'OddRow';
                    xml += `<Row>`;
                    headers.forEach(h => {
                        xml += `
                        <Cell ss:StyleID="${styleID}">
                            <Data ss:Type="String">${row[h] || ''}</Data>
                        </Cell>`;
                    });
                    xml += `</Row>`;
                });
                
                xml += `
                    </Table>
                </Worksheet>`;
                
                return xml;
            }
            
            // Crear documento XML de Excel con estilos
            let excelXML = `<?xml version="1.0"?>
<?mso-application progid="Excel.Sheet"?>
<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
    xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">
    <Styles>
        <Style ss:ID="Header">
            <Font ss:Bold="1" ss:Size="14" ss:Color="#FFFFFF"/>
            <Interior ss:Color="#4F46E5" ss:Pattern="Solid"/>
            <Alignment ss:Horizontal="Center" ss:Vertical="Center"/>
            <Borders>
                <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="2" ss:Color="#000000"/>
                <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="2" ss:Color="#000000"/>
                <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="2" ss:Color="#000000"/>
                <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="2" ss:Color="#000000"/>
            </Borders>
        </Style>
        <Style ss:ID="EvenRow">
            <Interior ss:Color="#F8F9FA" ss:Pattern="Solid"/>
            <Alignment ss:Horizontal="Center" ss:Vertical="Center"/>
            <Font ss:Size="11"/>
            <Borders>
                <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="#000000"/>
                <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="#000000"/>
                <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="#000000"/>
                <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="#000000"/>
            </Borders>
        </Style>
        <Style ss:ID="OddRow">
            <Interior ss:Color="#FFFFFF" ss:Pattern="Solid"/>
            <Alignment ss:Horizontal="Center" ss:Vertical="Center"/>
            <Font ss:Size="11"/>
            <Borders>
                <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="#000000"/>
                <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="#000000"/>
                <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="#000000"/>
                <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="#000000"/>
            </Borders>
        </Style>
    </Styles>`;
            
            // A√±adir hoja de Historial
            if(histData.length > 0) {
                excelXML += generateWorksheetXML(
                    histData, 
                    ['Parcial', 'L√≠nea', 'Fecha Solicitud', 'Hora Solicitud', 'Fecha Abastecimiento', 'Hora Abastecimiento', 'Duraci√≥n'],
                    'Historial'
                );
            }
            
            // A√±adir hoja de Anulaciones
            if(anulData.length > 0) {
                excelXML += generateWorksheetXML(
                    anulData,
                    ['L√≠nea', 'Orden Producci√≥n', 'Fecha Anulaci√≥n', 'Hora Anulaci√≥n'],
                    'Anulaciones'
                );
            }
            
            excelXML += `</Workbook>`;
            
            // Descargar como archivo XLS con hojas separadas
            const blob = new Blob([excelXML], { type: 'application/vnd.ms-excel' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `estado-vidrio-${fecha}.xls`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('‚úÖ Excel con 2 hojas (Historial y Anulaciones) descargado correctamente.');
        }catch(e){ 
            console.error('exportAllData error', e); 
            alert('‚ùå Error exportando datos:\n' + (e.message || String(e))); 
        }
    }

    function downloadBlob(filename, blob){
        try{
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(()=>URL.revokeObjectURL(url), 2000);
        }catch(e){ console.error('downloadBlob error', e); }
    }

    function objArrayToCSV(arr){
        const headerSet = new Set();
        arr.forEach(o=>{ Object.keys(o||{}).forEach(k=>headerSet.add(k)); });
        const headers = Array.from(headerSet);
        const lines = [headers.join(',')];
        for(const o of arr){
            const row = headers.map(h=>{
                let v = o[h] !== undefined ? o[h] : '';
                if(v === null) v = '';
                v = String(v).replace(/"/g, '""');
                if(v.indexOf(',')!==-1 || v.indexOf('\n')!==-1) v = '"'+v+'"';
                return v;
            }).join(',');
            lines.push(row);
        }
        return lines.join('\n');
    }

    // Panel interno: l√≥gica de render y botones
    function renderPanelContent(){
        // render historial from Firebase (√∫ltimas 20 √≥rdenes abastecidas)
        const listEl = document.getElementById('panel-historial-list');
        if(!listEl) return;
        listEl.innerHTML = '<em>Cargando...</em>';
        
        // Cargar desde Firebase
        try{
            if(window.db){
                window.db.ref('abastecimientos').once('value', snap=>{
                    const data = snap.val() || {};
                    const ordenes = Object.values(data).sort((a, b) => (b.suppliedAt || 0) - (a.suppliedAt || 0)).slice(0, 20);
                    
                    if(ordenes.length === 0){ 
                        listEl.innerHTML = '<em style="padding:10px;display:block;">üì≠ Sin √≥rdenes abastecidas a√∫n.</em>'; 
                        return; 
                    }
                    
                    listEl.innerHTML = ordenes.map((orden, idx) => {
                        // Extraer datos
                        const line = orden.line || '‚Äî';
                        const parcial = orden.parcial || '‚Äî';
                        const requestedAt = orden.requestedAt || 0;
                        const suppliedAt = orden.suppliedAt || 0;
                        const duration = orden.duration || 0;
                        
                        // Convertir timestamps a hora legible
                        const solicitudTime = new Date(requestedAt).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        const abastecimientoTime = new Date(suppliedAt).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        
                        // Convertir duraci√≥n a formato legible (Xm Ys)
                        const totalSeconds = Math.floor(duration / 1000);
                        const minutes = Math.floor(totalSeconds / 60);
                        const seconds = totalSeconds % 60;
                        const durationText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        
                        // Formatear fecha
                        const fecha = new Date(suppliedAt).toLocaleDateString('es-ES');
                        
                        return `
                            <div class="hist-item" style="border-left:5px solid #4f46e5;">
                                <div style="margin-bottom:10px;">
                                    <div style="font-size:16px; font-weight:800; color:#0f172a; margin-bottom:6px;">üì¶ ${parcial}</div>
                                    <div style="font-size:12px; color:#64748b;">
                                        üìç <strong style="color:#4f46e5;">${line}</strong>
                                    </div>
                                </div>
                                <div style="background:#f1f5f9; padding:10px; border-radius:6px; font-size:11px; line-height:1.8;">
                                    <div style="display:flex; align-items:center; gap:6px;">
                                        <span style="opacity:0.7;">üìÖ</span> <strong>${fecha}</strong>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:6px;">
                                        <span style="opacity:0.7;">üì§</span> ${solicitudTime}
                                    </div>
                                    <div style="display:flex; align-items:center; gap:6px;">
                                        <span style="opacity:0.7;">üì•</span> ${abastecimientoTime}
                                    </div>
                                    <div style="display:flex; align-items:center; gap:6px; margin-top:4px; padding-top:6px; border-top:1px solid #e2e8f0;">
                                        <span>‚è±Ô∏è</span> <strong style="color:#4f46e5; font-size:13px;">${durationText}</strong>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                });
            } else {
                listEl.innerHTML = '<em style="padding:10px;display:block;">‚ùå Firebase no disponible.</em>';
            }
        }catch(e){ 
            listEl.innerHTML = '<em style="padding:10px;display:block;">‚ùå Error cargando historial.</em>'; 
            console.error('renderPanelContent error:', e); 
        }
    }

    // ==========================================
    // CARGAR DATOS SOLO DESDE FIREBASE (Firebase como fuente √∫nica de verdad)
    // ==========================================
    async function loadAllDataFromFirebase(){
        try{
            let kanbanData = {};
            let solicitudesData = {};
            let abastecimientosData = {};
            let anulacionesData = {};
            let historialData = {};

            // Si Firebase est√° disponible, cargar desde ah√≠
            if(window.db){
                console.log('üì• Descargando TODOS los datos desde Firebase...');

                // Usar Promises para cargar en paralelo
                await Promise.all([
                    new Promise(resolve => {
                        window.db.ref('kanban_estado').once('value', (snap) => {
                            kanbanData = snap.val() || {};
                            console.log('‚úÖ Kanban desde Firebase:', kanbanData);
                            resolve();
                        });
                    }),
                    new Promise(resolve => {
                        window.db.ref('solicitudes').once('value', (snap) => {
                            solicitudesData = snap.val() || {};
                            console.log('‚úÖ Solicitudes desde Firebase:', solicitudesData);
                            resolve();
                        });
                    }),
                    new Promise(resolve => {
                        window.db.ref('abastecimientos').once('value', (snap) => {
                            abastecimientosData = snap.val() || {};
                            console.log('‚úÖ Abastecimientos desde Firebase:', abastecimientosData);
                            resolve();
                        });
                    }),
                    new Promise(resolve => {
                        window.db.ref('anulaciones').once('value', (snap) => {
                            anulacionesData = snap.val() || {};
                            console.log('‚úÖ Anulaciones desde Firebase:', anulacionesData);
                            resolve();
                        });
                    }),
                    new Promise(resolve => {
                        window.db.ref('historial').once('value', (snap) => {
                            historialData = snap.val() || {};
                            console.log('‚úÖ Historial desde Firebase:', historialData);
                            resolve();
                        });
                    })
                ]);
            } else {
                console.warn('‚ö† Firebase no disponible. Intentando cargar desde localStorage/fallback...');
                // Fallback: cargar desde localStorage si existen datos previos
                try {
                    kanbanData = JSON.parse(localStorage.getItem('json_kanban_state') || '{}');
                    solicitudesData = JSON.parse(localStorage.getItem('json_solicitudes') || '{}');
                    abastecimientosData = JSON.parse(localStorage.getItem('json_abastecimientos') || '{}');
                    anulacionesData = JSON.parse(localStorage.getItem('json_anulaciones') || '{}');
                    historialData = JSON.parse(localStorage.getItem('json_historial') || '{}');
                    console.log('‚úÖ Datos cargados desde localStorage');
                } catch (e) {
                    console.warn('‚ö† No hay datos en localStorage');
                }
            }

            // Guardar en localStorage (como cach√©)
            localStorage.setItem('json_kanban_state', JSON.stringify(kanbanData, null, 2));
            localStorage.setItem('json_solicitudes', JSON.stringify(solicitudesData, null, 2));
            localStorage.setItem('json_abastecimientos', JSON.stringify(abastecimientosData, null, 2));
            localStorage.setItem('json_anulaciones', JSON.stringify(anulacionesData, null, 2));
            localStorage.setItem('json_historial', JSON.stringify(historialData, null, 2));

            console.log('‚úÖ Todos los datos cargados correctamente');

            // Convertir kanbanData a array de l√≠neas para renderizar
            const lines = Object.keys(kanbanData).map(lineName => ({
                name: lineName,
                count: (kanbanData[lineName] || []).length,
                active: true
            }));

            // Si no hay l√≠neas en Firebase, usar las l√≠neas por defecto
            if(lines.length === 0){
                const defaultLines = ['PKB1', 'PKB2', 'PKB3', 'PKB4', 'PKB5', 'PKB6', 'JVH2', 'EYS', 'MAQ'];
                lines.push(...defaultLines.map(name => ({ name, count: 0, active: true })));
                console.log('üìã Usando l√≠neas por defecto:', lines);
            }

            // Guardar l√≠neas en localStorage y renderizar
            localStorage.setItem('pk_lines', JSON.stringify(lines));
            
            // ‚úÖ APLICAR datos del Kanban al DOM (esto renderiza los bloques)
            if(typeof applyKanbanSnapshot === 'function') {
                console.log('üé® Aplicando kanbanSnapshot al DOM...');
                applyKanbanSnapshot(kanbanData);
            }
            
            // Aplicar l√≠neas al DOM
            if(window.applyLinesToDOM){
                window.applyLinesToDOM(lines);
                console.log('üé® L√≠neas aplicadas al DOM');
            }

            return true;
        }catch(e){
            console.error('‚ùå Error cargando datos:', e);
            return false;
        }
    }

    // ==========================================
    // ESCUCHAR CAMBIOS EN TIEMPO REAL (Listeners activos)
    // ==========================================
    
    // Variable global para rastrear √∫ltima actualizaci√≥n y evitar loops
    window._lastKanbanUpdate = null;
    window._isUpdatingFromFirebase = false;
    
    async function initFirebaseSync(){
        console.log('üöÄüöÄüöÄ initFirebaseSync() LLAMADO');
        try{
            if(window.firebaseInitPromise){
                console.log('‚è≥ Esperando firebaseInitPromise...');
                await window.firebaseInitPromise;
                console.log('‚úÖ firebaseInitPromise resuelto');
            }
            
            if(!window.db){
                console.error('‚ùå‚ùå‚ùå Firebase DB NO DISPONIBLE en initFirebaseSync');
                return;
            }

            console.log('üîä Iniciando listeners de Firebase en tiempo real...');
            console.log('üóÑÔ∏è DB ref:', window.db.ref().toString());
            
            // ESPERAR a que Firebase est√© realmente conectado antes de registrar listeners
            console.log('‚è≥ Esperando conexi√≥n de Firebase...');
            let isConnected = false;
            await new Promise((resolve) => {
                window.db.ref('.info/connected').on('value', (snap) => {
                    console.log('üì° Estado de conexi√≥n:', snap.val());
                    if(snap.val() === true && !isConnected) {
                        isConnected = true;
                        console.log('‚úÖ‚úÖ‚úÖ Firebase DEFINITIVAMENTE conectado - Registrando listeners');
                        resolve();
                    }
                });
                // Timeout de seguridad de 10s
                setTimeout(() => {
                    console.log('‚è∞ Timeout de 10s alcanzado - continuando de todos modos');
                    resolve();
                }, 10000);
            });
            console.log('üì° Database URL:', window.db.ref().toString());

            // Funci√≥n reutilizable para aplicar un snapshot de kanban al DOM/localStorage
            function applyKanbanSnapshot(firebaseKanban){
                // CONVERTIR objetos a arrays (Firebase convierte arrays en objetos con √≠ndices)
                const convertToArray = (obj) => {
                    if(!obj) return [];
                    if(Array.isArray(obj)) return obj;
                    // Si es objeto con claves num√©ricas, convertir a array
                    const keys = Object.keys(obj).sort((a, b) => parseInt(a) - parseInt(b));
                    return keys.map(k => obj[k]);
                };
                
                // Convertir TODOS los valores a arrays
                const normalizedKanban = {};
                Object.keys(firebaseKanban || {}).forEach(lineName => {
                    normalizedKanban[lineName] = convertToArray(firebaseKanban[lineName]);
                });
                
                const firebaseJSON = JSON.stringify(normalizedKanban || {});

                // Detectar cambios reales
                const lastUpdate = window._lastKanbanUpdate;
                const hasChanges = lastUpdate !== firebaseJSON;

                console.log('üîÑ Datos de Firebase (normalizados):', normalizedKanban);
                console.log('üìä L√≠neas:', Object.keys(normalizedKanban||{}));
                console.log('üì¶ Parciales por l√≠nea:', Object.keys(normalizedKanban||{}).map(k => `${k}: ${(normalizedKanban[k] || []).length}`).join(', '));
                console.log('üîç ¬øHay cambios reales?', hasChanges);

                if(!hasChanges && window._isUpdatingFromFirebase){
                    console.log('‚è≠Ô∏è Sin cambios reales, ignorando actualizaci√≥n');
                    return;
                }

                window._lastKanbanUpdate = firebaseJSON;
                try { localStorage.setItem('json_kanban_state', JSON.stringify(normalizedKanban, null, 2)); } catch(e) { console.warn('localStorage no disponible'); }

                // Obtener l√≠neas actuales del localStorage (mantener estructura)
                let currentLines = [];
                try { currentLines = JSON.parse(localStorage.getItem('pk_lines') || '[]'); } catch(e) { currentLines = []; }

                // SI currentLines est√° vac√≠o, crear l√≠neas desde Firebase
                if(currentLines.length === 0) {
                    console.log('üìå currentLines vac√≠o - creando desde Firebase');
                    Object.keys(normalizedKanban || {}).forEach(lineName => {
                        currentLines.push({
                            name: lineName,
                            count: 0,
                            active: true
                        });
                    });
                }

                // Crear un mapa de l√≠neas existentes para preservar active/inactive
                const lineStatusMap = {};
                currentLines.forEach(line => {
                    lineStatusMap[line.name] = line.active !== false;
                });

                // Construir l√≠neas actualizadas desde Firebase
                const updatedLines = [];

                // Primero, actualizar l√≠neas que existen en Firebase
                Object.keys(normalizedKanban || {}).forEach(lineName => {
                    const parciales = normalizedKanban[lineName] || [];
                    updatedLines.push({
                        name: lineName,
                        count: parciales.length,
                        active: lineStatusMap[lineName] !== false
                    });
                });

                // Luego, agregar l√≠neas que est√°n en currentLines pero no en Firebase (preservar estructura)
                currentLines.forEach(line => {
                    if (!normalizedKanban || !normalizedKanban.hasOwnProperty(line.name)) {
                        updatedLines.push({
                            name: line.name,
                            count: 0,
                            active: line.active !== false
                        });
                    }
                });

                try { localStorage.setItem('pk_lines', JSON.stringify(updatedLines)); } catch(e) { console.warn('localStorage no disponible'); }
                console.log('üíæ pk_lines actualizado:', updatedLines);

                // Actualizar pk_block_names para reflejar los nombres EXACTOS de Firebase
                const pk_block_names = {};
                Object.keys(normalizedKanban || {}).forEach(lineName => {
                    const blocks = normalizedKanban[lineName] || [];
                    pk_block_names[lineName] = {};
                    blocks.forEach((blockName, idx) => {
                        if(blockName){
                            pk_block_names[lineName][String(idx)] = blockName;
                        }
                    });
                });
                try { localStorage.setItem('pk_block_names', JSON.stringify(pk_block_names)); } catch(e) { console.warn('localStorage no disponible'); }
                console.log('üè∑Ô∏è pk_block_names actualizado:', pk_block_names);

                // Refrescar bloques SIN cambiar estructura de columnas
                if(window.applyLinesToDOM){
                    try{
                        window._isUpdatingFromFirebase = true;
                        window.applyLinesToDOM(updatedLines);
                        console.log('‚úÖ Parciales actualizados en DOM desde Firebase');
                        console.log('üéØ Total de l√≠neas renderizadas:', updatedLines.length);

                        // Forzar actualizaci√≥n de los nombres de bloques desde pk_block_names
                        setTimeout(() => {
                            try {
                                const cols = Array.from(document.querySelectorAll('.container > .column'));
                                cols.forEach(col => {
                                    const lineName = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                                    const blocks = Array.from(col.querySelectorAll('.block'));
                                    const lineNames = pk_block_names[lineName] || {};

                                    blocks.forEach((block, idx) => {
                                        const savedName = lineNames[String(idx)];
                                        if(savedName){
                                            block.setAttribute('data-name', savedName);
                                            block.setAttribute('data-line', lineName);
                                            block.setAttribute('data-index', String(idx));

                                            // Actualizar el texto visible
                                            let label = block.querySelector('.label');
                                            if(!label){
                                                label = document.createElement('span');
                                                label.className = 'label';
                                                block.appendChild(label);
                                            }
                                            label.textContent = savedName;
                                            console.log(`üè∑Ô∏è Bloque ${lineName}[${idx}] = "${savedName}"`);
                                        }
                                    });
                                });
                                console.log('‚úÖ Nombres de bloques sincronizados con Firebase');
                                
                                // ‚ö° RESTAURAR ESTADO DE SOLICITUD desde Firebase (async IIFE)
                                (async () => {
                                    try {
                                        if(window.db) {
                                            const solicitudSnap = await window.db.ref('solicitudes').once('value');
                                            const solicitudData = solicitudSnap.val() || {};
                                            
                                            console.log('üìã Datos de solicitudes de Firebase:', solicitudData);
                                            
                                            // Obtener l√≠neas solicitadas
                                            const requestedMap = {};
                                            Object.keys(solicitudData || {}).forEach(lineName => {
                                                const lineData = solicitudData[lineName];
                                                if(lineData && typeof lineData === 'object') {
                                                    requestedMap[lineName] = Object.keys(lineData)
                                                        .filter(key => lineData[key] && lineData[key].requestedAt)
                                                    .map(key => parseInt(key));
                                            }
                                        });
                                        
                                        console.log('üü† Parciales solicitados desde Firebase:', requestedMap);
                                        
                                        // Restaurar clase .requested en los bloques
                                        Object.keys(requestedMap || {}).forEach(lineName => {
                                            const indices = requestedMap[lineName] || [];
                                            const blocks = Array.from(document.querySelectorAll(`[data-line="${lineName}"].block`));
                                            
                                            blocks.forEach((block, idx) => {
                                                if(indices.includes(idx)) {
                                                    block.classList.add('requested');
                                                    console.log(`üü† Marcado como solicitado: ${lineName}[${idx}]`);
                                                } else {
                                                    block.classList.remove('requested');
                                                }
                                            });
                                        });
                                        
                                        console.log('‚úÖ Estados de solicitud restaurados');
                                    }
                                    } catch(e) {
                                        console.warn('‚ö†Ô∏è Error restaurando solicitudes:', e);
                                    }
                                })();
                            } catch(e) {
                                console.error('‚ùå Error actualizando nombres de bloques:', e);
                            } finally {
                                window._isUpdatingFromFirebase = false;
                            }
                        }, 100);
                    }catch(e){
                        console.error('‚ùå Error actualizando parciales:', e);
                        window._isUpdatingFromFirebase = false;
                    }
                }
            }

            // Escuchar cambios en kanban_estado
            window.db.ref('kanban_estado').on('value', (snap) => {
                console.log('üîî ¬°¬°¬° EVENTO DE FIREBASE RECIBIDO !!!');
                const firebaseKanban = snap.val() || {};
                console.log('üì• Datos recibidos de Firebase:', firebaseKanban);
                applyKanbanSnapshot(firebaseKanban);
            });

            // Polling de respaldo: cada 3s forzar lectura y aplicaci√≥n del estado (√∫til si fallan eventos)
            setInterval(async () => {
                try{
                    if(!window.db) return;
                    const snap = await window.db.ref('kanban_estado').once('value');
                    const data = snap.val() || {};
                    console.log('‚è±Ô∏è [POLLING 3s] Estado de Firebase:', data);
                    applyKanbanSnapshot(data);
                }catch(e){ console.warn('Polling kanban_estado fall√≥', e); }
            }, 3000);

            console.log('‚úÖ Listener de kanban_estado registrado');

            // üü†üî• LISTENER CR√çTICO: Escuchar cambios en solicitudes (TITILADO EN TIEMPO REAL)
            console.log('üî•üü† REGISTRANDO LISTENER DE SOLICITUDES...');
            const solicitudesRef = window.db.ref('solicitudes');
            console.log('üîó Referencia de solicitudes:', solicitudesRef.toString());
            
            solicitudesRef.on('value', (snap) => {
                console.log('üîîüü†üîîüü†üîî ¬°¬°¬° EVENTO DE SOLICITUDES RECIBIDO (TITILADO) !!!');
                const firebaseSolicitudes = snap.val() || {};
                console.log('üì• Solicitudes de Firebase:', firebaseSolicitudes);
                try { localStorage.setItem('json_solicitudes', JSON.stringify(firebaseSolicitudes, null, 2)); } catch(e) { console.warn('localStorage no disponible'); }
                
                // Convertir solicitudes de Firebase a pk_requested y pk_solicitud_salida
                const pk_requested = {};
                const pk_solicitud_salida = {};
                
                Object.keys(firebaseSolicitudes).forEach(lineName => {
                    const lineData = firebaseSolicitudes[lineName];
                    if(lineData && typeof lineData === 'object'){
                        pk_requested[lineName] = Object.keys(lineData).filter(key => {
                            const val = lineData[key];
                            return val && val.requestedAt;
                        }).map(key => parseInt(key));
                        
                        pk_solicitud_salida[lineName] = {};
                        Object.keys(lineData).forEach(key => {
                            if(lineData[key] && lineData[key].requestedAt){
                                pk_solicitud_salida[lineName][key] = lineData[key].requestedAt;
                            }
                        });
                    }
                });
                
                try { localStorage.setItem('pk_requested', JSON.stringify(pk_requested)); } catch(e) { console.warn('localStorage no disponible'); }
                try { localStorage.setItem('pk_solicitud_salida', JSON.stringify(pk_solicitud_salida)); } catch(e) { console.warn('localStorage no disponible'); }
                
                // üü†üéØ ACTUALIZAR VISUALMENTE LOS BLOQUES CON ESTADO "REQUESTED" (TITILADO)
                console.log('üü† Actualizando estados de solicitud en DOM:', pk_requested);
                
                // Obtener todas las columnas
                const columns = document.querySelectorAll('.container > .column');
                columns.forEach(col => {
                    try{
                        const lineName = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                        const blocks = Array.from(col.querySelectorAll('.block'));
                        const requestedIndices = pk_requested[lineName] || [];
                        
                        console.log(`üìã L√≠nea: ${lineName}, Indices solicitados: [${requestedIndices.join(', ')}]`);
                        
                        blocks.forEach((block, idx) => {
                            // Asegurar que el bloque tiene data-index
                            if(!block.hasAttribute('data-index')){
                                block.setAttribute('data-index', String(idx));
                            }
                            if(!block.hasAttribute('data-line')){
                                block.setAttribute('data-line', lineName);
                            }
                            
                            const blockIdx = parseInt(block.getAttribute('data-index') || idx, 10);
                            
                            if(requestedIndices.includes(blockIdx)) {
                                if(!block.classList.contains('requested')){
                                    block.classList.add('requested');
                                    console.log(`‚ú®üü† TITILADO ACTIVADO: ${lineName}[${blockIdx}]`);
                                }
                            } else {
                                if(block.classList.contains('requested')){
                                    block.classList.remove('requested');
                                    console.log(`üîá TITILADO DESACTIVADO: ${lineName}[${blockIdx}]`);
                                }
                            }
                        });
                    }catch(e){
                        console.warn('Error procesando columna para titilado:', e);
                    }
                });
                
                console.log('‚úÖ Titilado sincronizado desde Firebase');
            }, (error) => {
                console.error('‚ùå ERROR EN LISTENER DE SOLICITUDES:', error);
            });
            
            console.log('‚úÖ‚úÖ LISTENER DE SOLICITUDES REGISTRADO CORRECTAMENTE');
            
            // üß™ TEST: Leer solicitudes actuales inmediatamente
            setTimeout(async () => {
                try{
                    console.log('üß™ TEST: Leyendo solicitudes actuales...');
                    const testSnap = await window.db.ref('solicitudes').once('value');
                    const testData = testSnap.val();
                    console.log('üß™ Solicitudes actuales en Firebase:', testData);
                    if(testData && Object.keys(testData).length > 0){
                        console.log('üü† HAY SOLICITUDES ACTIVAS - deber√≠an estar titilando');
                    } else {
                        console.log('‚ö™ No hay solicitudes activas');
                    }
                }catch(e){
                    console.error('‚ùå Error en test de solicitudes:', e);
                }
            }, 2000);

            // Escuchar cambios en abastecimientos
            console.log('%cüì¶ REGISTRANDO LISTENER DE ABASTECIMIENTOS...', 'background: green; color: white; font-weight: bold; padding: 4px;');
            window.db.ref('abastecimientos').on('value', (snap) => {
                console.log('%cüîîüì¶ ¬°¬°¬° EVENTO DE ABASTECIMIENTOS RECIBIDO !!!', 'background: green; color: white; font-weight: bold; padding: 8px; font-size: 16px;');
                const firebaseAbastecimientos = snap.val() || {};
                console.log('üì• Abastecimientos de Firebase:', firebaseAbastecimientos);
                localStorage.setItem('json_abastecimientos', JSON.stringify(firebaseAbastecimientos, null, 2));
                
                // Convertir abastecimientos a pk_history
                const pk_history = [];
                Object.keys(firebaseAbastecimientos).forEach(lineName => {
                    const lineData = firebaseAbastecimientos[lineName];
                    if(lineData && typeof lineData === 'object'){
                        Object.keys(lineData).forEach(key => {
                            const entry = lineData[key];
                            if(entry){
                                pk_history.push({
                                    lineName: lineName,
                                    parcial: entry.parcial || entry.name || 'N/A',
                                    timestamp: entry.timestamp || entry.suppliedAt || Date.now(),
                                    fecha: entry.fecha || new Date().toLocaleDateString(),
                                    hora: entry.hora || new Date().toLocaleTimeString()
                                });
                            }
                        });
                    }
                });
                
                try { localStorage.setItem('pk_history', JSON.stringify(pk_history.slice(-200))); } catch(e) { console.warn('localStorage no disponible'); }
                
                // Actualizar historial en la UI (panel de √∫ltimos 5 parciales)
                try{
                    console.log('%cüìã ACTUALIZANDO HISTORIAL EN TIEMPO REAL', 'background: purple; color: white; font-weight: bold; padding: 4px;');
                    console.log('üìä Total de items en pk_history:', pk_history.length);
                    console.log('üîç ¬øwindow.renderRecentHistory existe?', !!window.renderRecentHistory);
                    
                    // Ordenar por fecha m√°s reciente primero
                    const sorted = pk_history.sort((a, b) => {
                        const timeA = a.timestamp || a.suppliedAt || 0;
                        const timeB = b.timestamp || b.suppliedAt || 0;
                        return timeB - timeA;
                    });
                    
                    console.log('üîù Top 5 items:', sorted.slice(0, 5));
                    
                    // Preparar datos para renderRecentHistory
                    const recentItems = sorted.slice(0, 5).map(item => ({
                        id: `${item.lineName}_${item.parcial}`,
                        name: item.parcial,
                        orderId: item.parcial,
                        line: item.lineName,
                        action: 'abastecido',
                        suppliedAt: item.timestamp || Date.now(),
                        ts: item.timestamp || Date.now()
                    }));
                    
                    console.log('üì¶ Items preparados para renderizar:', recentItems);
                    
                    // Actualizar el panel
                    if(window.renderRecentHistory){
                        window.renderRecentHistory(recentItems);
                        console.log('‚úÖ renderRecentHistory ejecutado exitosamente');
                    } else {
                        console.error('‚ùå window.renderRecentHistory NO EST√Å DISPONIBLE');
                    }
                    
                    // Tambi√©n llamar al m√≥dulo si existe
                    if(window.historialModule && window.historialModule.renderizar){
                        window.historialModule.renderizar();
                        console.log('‚úÖ historialModule.renderizar ejecutado');
                    }
                }catch(e){
                    console.error('‚ùå Error actualizando historial:', e);
                }
                
                console.log('üîÑ Abastecimientos sincronizados desde Firebase');
            });

            // Escuchar cambios en anulaciones
            window.db.ref('anulaciones').on('value', (snap) => {
                const firebaseAnulaciones = snap.val() || {};
                try { localStorage.setItem('json_anulaciones', JSON.stringify(firebaseAnulaciones, null, 2)); } catch(e) { console.warn('localStorage no disponible'); }
                console.log('üîÑ Anulaciones actualizadas desde Firebase en tiempo real');
            });
            
            console.log('‚úÖ Listeners de Firebase inicializados correctamente');
            
            // ‚ö° CARGAR DATOS INICIALES DESDE FIREBASE (sin depender de localStorage)
            console.log('üîÑ Cargando datos iniciales desde Firebase...');
            try {
                const kanbanSnap = await window.db.ref('kanban_estado').once('value');
                const firebaseKanban = kanbanSnap.val() || {};
                console.log('üì• Datos de Firebase recibidos:', firebaseKanban);
                
                if(Object.keys(firebaseKanban).length > 0) {
                    console.log('‚úÖ Aplicando snapshot inicial...');
                    if(typeof applyKanbanSnapshot === 'function') {
                        applyKanbanSnapshot(firebaseKanban);
                        console.log('‚úÖ Snapshot aplicado exitosamente');
                    } else {
                        console.warn('‚ö†Ô∏è applyKanbanSnapshot no disponible');
                    }
                } else {
                    console.log('‚ö†Ô∏è Firebase est√° vac√≠o');
                }
            } catch(e) {
                console.error('‚ùå Error cargando datos iniciales:', e);
            }
            
            // ‚ö° POLLING AGRESIVO CADA 1 SEGUNDO PARA SINCRONIZACI√ìN EN TIEMPO REAL
            console.log('üöÄ INICIANDO POLLING CADA 1 SEGUNDO...');
            let pollCount = 0;
            window._pollingInterval = setInterval(async () => {
                pollCount++;
                try {
                    const snapshot = await window.db.ref('kanban_estado').once('value');
                    const firebaseKanban = snapshot.val() || {};
                    
                    if(Object.keys(firebaseKanban).length === 0) {
                        return; // Sin datos en Firebase, no hacer nada
                    }
                    
                    // CONVERTIR objetos a arrays (Firebase convierte arrays en objetos)
                    const convertToArray = (obj) => {
                        if(!obj) return [];
                        if(Array.isArray(obj)) return obj;
                        const keys = Object.keys(obj).sort((a, b) => parseInt(a) - parseInt(b));
                        return keys.map(k => obj[k]);
                    };
                    
                    // Verificar si hay diferencia entre Firebase y DOM
                    let needsUpdate = false;
                    
                    Object.keys(firebaseKanban).forEach(lineName => {
                        const parciales = convertToArray(firebaseKanban[lineName]);
                        const blocks = Array.from(document.querySelectorAll(`[data-line="${lineName}"].block`));
                        
                        if(blocks.length !== parciales.length) {
                            needsUpdate = true;
                            console.log(`‚ö†Ô∏è [POLLING #${pollCount}] ${lineName}: Firebase=${parciales.length}, DOM=${blocks.length} ‚Üí ACTUALIZANDO`);
                        }
                    });
                    
                    if(needsUpdate) {
                        console.log(`‚ö° [POLLING #${pollCount}] DETECTADO CAMBIO - Aplicando snapshot...`);
                        if(typeof applyKanbanSnapshot === 'function') {
                            applyKanbanSnapshot(firebaseKanban);
                        }
                    }
                    
                } catch(e) {
                    console.error(`‚ùå [POLLING #${pollCount}] Error:`, e.message);
                }
            }, 1000);
            
        }catch(e){
            console.warn('‚ö† Error inicializando Firebase listeners:', e.message);
        }
    }

    // ==========================================
    // LISTENER DE ABASTECIMIENTOS (FUERA DE initFirebaseSync)
    // ==========================================
    (async function registerAbastecimientosListener(){
        try{
            // Esperar a que Firebase est√© listo
            if(window.firebaseInitPromise){
                await window.firebaseInitPromise;
            }
            
            if(!window.db){
                console.error('‚ùå Firebase no disponible para listener de abastecimientos');
                return;
            }
            
            console.log('%cüì¶ REGISTRANDO LISTENER DE ABASTECIMIENTOS...', 'background: green; color: white; font-weight: bold; padding: 4px;');
            
            window.db.ref('abastecimientos').on('value', (snap) => {
                console.log('%cüîîüì¶ ¬°¬°¬° EVENTO DE ABASTECIMIENTOS RECIBIDO !!!', 'background: green; color: white; font-weight: bold; padding: 8px; font-size: 16px;');
                const firebaseAbastecimientos = snap.val() || {};
                console.log('üì• Abastecimientos de Firebase:', firebaseAbastecimientos);
                localStorage.setItem('json_abastecimientos', JSON.stringify(firebaseAbastecimientos, null, 2));
                
                // Convertir abastecimientos a pk_history
                const pk_history = [];
                Object.keys(firebaseAbastecimientos).forEach(lineName => {
                    const lineData = firebaseAbastecimientos[lineName];
                    if(lineData && typeof lineData === 'object'){
                        Object.keys(lineData).forEach(key => {
                            const entry = lineData[key];
                            if(entry){
                                pk_history.push({
                                    lineName: lineName,
                                    parcial: entry.parcial || entry.name || 'N/A',
                                    timestamp: entry.timestamp || entry.suppliedAt || Date.now(),
                                    fecha: entry.fecha || new Date().toLocaleDateString(),
                                    hora: entry.hora || new Date().toLocaleTimeString()
                                });
                            }
                        });
                    }
                });
                
                try { localStorage.setItem('pk_history', JSON.stringify(pk_history.slice(-200))); } catch(e) { console.warn('localStorage no disponible'); }
                
                // Actualizar historial en la UI (panel de √∫ltimos 5 parciales)
                try{
                    console.log('%cüìã ACTUALIZANDO HISTORIAL EN TIEMPO REAL', 'background: purple; color: white; font-weight: bold; padding: 4px;');
                    console.log('üìä Total de items en pk_history:', pk_history.length);
                    console.log('üîç ¬øwindow.renderRecentHistory existe?', !!window.renderRecentHistory);
                    
                    // Ordenar por fecha m√°s reciente primero
                    const sorted = pk_history.sort((a, b) => {
                        const timeA = a.timestamp || a.suppliedAt || 0;
                        const timeB = b.timestamp || b.suppliedAt || 0;
                        return timeB - timeA;
                    });
                    
                    console.log('üîù Top 5 items:', sorted.slice(0, 5));
                    
                    // Preparar datos para renderRecentHistory
                    const recentItems = sorted.slice(0, 5).map(item => ({
                        id: `${item.lineName}_${item.parcial}`,
                        name: item.parcial,
                        orderId: item.parcial,
                        line: item.lineName,
                        action: 'abastecido',
                        suppliedAt: item.timestamp || Date.now(),
                        ts: item.timestamp || Date.now()
                    }));
                    
                    console.log('üì¶ Items preparados para renderizar:', recentItems);
                    
                    // Actualizar el panel
                    if(window.renderRecentHistory){
                        window.renderRecentHistory(recentItems);
                        console.log('‚úÖ renderRecentHistory ejecutado exitosamente');
                    } else {
                        console.error('‚ùå window.renderRecentHistory NO EST√Å DISPONIBLE');
                    }
                    
                    // Tambi√©n llamar al m√≥dulo si existe
                    if(window.historialModule && window.historialModule.renderizar){
                        window.historialModule.renderizar();
                        console.log('‚úÖ historialModule.renderizar ejecutado');
                    }
                }catch(e){
                    console.error('‚ùå Error actualizando historial:', e);
                }
                
                console.log('üîÑ Abastecimientos sincronizados desde Firebase');
            });
            
            console.log('‚úÖ Listener de abastecimientos registrado correctamente');
            
        }catch(e){
            console.error('‚ùå Error registrando listener de abastecimientos:', e);
        }
    })();

    document.addEventListener('DOMContentLoaded', ()=>{
        const panel = document.getElementById('panel-control-interno');
        const btnCerrar = document.getElementById('btn-cerrar-panel');
        const btnExport = document.getElementById('panel-export-excel');
        const btnSync = document.getElementById('panel-sync-firebase');
        const btnRefresh = document.getElementById('panel-refresh-db');
        const btnReset = document.getElementById('panel-reset-firebase');
        const btnChangePass = document.getElementById('panel-change-pass');
        const inputNewPass = document.getElementById('panel-new-pass');
        
        // Restaurar panel si estaba abierto antes del refresh
        if(sessionStorage.getItem('panelControlOpen') === 'true' && panel){
            panel.style.display = 'block';
            document.body.style.overflow = 'hidden';
            if(typeof renderPanelContent === 'function') renderPanelContent();
        }
        if(btnCerrar) btnCerrar.addEventListener('click', ()=>{ 
            panel.style.display='none'; 
            document.body.style.overflow=''; 
            // Limpiar estado de persistencia
            sessionStorage.removeItem('panelControlOpen');
            try{ window.scrollTo(0,0); }catch(e){} 
        });
        if(btnExport){ btnExport.addEventListener('click', async ()=>{ try{ await exportAllData(); }catch(e){ console.warn('export button fallback', e); if(window.historialModule && window.historialModule.exportar) window.historialModule.exportar(); else alert('Funci√≥n exportar no disponible.'); } }); }
        // Botones de sincronizar y refrescar eliminados
        if(btnReset){ btnReset.addEventListener('click', async ()=>{
            try{
                // Preguntar si desea exportar antes
                const wantExport = confirm('¬øDeseas exportar los datos antes de reiniciar? Aceptar=Exportar ahora, Cancelar=No y continuar.');
                if(wantExport){ await exportAllData(); }
                else { const cont = confirm('¬øDeseas continuar sin exportar? Aceptar=Continuar, Cancelar=Cancelar reinicio'); if(!cont){ alert('Reinicio cancelado.'); return; } }

                // Mostrar advertencia clara sobre qu√© se va a borrar
                const datosABorrar = `
Se borrar√°n los siguientes datos de Firebase:
‚Ä¢ Historial de abastecimientos (√∫ltimos 5)
‚Ä¢ Todos los abastecimientos registrados
‚Ä¢ Todas las solicitudes pendientes
‚Ä¢ Todas las anulaciones registradas

‚ö†Ô∏è Esta acci√≥n NO SE PUEDE DESHACER.

Se recomienda hacer este proceso:
üìÖ AL FINAL DE CADA MES para limpiar la base de datos
y empezar el nuevo mes con informaci√≥n limpia.

¬øDeseas continuar?`;

                if(!confirm(datosABorrar)){ alert('Reinicio cancelado.'); return; }

                const confirmText = prompt("Escribe 'RESET' para confirmar el reinicio completo de datos:", '');
                if(confirmText !== 'RESET'){ alert('Reinicio cancelado. Texto de confirmaci√≥n incorrecto.'); return; }
                
                const adminPass = prompt('Ingresa la clave admin para confirmar reinicio:', '');
                const stored = localStorage.getItem('pk_admin_password_anular') || 'Almacen2025*';
                if(adminPass !== stored){ alert('Clave admin incorrecta. Reinicio cancelado.'); return; }
                
                if(!window.db){ alert('Firebase no est√° disponible. No se pudo reiniciar.'); return; }
                
                // Borrar todas las rutas de datos operacionales
                const paths = ['historial','abastecimientos','solicitudes','anulaciones','solicitud_times'];
                let borraron = 0;
                for(const p of paths){
                    try{ 
                        await window.db.ref(p).remove(); 
                        console.log(`‚úÖ Ruta '${p}' borrada`);
                        borraron++;
                    }catch(e){ 
                        console.warn('Error borrando',p,e); 
                        alert(`‚ö†Ô∏è Error borrando ${p}: ${e.message}`);
                    }
                }
                
                // Limpiar tambi√©n claves locales relacionadas
                const localKeys = ['pk_solicitud_salida','pk_requested','json_kanban_state','json_solicitudes','json_abastecimientos','json_anulaciones','pk_lines','pk_block_names','firebaseTimestampsCache'];
                localKeys.forEach(k=>{
                    localStorage.removeItem(k);
                    console.log(`üóëÔ∏è localStorage '${k}' limpiado`);
                });
                
                alert(`‚úÖ REINICIO COMPLETADO\n\n${borraron} rutas de datos borradas en Firebase.\nLocalStorage limpiado.\nLa base de datos est√° lista para el nuevo per√≠odo.`);
                renderPanelContent();
            }catch(e){ console.error('reset error', e); alert('Error durante reinicio. Revisa la consola.'); }
        }); }
        if(btnChangePass){ btnChangePass.addEventListener('click', ()=>{
            try{
                const newPass = (inputNewPass && inputNewPass.value || '').trim();
                if(!newPass){ alert('Ingrese una nueva clave v√°lida.'); return; }
                const current = prompt('Ingresa la clave actual para confirmar cambio:', '');
                const stored = localStorage.getItem('pk_admin_password_anular') || 'Almacen2025*';
                if(current !== stored){ alert('Clave actual incorrecta. Cambio cancelado.'); return; }
                localStorage.setItem('pk_admin_password_anular', newPass);
                inputNewPass.value = '';
                alert('‚úÖ Clave para anular solicitudes actualizada.');
            }catch(e){ console.error('change pass error', e); alert('Error cambiando clave.'); }
        }); }
        
        // ===== FUNCIONALIDAD DE BARRA DE NAVEGACI√ìN M√ìVIL =====
        if(window.innerWidth <= 768){
            const navButtons = document.querySelectorAll('#mobile-bottom-nav button');
            const mobilePanel = document.getElementById('panel-control-interno');
            
            navButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.getAttribute('data-tab');
                    
                    // Actualizar bot√≥n activo
                    navButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Ejecutar acci√≥n seg√∫n tab
                    switch(tab){
                        case 'kanban':
                            // Volver a kanban (cerrar panel)
                            if(mobilePanel) mobilePanel.style.display = 'none';
                            document.body.style.overflow = '';
                            window.scrollTo(0, 0);
                            break;
                        case 'panel':
                            // Abrir panel de control
                            if(mobilePanel) mobilePanel.style.display = 'block';
                            document.body.style.overflow = 'hidden';
                            break;
                        case 'export':
                            // Exportar Excel
                            if(mobilePanel) mobilePanel.style.display = 'none';
                            document.body.style.overflow = '';
                            exportAllData().catch(e => {
                                alert('Error exportando: ' + e.message);
                                console.error(e);
                            });
                            break;
                    }
                });
            });
        }
    });
</script>
</body>
</html>
