<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Diseño PK</title>
<!-- Fuente moderna -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
    :root{
        --bg-1: #f8fafc; /* claro */
        --bg-2: #f1f5f9;
        --card: rgba(0,0,0,0.02);
        --muted: #64748b;
        --accent: #34d399; /* verde */
        --accent2: #3b82f6; /* azul */
        --warning: #e74c3c;
        --glass: rgba(255,255,255,0.8);
        --glass-border: rgba(0,0,0,0.08);
        --glass-text: rgba(15,23,42,0.94);
        /* Tamaños de botones principales (fácil de personalizar) */
        --top-btn-height: 64px; /* altura por defecto */
        --top-btn-max-width: 360px; /* anchura máxima por botón */
        --top-btn-font-size: 14px; /* tamaño de la tipografía dentro del botón */
    }
    html,body{height:100%;margin:0;}
    /* ligera escala global para que la interfaz quepa mejor en pantallas grandes */
    body {
        transform: scale(1);
        transform-origin: top center;
        -webkit-transform: scale(1);
        -webkit-transform-origin: top center;
        font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 12px;
        padding: 8px; /* usar menos padding para aprovechar espacios laterales */
        background: linear-gradient(135deg, var(--bg-1) 0%, var(--bg-2) 100%);
        color: var(--glass-text);
    }
    /* stage */
    .container {
        display: flex;
        gap: 4px; /* reducir gap entre columnas para ahorrar espacio */
        border-radius: 12px;
        padding: 12px 8px; /* menos padding para reducir tamaño total */
        background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.85));
        box-shadow: 0 20px 40px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.8);
        max-width: 100%;
        width: 100%;
        border: 1px solid rgba(0,0,0,0.06);
        justify-content: space-between;
        flex-wrap: nowrap;
    }
    .column {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0 2px;
        min-width: 72px; /* columnas más estrechas para mostrar más en pantalla */
        background: linear-gradient(180deg, rgba(255,255,255,0.5), rgba(255,255,255,0.3));
        padding: 8px 6px 9px;
        border-radius: 8px;
        border: 1px solid rgba(0,0,0,0.06);
        position: relative;
        transition: transform 220ms ease, box-shadow 220ms ease;
        flex-shrink: 0;
    }
    .column:hover{ transform: translateY(-4px); box-shadow: 0 14px 30px rgba(0,0,0,0.1); }
    .column-header {
        font-weight: 700;
        text-align: center;
        margin-bottom: 9px;
        color: var(--glass-text);
        background: linear-gradient(90deg, rgba(0,0,0,0.03), rgba(0,0,0,0.02));
        padding: 4px 6px;
        border-radius: 6px;
        width: 100%;
        box-shadow: inset 0 -6px 18px rgba(0,0,0,0.02);
        font-size: 18px;
        letter-spacing: 0.5px;
    }
    .column .sol-timer{
        font-size: 12px;
        color: #06364a;
        margin-top: 6px;
        font-weight: 800;
        text-align: center;
        background: rgba(255,255,255,0.9);
        padding: 4px 6px;
        border-radius: 8px;
        box-shadow: 0 6px 18px rgba(2,6,23,0.06);
        min-width: 80px;
        margin-left: auto;
        margin-right: auto;
    }
    /* cabecera NO clickable: selección por título deshabilitada */
    .column-header {
        cursor: default;
        user-select: none;
        pointer-events: auto; /* keep pointer events for future features but prevent click-to-select behavior */
    }
    .block {
        width: 60px;
        height: 38px;
        background: linear-gradient(180deg,#fff85a,#fff069 60%);
        border-radius: 6px;
        border: 1px solid rgba(0,0,0,0.14);
        margin: 6px 0;
        box-shadow: 0 6px 14px rgba(3,7,18,0.12), inset 0 -6px 18px rgba(255,255,255,0.35);
        transition: transform 180ms ease, opacity 160ms ease;
    }
    .block .label{ display:block; font-size:10px; text-align:center; margin-top:4px; color:#0b1220; font-weight:700; pointer-events:none; }
    /* selección de parcial (click) */
    .block.selected-parcial{
        outline: 3px solid rgba(59,130,246,0.95);
        box-shadow: 0 10px 30px rgba(59,130,246,0.18), inset 0 -4px 10px rgba(255,255,255,0.4);
        transform: translateY(-3px);
    }
    /* parcial en estado 'solicitado' — titilar */
    @keyframes blink-partial {
        0% {
            box-shadow: 0 12px 28px rgba(34,197,94,0.40), 0 0 0 0 rgba(34,197,94,0);
            border-color: rgba(34,197,94,0.98);
            transform: translateY(-2px) scale(1);
            background: linear-gradient(180deg,#34d399,#10b981);
        }
        25% {
            box-shadow: 0 18px 44px rgba(231,76,60,0.48), 0 0 10px rgba(231,76,60,0.26);
            border-color: rgba(231,76,60,0.99);
            transform: translateY(-3px) scale(1.03);
            background: linear-gradient(180deg,#f87171,#ef4444);
        }
        50% {
            box-shadow: 0 14px 36px rgba(250,204,21,0.44), 0 0 10px rgba(250,204,21,0.24);
            border-color: rgba(250,204,21,0.99);
            transform: translateY(-2px) scale(1.02);
            background: linear-gradient(180deg,#fff85a,#fff069 60%);
        }
        75% {
            box-shadow: 0 18px 44px rgba(231,76,60,0.48), 0 0 14px rgba(231,76,60,0.26);
            border-color: rgba(231,76,60,0.99);
            transform: translateY(-3px) scale(1.03);
            background: linear-gradient(180deg,#f87171,#ef4444);
        }
        100% {
            box-shadow: 0 12px 28px rgba(34,197,94,0.40), 0 0 0 0 rgba(34,197,94,0);
            border-color: rgba(34,197,94,0.98);
            transform: translateY(-2px) scale(1);
            background: linear-gradient(180deg,#34d399,#10b981);
        }
    }
    .block.requested{
        animation: blink-partial 1.2s linear infinite;
        border-width: 2px;
        border-style: solid;
        z-index: 6;
        color: #0b1220;
        /* asegurar que el texto (si existe) sea visible sobre fondos cambiantes */
    }
    .block.appear{ animation: pop 320ms cubic-bezier(.2,.9,.3,1); }
    .block.removing{ animation: fadeOut 220ms ease forwards; }
    @keyframes pop{ 0%{ transform: scale(.86); opacity:0 } 60%{ transform: scale(1.04); opacity:1 } 100%{ transform: scale(1); } }
    @keyframes fadeOut{ to { transform: scale(.94); opacity:0 } }
    /* contenedor principal: layout vertical con botones arriba */
    .main-container {
        display: flex;
        flex-direction: column;
        gap: 12px;
        width: 100%;
        max-width: none; /* permitir que ocupe todo el ancho disponible */
    }
    /* fila superior: botones */
    .top-controls {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: auto auto;
        gap: 24px 300px; /* aumentado espacio horizontal entre botones */
        width: 100%;
        max-width: 100%;
        margin: 0 auto;
        padding: 6px 0 0 0;
        position: sticky;
        top: 18px;
        z-index: 90;
        background: transparent;
    }
    
    /* Posicionamiento de botones en grid */
    #btn-anular-solicitud {
        grid-column: 3;
        grid-row: 1;
    }
    
    #btn-entrada {
        grid-column: 1;
        grid-row: 2;
    }
    
    #btn-salida {
        grid-column: 2;
        grid-row: 2;
    }
    
    #btn-solicitar {
        grid-column: 3;
        grid-row: 2;
    }
    /* contenedor inferior: búsqueda izq, líneas der */
    .bottom-container {
        display: flex;
        gap: 12px;
        width: 100%;
        flex: 1;
    }
    /* panel izquierdo abajo: búsqueda y gestionar (más angosto) */
    .controls {
        border-radius: 12px;
        padding: 8px 10px;
        background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.85));
        width: 240px; /* reducir ancho para ceder espacio a las columnas */
        min-width: 200px;
        border: 1px solid rgba(0,0,0,0.06);
        backdrop-filter: blur(6px) saturate(120%);
        box-shadow: 0 12px 30px rgba(0,0,0,0.08);
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-sizing: border-box; /* ensure padding included in width */
        overflow: hidden; /* keep children visually inside the panel */
    }
    /* panel derecho: contenedor de líneas */
    .right-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: auto; /* permitir scroll interno en panel derecho */
        max-height: calc(100vh - 140px); /* dejar espacio para cabecera y controles */
    }
    .controls h3 {
        display: none;
    }
    /* Layout label + buscador en vertical */
    .controls .label-row {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 6px;
        margin-bottom: 10px;
        margin-top: 0;
    }
    .controls label {
        font-weight: bold;
        font-size: 10px;
        color: var(--glass-text);
    }
    .search-input {
        width: 100%;
        padding: 7px 9px;
        border: 1px solid rgba(0,0,0,0.08);
        border-radius: 7px;
        background: rgba(255,255,255,0.8);
        color: var(--glass-text);
        box-shadow: inset 0 4px 10px rgba(0,0,0,0.04);
        font-size: 11px;
    }
    /* buscador: atenuar elementos no coincidentes y resaltar coincidencias */
    .block.search-dim { opacity: 0.18; transform: scale(0.98); filter: grayscale(40%); }
    .block.search-match { outline: 3px solid rgba(59,130,246,0.92); box-shadow: 0 12px 32px rgba(59,130,246,0.16); transform: translateY(-4px); }
    .search-row { display:flex; gap:8px; align-items:center; }
    .search-clear { background:transparent;border:0;color:var(--muted);cursor:pointer;font-weight:700;padding:6px;border-radius:6px }
    /* historial: resaltar o atenuar entradas del historial cuando se busca */
    #recent-history-list li.history-dim { opacity: 0.28; filter: grayscale(50%); }
    #recent-history-list li.history-match { background: linear-gradient(90deg, rgba(59,130,246,0.06), rgba(59,130,246,0.02)); border-left: 4px solid rgba(59,130,246,0.9); padding-left:8px; }
    .color-boxes {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        gap: 8px;
        margin: 0;
        padding: 0;
    }
    .color-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }
    /* usar button para accesibilidad */
    .color-box {
        flex: 1;
        height: 32px;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.16s, box-shadow 0.16s, opacity 0.12s;
        background-clip: padding-box;
        padding: 0 6px;
        border: none;
        box-shadow: 0 6px 16px rgba(3,7,18,0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        color: white;
        font-size: 9px;
        text-align: center;
        line-height: 1.2;
        white-space: normal;
    }

    /* Botones principales (top-controls) — más altos y con acento superior */
    .top-controls .color-box{
        /* Usar anchura fluida dentro de la celda del grid y limitar por max-width */
        width: 100%;
        max-width: var(--top-btn-max-width);
        height: var(--top-btn-height);
        padding: 0 14px;
        font-size: var(--top-btn-font-size);
        letter-spacing: 0.6px;
        font-weight: 700;
        box-shadow: 0 12px 36px rgba(3,7,18,0.16);
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        justify-self: stretch; /* ocupar todo el ancho de la celda */
        align-self: center;
    }
    .top-controls .color-box::before{
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 12px; /* 'grosor' visual arriba */
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        background: linear-gradient(180deg, rgba(255,255,255,0.22), rgba(255,255,255,0.06));
        pointer-events: none;
    }
    .top-controls .color-box:active{ transform: translateY(1px) scale(0.996); }
    .color-box.blue{ box-shadow: 0 8px 30px rgba(59,130,246,0.14), 0 2px 6px rgba(0,0,0,0.25); }
    .color-box.green{ box-shadow: 0 8px 30px rgba(52,211,153,0.12), 0 2px 6px rgba(0,0,0,0.25); }
    .color-box:focus {
        outline: none;
        transform: translateY(-3px) scale(1.03);
        box-shadow: 0 14px 32px rgba(0,0,0,0.12);
    }
    .color-box:active {
        transform: translateY(0) scale(0.98);
        box-shadow: 0 6px 16px rgba(0,0,0,0.1);
    }
    /* drag ghost used during touch/pointer drag */
    .drag-ghost{ position:fixed; pointer-events:none; transform:translate(-50%,-50%); z-index:9999; opacity:0.95; border-radius:6px; box-shadow:0 12px 30px rgba(0,0,0,0.18); }
    /* visual highlight for drop target */
    .btn-drop-target{ box-shadow: 0 0 0 6px rgba(59,130,246,0.12) !important; transform: translateY(-2px) scale(1.02) !important; }
    /* barcode modal */
    .barcode-modal{ position: fixed; left:50%; top:50%; transform:translate(-50%,-50%); background: #fff; border-radius:10px; box-shadow:0 20px 40px rgba(2,6,23,0.18); padding:14px; z-index:13000; width:360px; max-width:92vw; display:none; }
    .barcode-modal.open{ display:block; }
    .barcode-modal h3{ margin:0 0 8px 0; font-size:16px }
    .barcode-modal .scan-list{ max-height:220px; overflow:auto; margin:8px 0; padding:6px; border-radius:6px; background: #f8fafc; }
    .barcode-modal .scan-item{ padding:6px 8px; border-bottom:1px solid rgba(0,0,0,0.04); font-weight:600 }
    .barcode-modal .modal-actions{ display:flex; gap:8px; margin-top:8px }
    .color-box:hover {
        transform: translateY(-6px) scale(1.04);
        filter: saturate(1.08);
    }
    /* ajustar etiqueta debajo del botón para mantenerse legible */
    .color-label {
        font-size: 9px;
        text-align: center;
        color: var(--glass-text);
        font-weight: 600;
        line-height: 1.1;
        max-width: 100%;
    }
    .color-label {
        font-size: 12px;
        text-align: center;
        max-width: 110px;
        color: var(--glass-text);
        font-weight: 500;
    }
    .blue { background-color: #3498db; }
    .green { background-color: #2ecc71; }
    .orange { background-color: #f97316; }
    .status {
        min-height: 16px;
        color: var(--glass-text);
        font-size: 12px;
        margin-top: 10px;
        text-align: center;
    }
    /* resaltar columna seleccionada sin cambiar layout */
    .column.selected {
        box-shadow: 0 20px 50px rgba(59,130,246,0.14), 0 6px 18px rgba(0,0,0,0.1);
        transform: translateY(-8px);
    }
    /* alerta llamativa para líneas vacías */
    .alert {
        width: calc(100% - 80px);
        max-width: 1100px;
        background: linear-gradient(90deg,#e74c3c,#ec7063);
        color: #fff;
        padding: 12px 16px;
        border-radius: 6px;
        box-shadow: 0 6px 18px rgba(231,76,60,0.22);
        font-weight: 700;
        text-align: center;
        margin-bottom: 8px;
        animation: pulse 1.6s ease-in-out infinite;
        position: relative;
        z-index: 9999; /* ensure it's above other elements */
        transition: opacity 220ms ease, transform 260ms ease;
    }
    .alert.hidden { display: none !important; opacity:0 }
    @keyframes pulse {
        0% { transform: translateY(0); box-shadow: 0 6px 18px rgba(0,0,0,0.18); }
        50% { transform: translateY(-4px); box-shadow: 0 10px 24px rgba(0,0,0,0.26); }
        100% { transform: translateY(0); box-shadow: 0 6px 18px rgba(0,0,0,0.18); }
    }
    /* marcar visualmente columnas sin parciales */
    .column.empty {
        border: 3px solid rgba(231,76,60,0.95);
        outline: none;
        box-shadow: 0 14px 34px rgba(231,76,60,0.20), 0 0 0 6px rgba(231,76,60,0.06) inset;
        transform: translateY(-2px);
        transition: box-shadow 260ms ease, transform 260ms ease, border-color 260ms ease;
        position: relative;
    }
    @keyframes pulse-empty {
        0% { box-shadow: 0 10px 26px rgba(231,76,60,0.16), 0 0 0 0 rgba(231,76,60,0); transform: translateY(0); }
        50% { box-shadow: 0 18px 42px rgba(231,76,60,0.28), 0 0 16px rgba(231,76,60,0.08); transform: translateY(-4px); }
        100% { box-shadow: 0 10px 26px rgba(231,76,60,0.16), 0 0 0 0 rgba(231,76,60,0); transform: translateY(0); }
    }
    .column.empty.animate {
        animation: pulse-empty 1.6s ease-in-out infinite;
    }
    /* visual de línea inactiva */
    .column.inactive {
        opacity: 0.44;
        filter: grayscale(70%);
        transform: none !important;
    }
    .inactive-badge{
        position:absolute;
        top:-16px;
        right:8px;
        color:#fff;
        padding:4px 8px;
        border-radius:8px;
        font-size:11px;
        background: rgba(125,31,31,0.92);
        box-shadow: 0 6px 14px rgba(0,0,0,0.15);
    }
    /* toggle switch para activar/desactivar línea */
    .toggle-switch{
        position: absolute; top: -16px; left: 8px;
        width: 48px; height: 24px;
        background: #e5e7eb; border: none; border-radius: 12px;
        cursor: pointer; transition: all 220ms ease;
        display: flex; align-items: center; padding: 0 2px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }
    .toggle-switch.active{ background: #10b981; }
    .toggle-switch::after{
        content: '';
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 50%;
        transition: transform 220ms ease;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }
    .toggle-switch.active::after{ transform: translateX(24px); }
    .toggle-switch:hover{ transform: scale(1.05); }
    /* título con efecto glassmorphism */
    .title {
        font-size: 26px;
        font-weight: 700;
        letter-spacing: -0.5px;
        color: var(--glass-text);
        text-align: center;
        background: linear-gradient(135deg, rgba(255,255,255,0.75), rgba(255,255,255,0.55));
        backdrop-filter: blur(12px) saturate(150%);
        padding: 12px 28px;
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,0.6);
        box-shadow: 0 8px 32px rgba(0,0,0,0.06), inset 0 1px 1px rgba(255,255,255,0.9);
        max-width: 520px;
        margin-top: -10px;
        margin-bottom: 8px;
        background-clip: text;
    }
    .manage-btn{
        margin-top:12px;
        display:inline-block;
        width:100%;
        padding:10px 12px;
        border-radius:10px;
        background: linear-gradient(90deg,var(--accent2), #60a5fa);
        color:white;
        border:none;
        cursor:pointer;
        font-weight:700;
        box-shadow: 0 10px 26px rgba(59,130,246,0.12);
    }
    .manage-btn:active{ transform: translateY(1px) }
    /* panel de reporte de líneas vacías (lista roja) */
    .empty-report{
        width: 280px;
        background: linear-gradient(180deg,#ff1f1f,#e73b3b);
        color: #fff;
        padding: 18px 16px;
        border-radius: 10px;
        box-shadow: 0 14px 36px rgba(231,76,60,0.18);
        font-weight:700;
        text-align: left;
        margin-bottom: 6px;
        display: none;
    }
    .empty-report.show{ display: block; }
    .empty-report h3{ margin:0 0 8px 0; font-size:18px; text-align:center }
    .empty-report ul{ margin:10px 0 0 12px; padding:0; list-style:none }
    .empty-report li{ margin:6px 0; font-weight:700; font-size:15px }
    .empty-report .note{ font-weight:600; font-size:12px; opacity:0.95; margin-top:8px }
    /* panel de gestión embebido (slide-over) */
    .manage-panel{
        position: fixed; right: 0; top: 0; bottom: 0; width: 420px; max-width: 92vw;
        background: #ffffff; box-shadow: -18px 0 40px rgba(2,6,23,0.12); transform: translateX(110%);
        transition: transform 280ms cubic-bezier(.2,.9,.25,1); z-index:12000; padding:18px; overflow:auto;
    }
    .manage-panel.open{ transform: translateX(0); }
    /* make sure controls-area stacks on small screens */
    @media (max-width:900px){
        .controls-area{ flex-direction: column; align-items: stretch }
        .empty-report{ width: 100%; }
        .controls{ width: 100% }
    }
    /* top-right info: current date/time and durations of empty lines */
    .top-info{
        position: static; margin-top:12px; z-index: 2;
        background: rgba(255,255,255,0.95); color:#0f172a; padding:10px 12px; border-radius:10px;
        box-shadow: 0 8px 18px rgba(2,6,23,0.06); font-size:13px; text-align:left;
        width:100%; max-width:100%; box-sizing: border-box; border:1px solid rgba(0,0,0,0.04);
        /* prevent the internal content from forcing the card wider than its parent */
        overflow: hidden;
    }
    .top-info .now{ font-weight:700; font-size:14px }
    .top-info .durations{ margin-top:8px; text-align:left; }
    .top-info .durations ul{ margin:0; padding:6px 8px; list-style:none; max-height:220px; overflow:auto }
    .top-info .durations li{ display:flex; justify-content:space-between; align-items:center; gap:8px; padding:4px 2px; margin:6px 0; box-sizing:border-box; }
    .top-info .durations li span.name{ display:block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:#6b7280; font-weight:600; font-size:13px; }
    .top-info .durations li span.time{ flex-shrink:0; color:#6b7280; font-weight:700; font-size:13px; margin-left:6px; }
    .top-info .durations li.current span.name{ color:#b91c1c; font-weight:800; }
    .top-info .durations li.current span.time{ color:#b91c1c; }
    .top-info .durations li.stopped span.name{ color:#6b7280; font-weight:700; }
    .top-info .durations li.stopped span.time{ color:#6b7280; opacity:0.92; font-weight:700; }
    .manage-panel h2{ margin-top:0 }
    .manage-row{ display:flex; gap:8px; margin-bottom:10px }
    .manage-row input[type=text]{ flex:1; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.08) }
    .manage-row input[type=number]{ width:92px; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.08) }
    .manage-list{ display:flex; flex-direction:column; gap:8px; margin-top:8px }
    .manage-item{ display:flex; gap:8px; align-items:center }
    .manage-item input{ padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.08) }
    .manage-actions{ display:flex; gap:8px; margin-top:12px }
</style>
</head>
<body>
    <!-- (alert banner removed — using red report panel below) -->
    <!-- panel de reporte de líneas vacías (se ubicará junto al panel de controles) -->
    <!-- el elemento se inserta junto a .controls más abajo -->

    <!-- panel embebido de gestión de líneas -->
    <aside id="manage-panel" class="manage-panel" aria-hidden="true">
        <h2>Gestionar líneas</h2>
        <p class="small">Añade, edita o quita líneas. Los cambios se guardan en tu navegador y la vista principal se actualizará automáticamente.</p>
        <div class="manage-row">
            <input id="m-new-name" type="text" placeholder="Nombre nueva línea (ej. PK11)" />
            <button id="m-btn-add" class="btn btn-add">Añadir</button>
        </div>
        <div id="m-lines-list" class="manage-list"></div>
        <div class="manage-actions">
            <button id="m-btn-save" class="btn btn-save">Guardar</button>
            <button id="m-btn-close" class="btn" style="margin-left:auto">Cerrar</button>
        </div>
    </aside>
    <h1 class="title">Estado y solicitud de parciales,kamban descartonado de vidrio</h1>
    <!-- (removed stray closing tag that broke DOM structure) -->
    <script>
    document.addEventListener('DOMContentLoaded', function(){
        const input = document.getElementById('line-name');
        const btnAdd = document.getElementById('btn-entrada');
        const btnRemove = document.getElementById('btn-salida');
        const status = document.getElementById('control-status');

        // Do NOT reset persisted timers on load. Preserve `pk_solicitud_salida` and `pk_empty_since` so
        // durations survive page reloads. Run a small deferred refresh of timer UI to pick up stored values.
        try{ setTimeout(()=>{ try{ ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); window.updateEmptyDurationsDisplay && window.updateEmptyDurationsDisplay(); }catch(e){} }, 50); }catch(e){}

        

        // poblar datalist con las líneas existentes
        function populateDatalist(){
            const dl = document.getElementById('line-list');
            if(!dl) return;
            dl.innerHTML = '';
            const headers = document.querySelectorAll('.container .column .column-header');
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h.textContent.trim();
                dl.appendChild(opt);
            });
        }
        // helper global: append history entries and refresh the recent-history UI
        function addHistoryEntries(entries){
            try{
                if(!Array.isArray(entries) || entries.length === 0) return;
                let hist = [];
                try{ hist = JSON.parse(localStorage.getItem('pk_history')||'[]'); }catch(e){ hist = []; }
                hist = hist.concat(entries || []);
                hist = hist.slice(-200);
                localStorage.setItem('pk_history', JSON.stringify(hist));
                try{ window.historialModule && window.historialModule.renderizar(); }catch(e){}
            }catch(err){ console.error('addHistoryEntries failed', err); }
        }
        // llenar la lista desplegable con las líneas actuales
        populateDatalist();

        // función que detecta líneas sin parciales y muestra alerta
        function checkEmptyLines(){
            // only direct children columns to avoid accidental matches
            const cols = Array.from(document.querySelectorAll('.container > .column'));
            const emptyNames = [];
            // load existing empty timestamps mapping
            let emptySince = {};
            try{ emptySince = JSON.parse(localStorage.getItem('pk_empty_since')||'{}'); }catch(e){ emptySince = {}; }
            let changed = false;
            cols.forEach(c => {
                // skip inactive lines from empty checks
                if(c.classList.contains('inactive')) {
                    const header = (c.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    try{
                        const mapRaw = localStorage.getItem('pk_empty_since');
                        const map = mapRaw ? JSON.parse(mapRaw) : {};
                        if(map[header]){ delete map[header]; localStorage.setItem('pk_empty_since', JSON.stringify(map)); changed = true; }
                    }catch(e){}
                    c.classList.remove('empty');
                    return;
                }
                const blocks = c.querySelectorAll('.block').length;
                const header = (c.querySelector('.column-header')||{textContent:'?'}).textContent.trim();
                if(blocks === 0){
                    c.classList.add('empty');
                    if(header) {
                        emptyNames.push(header);
                        if(!emptySince[header]){ emptySince[header] = Date.now(); changed = true; }
                    }
                } else {
                    c.classList.remove('empty');
                    if(header && emptySince[header]){ delete emptySince[header]; changed = true; }
                }
            });
            // deduplicate and clean names
            const names = Array.from(new Set(emptyNames.map(n=>n.trim()).filter(Boolean)));
            
            // Alert if new lines became empty
            if(names.length > 0){
                const newEmpty = names.filter(n => !emptySince[n] || (emptySince[n] && Date.now() - emptySince[n] < 2000));
                if(newEmpty.length > 0){
                    console.warn('⚠️ Líneas sin parciales detectadas:', newEmpty);
                    // Only alert once per session per line to avoid spam
                    newEmpty.forEach(lineName => {
                        if(!window._emptyLineAlerted) window._emptyLineAlerted = {};
                        if(!window._emptyLineAlerted[lineName]){
                            // Alert user about empty line
                            // (commented out to avoid too many alerts, but logged to console)
                            window._emptyLineAlerted[lineName] = true;
                        }
                    });
                }
            }
            
            // render the red report panel
            const report = document.getElementById('empty-report');
            const list = document.getElementById('empty-report-list');
            if(report && list){
                list.innerHTML = '';
                if(names.length > 0){
                    names.forEach(n=>{
                        const li = document.createElement('li'); li.textContent = n; list.appendChild(li);
                    });
                    report.classList.add('show');
                    report.setAttribute('aria-hidden','false');
                } else {
                    report.classList.remove('show');
                    report.setAttribute('aria-hidden','true');
                    list.innerHTML = '';
                }
            }
            // persist empty timestamps if changed
            try{ if(changed) localStorage.setItem('pk_empty_since', JSON.stringify(emptySince)); }catch(e){}
            // update durations display
            try{ updateEmptyDurationsDisplay(); }catch(e){}
        }
        // ejecutar la comprobación inicial
        checkEmptyLines();

        // desactivar selección por click sobre la cabecera: la única forma de abastecer Kamban
        // será mediante el botón "ABASTECER KAMBAN" (btn-entrada) que abre la ventana/modal.
        function setupHeaderClicks(){
            const headers = document.querySelectorAll('.container .column .column-header');
            headers.forEach(h => {
                // ensure header does not indicate clickability
                h.style.cursor = 'default';
                // remove any inline onclick handlers if present
                try{ h.onclick = null; }catch(e){}
            });
            // add a single capture-phase guard to prevent header clicks from triggering other handlers
            try{
                if(!window._headerClickGuardAdded){
                    document.addEventListener('click', function(e){
                        const hh = e.target && e.target.closest && e.target.closest('.column-header');
                        if(hh){
                            e.stopPropagation();
                            e.preventDefault();
                            // no-op: prevent using header to select or open modals
                        }
                    }, true);
                    window._headerClickGuardAdded = true;
                }
            }catch(e){ console.warn('failed to add header click guard', e); }
        }
        setupHeaderClicks();
        // setup selection of parciales (blocks)
        function setupBlockSelection(){
            const blocks = document.querySelectorAll('.container .column .block');
            blocks.forEach(b => {
                b.style.cursor = 'pointer';
                // remove any existing handler we may have attached earlier
                if(b._selectHandler) b.removeEventListener('click', b._selectHandler);
                b._selectHandler = function(e){
                    // only allow selecting visible, non-inactive columns
                    const col = b.closest('.column');
                    if(col && col.classList.contains('inactive')) return;
                    // ensure this block has correct data attributes before toggling
                    try{
                        const lineName = (col && col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                        if(!b.hasAttribute('data-line')) b.setAttribute('data-line', lineName);
                        // compute index if missing or inconsistent
                        if(!b.hasAttribute('data-index')){
                            const siblings = Array.from(col.querySelectorAll('.block'));
                            const idx = siblings.indexOf(b);
                            b.setAttribute('data-index', String(idx));
                        }
                    }catch(err){ console.warn('ensure data attrs failed', err); }
                    // enforce single selection: deselect others, then toggle this one
                    try{ document.querySelectorAll('.block.selected-parcial').forEach(x=>{ if(x!==b) x.classList.remove('selected-parcial'); }); }catch(e){}
                    if(b.classList.contains('selected-parcial')){
                        // if already selected, unselect it (no selection)
                        b.classList.remove('selected-parcial');
                    } else {
                        // select this block only
                        b.classList.add('selected-parcial');
                    }
                    // update status: show how many selected
                    try{
                        const count = document.querySelectorAll('.block.selected-parcial').length;
                        if(count === 0) status.textContent = '';
                        else status.textContent = `${count} parcial(es) seleccionado(s).`;
                    }catch(e){}
                };
                b.addEventListener('click', b._selectHandler);
                // pointer/touch drag support: start drag on pointerdown
                if(b._pointerDownHandler) b.removeEventListener('pointerdown', b._pointerDownHandler);
                b._pointerDownHandler = function(ev){
                    try{ startDrag(b, ev); }catch(err){ console.warn('drag start failed', err); }
                };
                b.addEventListener('pointerdown', b._pointerDownHandler);
                // touch fallback for devices that don't support Pointer Events
                if(b._touchStartHandler) b.removeEventListener('touchstart', b._touchStartHandler);
                b._touchStartHandler = function(ev){
                    try{
                        // prevent default to avoid page scroll while dragging
                        if(ev.cancelable) ev.preventDefault();
                        // pass the touch event to the same startDrag function
                        startDrag(b, ev);
                    }catch(err){ console.warn('touch drag start failed', err); }
                };
                b.addEventListener('touchstart', b._touchStartHandler, { passive: false });
            });
        }
        setupBlockSelection();

        function findColumn(name){
            if(!name) return null;
            const cols = document.querySelectorAll('.container .column');
            const target = Array.from(cols).find(col => {
                const h = col.querySelector('.column-header');
                return h && h.textContent.trim().toLowerCase() === name.trim().toLowerCase();
            });
            return target || null;
        }

        // Drag and drop (pointer/touch) for blocks - drop on ABASTECER AB (btn-salida)
        let _dragState = null;
        const btnSalida = document.getElementById('btn-salida');

        function startDrag(block, ev){
            if(_dragState) return; // prevent nested drags
            // only start if primary button / primary pointer
            if(ev && ev.button && ev.button !== 0) return;
            ev.preventDefault && ev.preventDefault();
            // compute which blocks will be dragged: selected group or the single block
            // only allow one selected block: if exists use it, otherwise use the clicked block
            const selected = document.querySelector('.block.selected-parcial');
            const dragged = selected ? [selected] : [block];

            // create ghost element
            const ghost = block.cloneNode(true);
            ghost.classList.add('drag-ghost');
            ghost.style.width = Math.max(52, block.offsetWidth) + 'px';
            ghost.style.height = Math.max(32, block.offsetHeight) + 'px';
            document.body.appendChild(ghost);

            _dragState = { dragged, ghost, pointerId: ev.pointerId || null };

            // capture pointer for the initiating block if possible
            try{ if(ev.target && ev.pointerId) ev.target.setPointerCapture && ev.target.setPointerCapture(ev.pointerId); }catch(e){}

            // initial position
            const x = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || 0;
            const y = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 0;
            _dragState.ghost.style.left = x + 'px'; _dragState.ghost.style.top = y + 'px';

            // attach move/up listeners on document
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('pointercancel', onPointerUp);
            // touch fallbacks
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd);
            document.addEventListener('touchcancel', onTouchEnd);
            // small visual cue on target
            if(btnSalida) btnSalida.classList.add('drop-ready');
        }

        function onTouchMove(ev){
            if(!ev || !ev.touches || ev.touches.length === 0) return;
            // prevent native scrolling while dragging
            if(ev.cancelable) ev.preventDefault();
            const t = ev.touches[0];
            onPointerMove({ clientX: t.clientX, clientY: t.clientY });
        }

        function onTouchEnd(ev){
            // use changedTouches for end coordinate if available
            const t = (ev && ev.changedTouches && ev.changedTouches[0]) || (ev && ev.touches && ev.touches[0]) || null;
            const fake = t ? { clientX: t.clientX, clientY: t.clientY } : (ev || {});
            onPointerUp(fake);
        }

        function onPointerMove(ev){
            if(!_dragState) return;
            const x = ev.clientX; const y = ev.clientY;
            if(_dragState.ghost){ _dragState.ghost.style.left = x + 'px'; _dragState.ghost.style.top = y + 'px'; }
            // highlight drop target if hovering
            if(btnSalida){
                const el = document.elementFromPoint(x, y);
                if(el && (el === btnSalida || btnSalida.contains(el))){ btnSalida.classList.add('btn-drop-target'); }
                else btnSalida.classList.remove('btn-drop-target');
            }
        }

        function onPointerUp(ev){
            if(!_dragState) return;
            const x = ev.clientX; const y = ev.clientY;
            // determine drop target
            let dropEl = document.elementFromPoint(x,y);
            const isOnBtn = dropEl && (dropEl === btnSalida || (btnSalida && btnSalida.contains(dropEl)));
                if(isOnBtn){
                    // perform abastecer-ab for all dragged blocks: collect info, save history, remove nodes,
                    // set solicitud+salida for their lines (now) and rebuild requested map from DOM.
                    const now = Date.now();
                    // collect unique dragged elements
                    const uniq = Array.from(new Set(_dragState.dragged || []));
                    // collect metadata for each dragged block BEFORE removing it
                    const removedBlocks = uniq.map(b => {
                        try{
                            const col = b.closest('.column');
                            const line = (col && col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                            const idx = parseInt(b.getAttribute('data-index')||'-1',10);
                            const name = b.getAttribute('data-name') || ((b.querySelector('.label')||{}).textContent||'').trim();
                            return { el: b, line, index: idx, name };
                        }catch(e){ return null; }
                    }).filter(Boolean);
                    const lines = Array.from(new Set(removedBlocks.map(r=>r.line))).filter(Boolean);

                    // load solicitud map BEFORE overwriting so we can compute durations
                    let solicitudMap = {};
                    try{ solicitudMap = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ solicitudMap = {}; }

                    // load existing history, append new entries for each removed block
                    let newEntries = [];
                    removedBlocks.forEach(rb => {
                        try{
                            const prevSolic = solicitudMap[rb.line] && solicitudMap[rb.line].solicitud ? parseInt(solicitudMap[rb.line].solicitud,10) : null;
                            const duration = prevSolic ? Math.max(0, now - prevSolic) : 0;
                            newEntries.push({ name: rb.name || (`${rb.line}#${rb.index}`), line: rb.line, index: rb.index, requestedAt: prevSolic || now, suppliedAt: now, duration });
                        }catch(e){}
                    });
                    // persist via helper so view is refreshed
                    try{ addHistoryEntries(newEntries); }catch(e){}

                    // remove dragged blocks from DOM
                    try{ uniq.forEach(b => { try{ if(b && b.parentNode) b.parentNode.removeChild(b); }catch(e){} }); }catch(e){}

                    // after removals, ensure attributes are consistent and rebuild names mapping
                    try{ ensureBlockDataAttributes(); rebuildBlockNamesFromDOM(); }catch(e){}

                    // update solicitud map for affected lines: set solicitud+salida = now
                    lines.forEach(lineName => {
                        if(!lineName) return;
                        solicitudMap[lineName] = solicitudMap[lineName] || {};
                        solicitudMap[lineName].solicitud = now;
                        solicitudMap[lineName].salida = now;
                    });
                    try{ localStorage.setItem('pk_solicitud_salida', JSON.stringify(solicitudMap)); }catch(e){}

                    // rebuild requested map based on remaining DOM (removes requested indices that no longer exist)
                    try{ rebuildRequestedFromDOM(); }catch(e){}
                    // persist current lines state (counts, active)
                    try{ saveState(); }catch(e){}
                    // apply UI updates
                    try{ applyRequestedToDOM(); ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); window.historialModule && window.historialModule.renderizar(); }catch(e){}
                    
                    // Mostrar notificación de éxito después de drag-drop
                    setTimeout(()=>{
                        try{ 
                            const status = document.getElementById('control-status');
                            if(status){
                                status.style.display = 'block';
                                status.textContent = '✅ Parcial abastecido correctamente'; 
                                alert('✅ Parcial abastecido correctamente');
                                setTimeout(()=>{ 
                                    status.textContent = ''; 
                                    status.style.display = 'none';
                                }, 3000); 
                            }
                        }catch(e){}
                    }, 300);
                }

            // cleanup
            try{ if(_dragState.ghost) _dragState.ghost.remove(); }catch(e){}
            if(btnSalida) btnSalida.classList.remove('btn-drop-target','drop-ready');
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);
            document.removeEventListener('pointercancel', onPointerUp);
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onTouchEnd);
            document.removeEventListener('touchcancel', onTouchEnd);
            _dragState = null;
        }

        function addPartial(name){
            // backward-compatible signature: addPartial(lineName, blockLabel)
            const lineName = name;
            const blockLabel = arguments.length > 1 ? arguments[1] : undefined;
            const col = findColumn(lineName);
            if(!col){
                status.textContent = `Línea "${lineName}" no encontrada.`;
                return;
            }
            if(col.classList.contains('inactive')){
                status.textContent = `Línea "${name}" está inactiva. No se pueden añadir parciales.`;
                return;
            }
            const block = document.createElement('div');
            block.className = 'block appear';
            // set data attributes so persistence works
                // cleanup requested map: remove any requested indices >= new count
                try{
                    const lineName = name;
                    const map = getRequestedMap();
                    const arr = Array.isArray(map[lineName]) ? map[lineName] : [];
                    const newCount = col.querySelectorAll('.block').length;
                    const cleaned = arr.filter(i => i < newCount);
                    if(cleaned.length > 0) map[lineName] = cleaned; else delete map[lineName];
                    saveRequestedMap(map);
                }catch(e){}
            const idx = col.querySelectorAll('.block').length; // next index
                try{ saveState(); }catch(e){ /* ignore */ }
            block.setAttribute('data-index', String(idx));
            if(blockLabel){
                block.setAttribute('data-name', blockLabel);
                const span = document.createElement('span'); span.className = 'label'; span.textContent = blockLabel; block.appendChild(span);
                // persist name in pk_block_names
                try{
                    const names = JSON.parse(localStorage.getItem('pk_block_names')||'{}');
                    names[lineName] = names[lineName] || {};
                    names[lineName][String(idx)] = blockLabel;
                    localStorage.setItem('pk_block_names', JSON.stringify(names));
                }catch(e){}
            }
            // if this index is in requested map, mark requested
            try{
                const map = getRequestedMap();
                const arr = Array.isArray(map[lineName]) ? map[lineName] : [];
                if(arr.indexOf(idx) !== -1) block.classList.add('requested');
            }catch(e){}
            col.appendChild(block);
            // ensure the newly created block gets the selection/drag handlers
            try{ setupBlockSelection && setupBlockSelection(); }catch(e){ console.warn('setupBlockSelection failed for new block', e); }
            // quitar la clase appear después de la animación
            setTimeout(()=>{ try{ block.classList.remove('appear'); }catch(e){} }, 420);
            // pequeño pulso visual en la columna
            try{ col.animate([{ transform: 'scale(1)' },{ transform: 'scale(1.02)' }, { transform: 'scale(1)'}], { duration: 260, easing: 'ease-out' }); }catch(e){}
            status.textContent = `Agregado parcial a ${name}. Total: ${col.querySelectorAll('.block').length}`;
            checkEmptyLines();
            // persist change so it survives reloads
            try{ saveState(); }catch(e){ /* ignore */ }
            // re-apply requested map just in case
            try{ applyRequestedToDOM(); }catch(e){}
        }

        function removePartial(name){
            const col = findColumn(name);
            if(!col){
                status.textContent = `Línea "${name}" no encontrada.`;
                return;
            }
            if(col.classList.contains('inactive')){
                status.textContent = `Línea "${name}" está inactiva. No se pueden quitar parciales.`;
                return;
            }
            const blocks = col.querySelectorAll('.block');
            if(blocks.length === 0){
                status.textContent = `No hay parciales para eliminar en ${name}.`;
                return;
            }
            const last = blocks[blocks.length-1];
            // animar eliminación y luego remover
            last.classList.add('removing');
            setTimeout(()=>{
                try{ last.remove(); }catch(e){}
                status.textContent = `Eliminado parcial de ${name}. Restan: ${col.querySelectorAll('.block').length}`;
                checkEmptyLines();
                // persist change so it survives reloads
                try{ saveState(); rebuildBlockNamesFromDOM(); }catch(e){ /* ignore */ }
            }, 260);
        }

        btnAdd.addEventListener('click', ()=>{
            // Open modal to allow manual naming via scanner or quick add
            openBarcodeModal(input.value);
        });

        btnRemove.addEventListener('click', ()=>{
            try{
                const lineName = (input.value||'').trim();
                if(lineName){
                    // capture last block info for history BEFORE removing
                    const col = findColumn(lineName);
                    let lastInfo = null;
                    if(col){
                        const blocks = col.querySelectorAll('.block');
                        if(blocks.length > 0){
                            const last = blocks[blocks.length-1];
                            const idx = parseInt(last.getAttribute('data-index')||'-1',10);
                            const name = last.getAttribute('data-name') || ((last.querySelector('.label')||{}).textContent||'').trim();
                            lastInfo = { line: lineName, index: idx, name };
                        }
                    }

                    // compute duration based on existing solicitud timestamp and save history entry
                    const now = Date.now();
                    let solicitudMap = {};
                    try{ solicitudMap = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ solicitudMap = {}; }
                    let history = [];
                    try{ history = JSON.parse(localStorage.getItem('pk_history')||'[]'); }catch(e){ history = []; }
                    if(lastInfo){
                            const prevSolic = solicitudMap[lastInfo.line] && solicitudMap[lastInfo.line].solicitud ? parseInt(solicitudMap[lastInfo.line].solicitud,10) : null;
                            const duration = prevSolic ? Math.max(0, now - prevSolic) : 0;
                            try{ addHistoryEntries([{ name: lastInfo.name || (lastInfo.line + '#' + lastInfo.index), line: lastInfo.line, index: lastInfo.index, requestedAt: prevSolic || now, suppliedAt: now, duration }]); }catch(e){}
                    }

                    // actually remove the partial (keeps same behavior with animation)
                    removePartial(lineName);

                    // Mostrar notificación de éxito DESPUÉS de la animación de removePartial (260ms)
                    setTimeout(()=>{
                        try{ 
                            status.style.display = 'block';
                            status.textContent = '✅ Parcial abastecido correctamente'; 
                            alert('✅ Parcial abastecido correctamente');
                            setTimeout(()=>{ 
                                status.textContent = ''; 
                                status.style.display = 'none';
                            }, 3000); 
                        }catch(e){}
                    }, 300);
                }
            }catch(e){ console.error('btnRemove error', e); }
            input.focus();
        });

        // enter key in input triggers add
        input.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter'){
                e.preventDefault();
                addPartial(input.value);
            }
        });

        /** RENDER / STORAGE SYNC **/
        // render columns from an array of {name, count, active}
        function renderColumns(lines){
            const container = document.querySelector('.container');
            if(!container) return;
            container.innerHTML = '';
            lines.forEach(line => {
                const col = document.createElement('div');
                col.className = 'column';
                if(line.active === false){
                    col.classList.add('inactive');
                }
                // toggle switch for activate/deactivate
                const toggle = document.createElement('button');
                toggle.className = 'toggle-switch';
                if(line.active !== false) toggle.classList.add('active');
                toggle.type = 'button';
                toggle.title = line.active !== false ? 'Clic para desactivar' : 'Clic para activar';
                toggle.addEventListener('click', (e)=>{
                    e.stopPropagation();
                    // toggle active status in storage
                    try{
                        const raw = localStorage.getItem('pk_lines') || '[]';
                        const stored = JSON.parse(raw);
                        const idx = stored.findIndex(l => l.name === line.name);
                        if(idx >= 0){
                            stored[idx].active = !(stored[idx].active !== false);
                            localStorage.setItem('pk_lines', JSON.stringify(stored));
                            // apply immediately
                            try{ if(window.applyLinesToDOM) window.applyLinesToDOM(stored); }catch(e){}
                            window.dispatchEvent(new StorageEvent('storage', {key:'pk_lines'}));
                        }
                    }catch(e){ console.error('toggle failed', e); }
                });
                col.appendChild(toggle);
                
                const h = document.createElement('div');
                h.className = 'column-header';
                h.textContent = line.name;
                // add a small timer element under the header to show solicitud/salida durations
                const timer = document.createElement('div');
                timer.className = 'sol-timer';
                timer.textContent = '';
                col.appendChild(h);
                col.appendChild(timer);
                if(line.active === false){
                    const badge = document.createElement('div');
                    badge.className = 'inactive-badge';
                    badge.textContent = 'INACTIVA';
                    col.appendChild(badge);
                }
                for(let i=0;i< (line.count||0); i++){
                    const b = document.createElement('div');
                    b.className = 'block';
                    // mark which line and index this block belongs to so we can persist "requested" state
                    b.setAttribute('data-line', line.name);
                    b.setAttribute('data-index', String(i));
                    // if we have a saved name for this block, set it
                    try{
                        const namesMap = JSON.parse(localStorage.getItem('pk_block_names')||'{}');
                        const nm = namesMap[line.name] && namesMap[line.name][String(i)];
                        if(nm){ b.setAttribute('data-name', nm); const span = document.createElement('span'); span.className='label'; span.textContent = nm; b.appendChild(span); }
                    }catch(e){}
                    // if this block index is present in requested map, add requested class
                    try{
                        const reqRaw = localStorage.getItem('pk_requested') || '{}';
                        const reqMap = reqRaw ? JSON.parse(reqRaw) : {};
                        const arr = Array.isArray(reqMap[line.name]) ? reqMap[line.name] : [];
                        if(arr.indexOf(i) !== -1) b.classList.add('requested');
                    }catch(e){ }
                    col.appendChild(b);
                }
                container.appendChild(col);
            });
            // re-run header click setup so newly rendered headers are interactive
            setupHeaderClicks && setupHeaderClicks();
            setupBlockSelection && setupBlockSelection();
            populateDatalist && populateDatalist();
            checkEmptyLines && checkEmptyLines();

            

            // ADJUST container width so the white background expands to fit the columns
            try{
                // remove CSS max-width restriction so we can size freely
                container.style.maxWidth = 'none';
                const cols = container.querySelectorAll('.column');
                if(cols.length > 0){
                    const first = cols[0];
                    // measure a single column's rendered width
                    const colW = first.offsetWidth || (parseFloat(getComputedStyle(first).minWidth) || 122);
                    const gap = parseFloat(getComputedStyle(container).gap) || 9;
                    const cs = getComputedStyle(container);
                    const padL = parseFloat(cs.paddingLeft) || 0;
                    const padR = parseFloat(cs.paddingRight) || 0;
                    // use fluid width so columns distribute across available viewport
                    container.style.maxWidth = '100%';
                    container.style.width = '100%';
                }
            }catch(e){ console.warn('renderColumns: width adjust failed', e); }
        }

        // Persist current DOM state (name + count + active) to localStorage so changes survive reload
        function getStateFromDOM(){
            try{
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                return cols.map(c => {
                    const name = (c.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const count = c.querySelectorAll('.block').length;
                    const active = !c.classList.contains('inactive');
                    return { name, count, active };
                });
            }catch(e){ console.error('getStateFromDOM', e); return []; }
        }

        // Requested parciales persistence helpers
        function getRequestedMap(){
            try{ return JSON.parse(localStorage.getItem('pk_requested')||'{}'); }catch(e){ return {}; }
        }
        function saveRequestedMap(map){
            try{ localStorage.setItem('pk_requested', JSON.stringify(map)); }catch(e){}
        }
        // ensure requested classes are applied to blocks currently in the DOM
        function applyRequestedToDOM(){
            try{
                const map = getRequestedMap();
                const blocks = document.querySelectorAll('.container .column .block');
                blocks.forEach(b => {
                    const line = b.getAttribute('data-line') || ((b.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const idx = parseInt(b.getAttribute('data-index')||'-1',10);
                    if(line && Number.isFinite(idx)){
                        const arr = Array.isArray(map[line]) ? map[line] : [];
                        if(arr.indexOf(idx) !== -1) b.classList.add('requested'); else b.classList.remove('requested');
                    }
                });
            }catch(e){}
        }

        // Ensure each column has a sol-timer element for showing solicitud/salida durations
        function ensureTimerElements(){
            try{
                console.log('ensureTimerElements: scanning columns for .sol-timer');
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                cols.forEach(col => {
                    if(!col.querySelector('.sol-timer')){
                        const timer = document.createElement('div');
                        timer.className = 'sol-timer';
                        timer.textContent = '';
                        // insert after header if header exists
                        const hdr = col.querySelector('.column-header');
                        if(hdr && hdr.nextSibling) col.insertBefore(timer, hdr.nextSibling);
                        else if(hdr) col.appendChild(timer);
                        else col.insertBefore(timer, col.firstChild);
                        console.log('ensureTimerElements: created .sol-timer for', (hdr||{}).textContent);
                    }
                });
            }catch(e){ console.error('ensureTimerElements error', e); }
        }

        // Rebuild pk_requested from DOM requested classes (keeps indices consistent after removals)
        function rebuildRequestedFromDOM(){
            try{
                const map = {};
                const blocks = document.querySelectorAll('.container .column .block.requested');
                blocks.forEach(b => {
                    try{
                        const line = (b.getAttribute('data-line') || ((b.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent).trim();
                        const idx = parseInt(b.getAttribute('data-index')||'-1',10);
                        if(!line || !Number.isFinite(idx) || idx < 0) return;
                        map[line] = map[line] || [];
                        map[line].push(idx);
                    }catch(e){}
                });
                Object.keys(map).forEach(k=> map[k].sort((a,b)=>a-b));
                try{ localStorage.setItem('pk_requested', JSON.stringify(map)); }catch(e){}
                return map;
            }catch(e){ return {}; }
        }

        // Rebuild pk_block_names from DOM (used after removals or reindexing)
        function rebuildBlockNamesFromDOM(){
            try{
                const map = {};
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                cols.forEach(col => {
                    const line = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    if(!line) return;
                    const blocks = Array.from(col.querySelectorAll('.block'));
                    blocks.forEach((b,i)=>{
                        const nm = b.getAttribute('data-name') || ((b.querySelector('.label')||{}).textContent||'').trim();
                        if(nm) {
                            map[line] = map[line] || {};
                            map[line][String(i)] = nm;
                            // ensure data-index up to date
                            b.setAttribute('data-index', String(i));
                            b.setAttribute('data-line', line);
                        }
                    });
                });
                try{ localStorage.setItem('pk_block_names', JSON.stringify(map)); }catch(e){}
                return map;
            }catch(e){ return {}; }
        }

        // Barcode modal logic
        function openBarcodeModal(prefillLine){
            try{
                const modal = document.getElementById('barcode-modal');
                const lineInput = document.getElementById('barcode-line-input');
                const scanInput = document.getElementById('barcode-input');
                const list = document.getElementById('barcode-scan-list');
                if(!modal || !scanInput) return;
                modal.classList.add('open'); modal.setAttribute('aria-hidden','false');
                if(prefillLine) lineInput.value = prefillLine;
                list.innerHTML = '';
                scanInput.value = '';
                scanInput.focus();

                function addScanned(name){
                    const lineName = (lineInput.value||'').trim() || input.value;
                    if(!lineName) { alert('Selecciona o escribe la línea antes.'); return; }
                    // add a new partial with this name
                    addPartial(lineName, name);
                    try{ ensureBlockDataAttributes(); rebuildBlockNamesFromDOM(); applyRequestedToDOM(); ensureTimerElements(); updateColumnTimers(); }catch(e){}
                    // close modal immediately after adding
                    try{ closeModal(); }catch(err){ /* closeModal is defined below */ }
                }

                function onKey(e){
                    if(e.key === 'Enter'){
                        const val = scanInput.value.trim();
                        if(val) { addScanned(val); scanInput.value = ''; }
                        e.preventDefault();
                    }
                }

                scanInput.addEventListener('keydown', onKey);

                // populate lines list inside the details so user can pick existing line quickly
                try{
                    const ul = document.getElementById('barcode-lines-ul');
                    ul.innerHTML = '';
                    // prefer stored pk_lines, fallback to DOM
                    let lines = [];
                    try{ lines = JSON.parse(localStorage.getItem('pk_lines')||'[]'); }catch(e){}
                    if(!Array.isArray(lines) || lines.length === 0){
                        try{ lines = Array.from(document.querySelectorAll('.container > .column')).map(c => ({ name: (c.querySelector('.column-header')||{textContent:''}).textContent.trim() })); }catch(e){}
                    }
                    lines.forEach(l => {
                        const li = document.createElement('li');
                        li.textContent = (l && l.name) ? l.name : (typeof l === 'string' ? l : '');
                        li.style.padding = '6px';
                        li.style.cursor = 'pointer';
                        li.addEventListener('click', ()=>{ document.getElementById('barcode-line-input').value = li.textContent; document.getElementById('barcode-input').focus(); try{ const d = document.getElementById('barcode-lines-list'); if(d && d.open) d.open = false; }catch(e){} });
                        ul.appendChild(li);
                    });
                }catch(e){ }

                // cancel
                const cancel = document.getElementById('barcode-cancel');
                const closeModal = function(){ try{ scanInput.removeEventListener('keydown', onKey); }catch(e){}; modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); try{ input.focus(); }catch(e){} };
                function onCancel(){ closeModal(); }
                cancel && cancel.addEventListener('click', onCancel);
            }catch(e){ console.error('openBarcodeModal failed', e); }
        }

        function formatDurationShort(ms){
            if(!ms || ms < 0) return '0s';
            const s = Math.floor(ms/1000);
            const hh = Math.floor(s/3600); const mm = Math.floor((s%3600)/60); const ss = s%60;
            if(hh>0) return `${hh}h ${mm}m ${ss}s`;
            if(mm>0) return `${mm}m ${ss}s`;
            return `${ss}s`;
        }

        // Update per-column timers based on pk_solicitud_salida entries
        function updateColumnTimers(){
            try{
                const map = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}');
                console.log('updateColumnTimers: map keys', Object.keys(map));
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                cols.forEach(col => {
                    const name = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const timerEl = col.querySelector('.sol-timer');
                    if(!timerEl) return;
                    const entry = map[name];
                    if(entry && entry.solicitud){
                        const solicitud = parseInt(entry.solicitud,10) || 0;
                        const salida = entry.salida ? (parseInt(entry.salida,10)||0) : 0;
                        if(solicitud && !salida){
                            timerEl.textContent = 'Solicitado: ' + formatDurationShort(Date.now() - solicitud);
                            try{ console.log('updateColumnTimers active:', name, Date.now() - solicitud); }catch(e){}
                        } else if(solicitud && salida){
                            timerEl.textContent = 'Tiempo: ' + formatDurationShort(salida - solicitud);
                        } else timerEl.textContent = '';
                    } else {
                        timerEl.textContent = '';
                    }
                });
            }catch(e){ console.error('updateColumnTimers error', e); }
        }

        // start interval to refresh column timers (and keep a quick initial update)
        try{
            console.log('starting column timers interval');
            // store interval id in window for debugging/ability to clear
            window._colTimersInterval = setInterval(()=>{ try{ ensureTimerElements(); updateColumnTimers(); }catch(e){ console.error('timer interval error', e); } }, 1000);
            console.log('column timers interval id:', window._colTimersInterval);
        }catch(e){ console.error('failed to start timers interval', e); }

        // expose functions for manual debugging in console
        try{ window.ensureTimerElements = ensureTimerElements; window.updateColumnTimers = updateColumnTimers; }catch(e){ }
        // expose requested-map helpers to other scripts (they run in separate script blocks)
        try{ window.getRequestedMap = getRequestedMap; window.saveRequestedMap = saveRequestedMap; window.applyRequestedToDOM = applyRequestedToDOM; window.ensureBlockDataAttributes = ensureBlockDataAttributes; }catch(e){ }

        // Ensure existing static DOM blocks have `data-line` and `data-index` attributes
        function ensureBlockDataAttributes(){
            try{
                const cols = Array.from(document.querySelectorAll('.container > .column'));
                cols.forEach(col => {
                    const lineName = (col.querySelector('.column-header')||{textContent:''}).textContent.trim();
                    const blocks = Array.from(col.querySelectorAll('.block'));
                    blocks.forEach((b, i) => {
                        if(!b.hasAttribute('data-line')) b.setAttribute('data-line', lineName);
                        if(!b.hasAttribute('data-index')) b.setAttribute('data-index', String(i));
                    });
                });
            }catch(e){}
        }

        function saveState(){
            try{
                const state = getStateFromDOM();
                localStorage.setItem('pk_lines', JSON.stringify(state));
                // no need to dispatch storage event here; other tabs will receive native event
            }catch(e){ console.error('saveState', e); }
        }

        // load lines from localStorage and render
        function loadLinesFromStorage(){
            try{
                const raw = localStorage.getItem('pk_lines');
                if(!raw) return false;
                const lines = JSON.parse(raw);
                if(Array.isArray(lines)){
                    renderColumns(lines);
                    return true;
                }
            }catch(e){ console.error('loadLinesFromStorage', e); }
            return false;
        }

        // expose a helper so other scripts (manage panel) can apply lines directly without reloading
        window.applyLinesToDOM = function(lines){
            try{ renderColumns(lines); populateDatalist && populateDatalist(); setupHeaderClicks && setupHeaderClicks(); setupBlockSelection && setupBlockSelection(); checkEmptyLines && checkEmptyLines(); }catch(e){ console.warn('applyLinesToDOM failed', e); }
        };

        // listen to storage changes from manage page
        window.addEventListener('storage', (e)=>{
            if(e.key === 'pk_lines'){
                loadLinesFromStorage();
                try{ ensureBlockDataAttributes(); applyRequestedToDOM(); ensureTimerElements(); updateColumnTimers(); }catch(e){}
            }
            // if requested map changed in another tab, reapply requested state and timers
            if(e.key === 'pk_requested' || e.key === 'pk_solicitud_salida'){
                try{ ensureBlockDataAttributes(); applyRequestedToDOM(); ensureTimerElements(); updateColumnTimers(); }catch(e){}
            }
        });

        // initial attempt to load from storage; if none, keep static DOM
        loadLinesFromStorage();
        // ensure static DOM blocks have data attributes, then apply requested state and show timers
        try{ ensureBlockDataAttributes(); applyRequestedToDOM(); ensureTimerElements(); updateColumnTimers(); }catch(e){}

    });
    </script>
    <!-- Firebase realtime sync (Firestore) - inicialización y listeners -->
    <!-- SDKs: compat version to integrate easily with existing inline scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script>
    (function(){
        // Config proporcionada por el usuario (desde la consola Firebase)
        const firebaseConfig = {
          apiKey: "AIzaSyDhSuWPakadOZcsTiSwy_JMfTyZ-ML4eI4",
          authDomain: "indexvidrio.firebaseapp.com",
          projectId: "indexvidrio",
          storageBucket: "indexvidrio.firebasestorage.app",
          messagingSenderId: "937199809438",
          appId: "1:937199809438:web:13a7e19799fd16f08edc8f",
          measurementId: "G-R0R2V42V1R"
        };

        try{
            firebase.initializeApp(firebaseConfig);
        }catch(e){ console.warn('Firebase init warning', e); }

        const auth = firebase.auth();
        const db = firebase.firestore();

        // Sign in anonymously so Firestore rules that require auth work during testing
        auth.signInAnonymously().catch(e=>{ console.warn('Firebase anonymous auth failed', e); });

        const stateDoc = db.collection('ui').doc('pk_state');

        // Listener en tiempo real: cuando cambie el documento remoto, aplicamos cambios al DOM
        stateDoc.onSnapshot(doc => {
            if(!doc.exists) return;
            const data = doc.data() || {};
            try{
                if(data.pk_lines && window.applyLinesToDOM) window.applyLinesToDOM(data.pk_lines);
            }catch(e){ console.error('applyLinesToDOM error', e); }
            try{
                if(data.pk_requested){
                    localStorage.setItem('pk_requested', JSON.stringify(data.pk_requested));
                    if(window.applyRequestedToDOM) window.applyRequestedToDOM();
                }
            }catch(e){ console.error('applyRequested error', e); }
            try{
                if(data.pk_solicitud_salida){
                    localStorage.setItem('pk_solicitud_salida', JSON.stringify(data.pk_solicitud_salida));
                    if(window.ensureTimerElements) window.ensureTimerElements();
                    if(window.updateColumnTimers) window.updateColumnTimers();
                    if(window.updateSolicitudDurationsDisplay) window.updateSolicitudDurationsDisplay();
                }
            }catch(e){ console.error('applySolicitud error', e); }
        }, err => console.error('stateDoc snapshot error', err));

        // Debounced save to avoid escrituras masivas
        let _saveTimeout = null;
        function saveStateToRemoteDebounced(state){
            if(_saveTimeout) clearTimeout(_saveTimeout);
            _saveTimeout = setTimeout(()=>{
                try{ stateDoc.set(state, { merge: true }).catch(e=>console.error('remote set failed', e)); }catch(e){ console.error(e); }
            }, 420);
        }

        // Exponer helper global para guardar el estado actual en remoto
        window.saveStateToRemote = function(){
            try{
                const state = {
                    pk_lines: window.getStateFromDOM ? window.getStateFromDOM() : JSON.parse(localStorage.getItem('pk_lines')||'[]'),
                    pk_requested: JSON.parse(localStorage.getItem('pk_requested')||'{}'),
                    pk_solicitud_salida: JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}')
                };
                saveStateToRemoteDebounced(state);
            }catch(e){ console.error('saveStateToRemote wrapper failed', e); }
        };

        // Hookear funciones locales para que también persistan al remoto
        try{
            const originalSave = window.saveState;
            window.saveState = function(){
                try{ if(typeof originalSave === 'function') originalSave(); }catch(e){ console.warn('original saveState failed', e); }
                try{ window.saveStateToRemote(); }catch(e){ console.warn('saveStateToRemote failed', e); }
            };
        }catch(e){ console.warn('hook saveState failed', e); }

        try{
            const originalSaveReq = window.saveRequestedMap;
            window.saveRequestedMap = function(map){
                try{ if(typeof originalSaveReq === 'function') originalSaveReq(map); }catch(e){ console.warn('original saveRequestedMap failed', e); }
                try{ saveStateToRemoteDebounced({ pk_requested: map || JSON.parse(localStorage.getItem('pk_requested')||'{}') }); }catch(e){ console.warn('remote saveRequestedMap failed', e); }
            };
        }catch(e){ console.warn('hook saveRequestedMap failed', e); }

        console.log('Firebase realtime sync initialized (Firestore).');
    })();
    </script>
    <!-- Barcode / naming modal -->
    <div id="barcode-modal" class="barcode-modal" aria-hidden="true">
        <h3>Abastecer Kamban — escanea o escribe nombre</h3>
        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
            <input id="barcode-line-input" type="text" placeholder="Línea (ej. PK1)" style="flex:1;padding:8px;border:1px solid rgba(0,0,0,0.08);border-radius:6px" />
        </div>
        <details id="barcode-lines-list" style="margin-top:8px">
            <summary style="cursor:pointer;font-weight:700">Líneas existentes</summary>
            <ul id="barcode-lines-ul" style="list-style:none;padding:6px;margin:6px 0;max-height:160px;overflow:auto"></ul>
        </details>
        <div style="margin-top:8px">Escanea la orden de producción</div>
        <input id="barcode-input" type="text" style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);margin-top:6px;font-size:16px" placeholder="Escanea la orden de producción" />
        <div class="scan-list" id="barcode-scan-list"></div>
        <div class="modal-actions">
            <button id="barcode-cancel" class="btn" style="margin-left:auto">Cancelar</button>
        </div>
    </div>
    <!-- debug modal removed per user request -->
    <script>
    // top-info helpers: update current datetime and durations list
    (function(){
        function fmtDateTime(d){
            try{ return d.toLocaleString(); }catch(e){ return (new Date()).toString(); }
        }

        function formatDuration(ms){
            if(ms < 1000) return 'justo ahora';
            let s = Math.floor(ms/1000);
            const days = Math.floor(s/86400); s-= days*86400;
            const hours = Math.floor(s/3600); s-= hours*3600;
            const minutes = Math.floor(s/60); s-= minutes*60;
            const parts = [];
            if(days) parts.push(days + 'd');
            if(hours) parts.push(hours + 'h');
            if(minutes) parts.push(minutes + 'm');
            if(s) parts.push(s + 's');
            return parts.join(' ');
        }

        function updateDateTime(){
            const dtEl = document.getElementById('current-datetime');
            if(dtEl) dtEl.textContent = fmtDateTime(new Date());
        }

        function updateEmptyDurationsDisplay(){
            const listEl = document.getElementById('empty-durations-list');
            if(!listEl) return;
            listEl.innerHTML = '';
            let map = {};
            try{ map = JSON.parse(localStorage.getItem('pk_empty_since')||'{}'); }catch(e){ map = {}; }
            const entries = Object.keys(map).map(k=> ({name:k, since: parseInt(map[k],10)||0}));
            entries.sort((a,b)=> (a.since||0) - (b.since||0));
            entries.forEach(e=>{
                const li = document.createElement('li');
                const dur = e.since ? formatDuration(Date.now() - e.since) : 'desconocido';
                li.textContent = `${e.name} — ${dur}`;
                listEl.appendChild(li);
            });
        }

        function updateSolicitudDurationsDisplay(){
            const listEl = document.getElementById('empty-durations-list');
            if(!listEl) return;
            listEl.innerHTML = '';
            let map = {};
            try{ map = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ map = {}; }
            const entries = Object.keys(map)
                .filter(k => map[k] && map[k].solicitud)
                .map(k=> ({ name: k, solicitud: parseInt(map[k].solicitud,10)||0, salida: parseInt((map[k].salida||0),10)||0 }));
            entries.sort((a,b)=> (a.solicitud||0) - (b.solicitud||0));
            // show active requests (no salida) first in red
            const active = entries.filter(x => x.solicitud && !x.salida).sort((a,b)=> (a.solicitud||0) - (b.solicitud||0));
            active.forEach(e => {
                const li = document.createElement('li');
                li.className = 'current';
                const nameSpan = document.createElement('span'); nameSpan.className = 'name'; nameSpan.textContent = e.name;
                const timeSpan = document.createElement('span'); timeSpan.className = 'time'; timeSpan.textContent = e.solicitud ? formatDuration(Date.now() - e.solicitud) : 'justo ahora';
                li.appendChild(nameSpan);
                li.appendChild(timeSpan);
                listEl.appendChild(li);
            });

            // also show recently completed requests (show 0s) for a short grace period so the top card shows stopped time
            const RECENT_MS = 10000; // show completed entries for 10s
            const now = Date.now();
            const recent = entries.filter(x => x.salida && (now - x.salida) <= RECENT_MS).sort((a,b)=> (b.salida||0) - (a.salida||0));
            recent.forEach(e => {
                const li = document.createElement('li');
                li.className = 'stopped';
                const nameSpan = document.createElement('span'); nameSpan.className = 'name'; nameSpan.textContent = e.name;
                const timeSpan = document.createElement('span'); timeSpan.className = 'time';
                const dur = (e.solicitud && e.salida) ? formatDuration((e.salida||0) - e.solicitud) : '0s';
                timeSpan.textContent = dur;
                li.appendChild(nameSpan);
                li.appendChild(timeSpan);
                listEl.appendChild(li);
            });
        }

        // initial update and interval
        updateDateTime(); updateSolicitudDurationsDisplay();
        // nota: renderRecentHistory ahora es manejado por historial.js
        setInterval(()=>{ updateDateTime(); updateSolicitudDurationsDisplay(); }, 1000);

        // expose for other code if needed
        window.updateEmptyDurationsDisplay = updateEmptyDurationsDisplay;
        window.updateSolicitudDurationsDisplay = updateSolicitudDurationsDisplay;
    })();
    </script>
    <!-- Debug module removed -->
    <!-- Monitor module (monitorea cambios en localStorage en consola) -->
    <script src="monitor.js"></script>
    <!-- Historial module (gestiona y muestra el historial de órdenes) -->
    <script src="historial.js"></script>
    <!-- LAYOUT: Botones arriba, búsqueda/gestionar abajo-izq, líneas derecha -->
    <div class="main-container">
        <!-- Fila superior: BOTONES -->
        <div class="top-controls">
            <button id="btn-entrada" class="color-box blue" type="button" aria-label="Abastecer Kamban">ABASTECER<br>KAMBAN</button>
            <button id="btn-salida" class="color-box green" type="button" aria-label="Abastecer AB">ABASTECER<br>AB</button>
            <button id="btn-anular-solicitud" class="color-box red" type="button" aria-label="Anular solicitud" style="background:linear-gradient(90deg,#ff6b6b,#ff5252);color:white;">ANULAR<br>SOLICITUD</button>
            <button id="btn-solicitar" class="color-box orange" type="button" aria-label="Solicitar parciales">SOLICITAR<br>PARCIALES</button>
        </div>
        <!-- Contenedor inferior: búsqueda izq, líneas der -->
        <div class="bottom-container">
            <!-- Panel izquierdo: búsqueda y gestionar -->
            <div class="controls">
                <!-- 'NOMBRE DE LA LÍNEA' y buscador removidos por petición del usuario. -->
                <!-- Mantener un input oculto con id 'line-name' para compatibilidad con el JS existente. -->
                <input id="line-name" type="text" value="" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;border:0;padding:0;margin:0" aria-hidden="true" />
                <div id="control-status" class="status" aria-live="polite" style="font-size:11px;color:#333;display:none"></div>
                <button id="manage-lines-btn" class="manage-btn" type="button">Gestionar líneas</button>
                <!-- moved info panel (fecha y duraciones) -->
                <div id="top-info" class="top-info" aria-live="polite">
                    <div id="current-datetime" class="now">--</div>
                    <div class="durations">
                        <div style="font-size:12px;opacity:0.9;margin-top:6px">Tiempo de gestión (solicitud → salida):</div>
                        <ul id="empty-durations-list"></ul>
                    </div>
                </div>
                <!-- Buscador de órdenes -->
                <div class="search-row" style="margin-top:8px">
                    <input id="order-search" class="search-input" type="search" placeholder="Buscar en historial (ej. 12721111)" aria-label="Buscar en historial" />
                    <button id="order-search-clear" class="search-clear" title="Limpiar búsqueda">✕</button>
                </div>
                <!-- Historial de últimos parciales solicitados y tiempo hasta abastecer AB -->
                <div id="recent-history" class="top-info" aria-live="polite" style="margin-top:10px">
                    <div style="font-weight:700;margin-bottom:6px">Últimos 5 parciales abastecidos</div>
                    <ul id="recent-history-list" style="list-style:none;padding:6px;margin:0;max-height:200px;overflow:auto"></ul>
                    <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
                        <button id="export-history-csv" class="color-box" style="flex:0 0 auto;height:36px;padding:6px 10px;font-size:13px;background:#2563eb">Exportar Excel</button>
                    </div>
                </div>
            </div>
            <!-- Panel izquierdo: líneas y parciales -->
            <div class="right-panel">
                <div class="container">
        <div class="column">
            <div class="column-header">PKB1</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB2</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB3</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB4</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB5</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">PKB6</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">JVH2</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">EYS</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
        <div class="column">
            <div class="column-header">MAQ</div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
            <div class="block"></div>
        </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // attach manage button behavior (runs after controls exist)
        (function(){
            const btn = document.getElementById('manage-lines-btn');
            const panel = document.getElementById('manage-panel');
            const closeBtn = document.getElementById('m-btn-close');
            if(!btn || !panel) return;
            function openPanel(){ panel.classList.add('open'); panel.setAttribute('aria-hidden','false'); }
            function closePanel(){ panel.classList.remove('open'); panel.setAttribute('aria-hidden','true'); }
            btn.addEventListener('click', ()=>{ openPanel(); });
            closeBtn && closeBtn.addEventListener('click', closePanel);
            // close on Escape
            window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closePanel(); });
        })();
    </script>

    <script>
    // buscador de órdenes: filtra y resalta bloques que contienen el texto buscado
    (function(){
        const input = document.getElementById('order-search');
        const clearBtn = document.getElementById('order-search-clear');
        if(!input) return;

        function normalize(s){ return String(s||'').trim().toLowerCase(); }

        function applyFilter(){
            const q = normalize(input.value);
            const historyItems = Array.from(document.querySelectorAll('#recent-history-list li'));
            let firstHistMatch = null;
            if(!q){
                historyItems.forEach(li => li.classList.remove('history-dim','history-match'));
                return;
            }
            // search history list only
            historyItems.forEach(li =>{
                const text = normalize(li.textContent || li.innerText || '');
                if(text.indexOf(q) !== -1){
                    li.classList.add('history-match');
                    li.classList.remove('history-dim');
                    if(!firstHistMatch) firstHistMatch = li;
                } else {
                    li.classList.add('history-dim');
                    li.classList.remove('history-match');
                }
            });
            // scroll first history match into view
            if(firstHistMatch){
                try{ firstHistMatch.scrollIntoView({ behavior: 'smooth', block: 'center' }); }catch(e){}
            }
        }

        input.addEventListener('input', applyFilter);
        input.addEventListener('search', applyFilter);
        clearBtn && clearBtn.addEventListener('click', ()=>{ input.value=''; input.focus(); applyFilter(); });

        // expose for debugging
        window.pkFilterOrders = applyFilter;

        // attach export buttons (if module exists later, they'll call it)
        function attachExportButtons(){
            const btnCsv = document.getElementById('export-history-csv');
            const btnJson = document.getElementById('export-history-json');
            if(btnCsv){ btnCsv.addEventListener('click', ()=>{ if(window.historialModule && window.historialModule.exportCSV) window.historialModule.exportCSV(); else alert('Módulo historial no disponible aún. Intenta de nuevo.'); }); }
            if(btnJson){ btnJson.addEventListener('click', ()=>{ if(window.historialModule && window.historialModule.exportar) window.historialModule.exportar(); else alert('Módulo historial no disponible aún. Intenta de nuevo.'); }); }
        }
        // intentar conectar inmediatamente y también tras carga completa
        attachExportButtons();
        window.addEventListener('DOMContentLoaded', attachExportButtons);
    })();
    </script>

    <!-- Gestión: lógica embebida que reemplaza manage-lines.html -->
    <script>
    (function(){
        const STORAGE_KEY = 'pk_lines';
        const listEl = document.getElementById('m-lines-list');
        const btnAdd = document.getElementById('m-btn-add');
        const btnSave = document.getElementById('m-btn-save');
    const btnReset = null;
        const openMain = document.getElementById('open-main');

        function defaultLines(){
            const out = [];
            for(let i=1;i<=10;i++) out.push({ name: 'PK'+i, count: 0 });
            return out;
        }

        function load(){
            try{
                const raw = localStorage.getItem(STORAGE_KEY);
                if(raw){
                    const parsed = JSON.parse(raw);
                    if(Array.isArray(parsed)) return parsed;
                }
                // no stored state: try to infer from current DOM so the manage panel reflects actual parciales
                try{
                    const cols = Array.from(document.querySelectorAll('.container > .column'));
                    if(cols.length > 0){
                        return cols.map(c=>({ name: (c.querySelector('.column-header')||{textContent:''}).textContent.trim(), count: c.querySelectorAll('.block').length }));
                    }
                }catch(e){/* ignore DOM read errors */}
            }catch(e){ console.error(e) }
            return defaultLines();
        }

        function save(lines){
            try{
                localStorage.setItem(STORAGE_KEY, JSON.stringify(lines));
                return true;
            }catch(e){ console.error(e); return false; }
        }

        function render(){
            const lines = load();
            listEl.innerHTML = '';
            lines.forEach((l,idx)=>{
                const row = document.createElement('div'); row.className = 'manage-item';
                const name = document.createElement('input'); name.type='text'; name.value = l.name;
                // mostrar la cantidad como texto (no editable)
                const countSpan = document.createElement('div'); countSpan.style.minWidth = '48px'; countSpan.style.padding = '8px'; countSpan.style.borderRadius = '8px'; countSpan.style.background = 'rgba(0,0,0,0.03)'; countSpan.style.textAlign = 'center'; countSpan.textContent = String(l.count || 0);
                const chkActive = document.createElement('input');
                chkActive.type = 'checkbox';
                chkActive.checked = (l.active !== false);
                chkActive.title = 'Línea activa';
                chkActive.style.width = '18px';
                chkActive.style.height = '18px';
                chkActive.style.cursor = 'pointer';
                const del = document.createElement('button'); del.className='btn btn-del'; del.textContent='Eliminar';
                del.addEventListener('click', ()=>{ lines.splice(idx,1); save(lines); render(); window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY})); });
                // update on change
                name.addEventListener('change', ()=>{ lines[idx].name = name.value.trim() || ('PK'+(idx+1)); save(lines); render(); window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY})); });
                // count is not editable from the manage UI per user request
                chkActive.addEventListener('change', ()=>{
                    lines[idx].active = !!chkActive.checked;
                    save(lines);
                    render();
                    try{ if(window.applyLinesToDOM) window.applyLinesToDOM(lines); }catch(e){}
                    // if deactivating, remove timestamp
                    if(!lines[idx].active){
                        try{
                            const mapRaw = localStorage.getItem('pk_empty_since');
                            const map = mapRaw ? JSON.parse(mapRaw) : {};
                            if(map[lines[idx].name]){ delete map[lines[idx].name]; localStorage.setItem('pk_empty_since', JSON.stringify(map)); }
                        }catch(e){}
                    }
                    window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY}));
                });
                row.appendChild(name); row.appendChild(countSpan); row.appendChild(chkActive); row.appendChild(del);
                listEl.appendChild(row);
            });
        }

        btnAdd && btnAdd.addEventListener('click', ()=>{
            const nameInput = document.getElementById('m-new-name');
            const name = (nameInput.value || '').trim();
            const defaultCount = 0; // fixed default now 0 per user request
            if(!name){ nameInput.focus(); return; }
            if(!confirm(`¿Añadir nueva línea "${name}"?`)) return;
            const lines = load();
            lines.push({ name, count: defaultCount });
            save(lines);
            nameInput.value = '';
            render();
            // notify other tabs via storage event
            window.dispatchEvent(new StorageEvent('storage',{key:STORAGE_KEY}));
        });

        // manejar botón "Solicitar parcial"
        (function(){
            const solicitar = document.getElementById('btn-solicitar');
            if(!solicitar) return;
            solicitar.addEventListener('click', ()=>{
                const selected = Array.from(document.querySelectorAll('.block.selected-parcial'));
                if(selected.length === 0){
                    try{ status.textContent = 'Selecciona primero uno o más parciales para solicitar.'; }catch(e){}
                    return;
                }
                if(!confirm(`¿Solicitar ${selected.length} parcial(es)?`)) return;
                // ensure data attributes are present
                try{ ensureBlockDataAttributes(); }catch(e){}

                let added = 0, removed = 0;
                const reqMap = getRequestedMap();
                // load or create solicitud map once
                let solicitudMap = {};
                try{ solicitudMap = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ solicitudMap = {}; }

                selected.forEach(s => {
                    try{
                        let lineName = s.getAttribute('data-line') || ((s.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent;
                        lineName = (lineName||'').trim();
                        const idx = parseInt(s.getAttribute('data-index')||'-1',10);
                        if(!lineName || !Number.isFinite(idx)){
                            // toggle visual only
                            if(s.classList.contains('requested')){ s.classList.remove('requested'); removed++; }
                            else { s.classList.add('requested'); added++; }
                            s.classList.remove('selected-parcial');
                            return;
                        }

                        // normalize key to avoid whitespace/case mismatches
                        const key = lineName;
                        const arr = Array.isArray(reqMap[key]) ? reqMap[key].slice() : [];
                        const pos = arr.indexOf(idx);
                        if(s.classList.contains('requested') || pos !== -1){
                            // remove request
                            s.classList.remove('requested');
                            if(pos !== -1) arr.splice(pos,1);
                            removed++;
                            // if no more requested for this line, we don't delete solicitud timestamp here (keep for history)
                        } else {
                            // add request
                            s.classList.add('requested');
                            if(pos === -1) arr.push(idx);
                            added++;
                            // set solicitud timestamp for this line (overwrite to now)
                            solicitudMap[key] = solicitudMap[key] || {};
                            solicitudMap[key].solicitud = Date.now();
                            delete solicitudMap[key].salida; // clear salida while new request open
                            try{ console.log('saved solicitud for', key, solicitudMap[key].solicitud); }catch(e){}
                        }

                        if(arr.length > 0) reqMap[key] = Array.from(new Set(arr)).sort((a,b)=>a-b); else delete reqMap[key];
                        s.classList.remove('selected-parcial');
                    }catch(err){ console.error('solicitar loop error', err); }
                });

                // persist both maps
                try{ saveRequestedMap(reqMap); localStorage.setItem('pk_solicitud_salida', JSON.stringify(solicitudMap)); try{ console.log('saved pk_requested for', Object.keys(reqMap)); }catch(e){} }catch(e){ console.error('failed to save request maps', e); }

                // refresh timers immediately after toggling requests
                try{ ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); }catch(e){ console.error('timer refresh failed', e); }

                // status message
                try{
                    if(added > 0 && removed === 0) status.textContent = `${added} parcial(es) solicitados.`;
                    else if(removed > 0 && added === 0) status.textContent = `${removed} solicitud(es) cancelada(s).`;
                    else status.textContent = `${added} solicitados, ${removed} cancelados.`;
                }catch(e){ }
            });
        })();

        // manejar botón "Anular solicitud"
        (function(){
            const btnAnular = document.getElementById('btn-anular-solicitud');
            if(!btnAnular) return;
            btnAnular.addEventListener('click', ()=>{
                // Find all requested parcials (those with 'requested' class)
                const requested = Array.from(document.querySelectorAll('.block.requested'));
                if(requested.length === 0){
                    try{ status.textContent = 'No hay solicitudes activas para anular.'; }catch(e){}
                    return;
                }
                
                // Ask for password
                const password = prompt('Ingresa la clave para anular solicitud:', '');
                if(password === null) return; // user cancelled
                
                const correctPassword = 'AB135';
                if(password !== correctPassword){
                    alert('❌ Clave incorrecta. La solicitud no ha sido anulada.');
                    return;
                }
                
                // Password correct, proceed with cancellation
                try{ ensureBlockDataAttributes(); }catch(e){}
                
                let canceled = 0;
                const reqMap = getRequestedMap();
                let solicitudMap = {};
                try{ solicitudMap = JSON.parse(localStorage.getItem('pk_solicitud_salida')||'{}'); }catch(e){ solicitudMap = {}; }
                
                requested.forEach(s => {
                    try{
                        let lineName = s.getAttribute('data-line') || ((s.closest('.column')||{}).querySelector('.column-header')||{textContent:''}).textContent;
                        lineName = (lineName||'').trim();
                        const idx = parseInt(s.getAttribute('data-index')||'-1',10);
                        if(!lineName || !Number.isFinite(idx)) return;
                        
                        const key = lineName;
                        const arr = Array.isArray(reqMap[key]) ? reqMap[key].slice() : [];
                        const pos = arr.indexOf(idx);
                        
                        // Remove from requested
                        s.classList.remove('requested');
                        if(pos !== -1) arr.splice(pos, 1);
                        canceled++;
                        
                        // Update maps
                        if(arr.length > 0) reqMap[key] = Array.from(new Set(arr)).sort((a,b)=>a-b);
                        else delete reqMap[key];
                        
                        // Clear solicitud timestamp if no more requested items for this line
                        if(arr.length === 0){
                            delete solicitudMap[key];
                        }
                    }catch(err){ console.error('anular loop error', err); }
                });
                
                // Persist changes
                try{ saveRequestedMap(reqMap); localStorage.setItem('pk_solicitud_salida', JSON.stringify(solicitudMap)); }catch(e){ console.error('failed to save anular changes', e); }
                
                // Refresh timers and UI
                try{ ensureTimerElements(); updateColumnTimers(); window.updateSolicitudDurationsDisplay && window.updateSolicitudDurationsDisplay(); }catch(e){ console.error('timer refresh failed', e); }
                
                // Status message
                try{
                    status.style.display = 'block';
                    status.textContent = `✅ ${canceled} solicitud(es) anulada(s) correctamente.`;
                    setTimeout(()=>{ status.textContent = ''; status.style.display = 'none'; }, 3000);
                }catch(e){}
            });
        })();

        btnSave && btnSave.addEventListener('click', ()=>{
            if(!confirm('¿Guardar cambios en la gestión de líneas?')) return;
            const lines = load();
            const ok = save(lines);
            if(ok){
                // apply immediately to main UI in same tab
                try{ if(window.applyLinesToDOM) window.applyLinesToDOM(lines); }catch(e){}
                alert('✅ Cambios guardados.');
            } else alert('❌ Error al guardar.');
        });

        // reset button removed per user request

        // initial
        render();
    })();
    </script>
</body>
</html>
